{"version":3,"file":"browser.global.js","sources":["../src/compat/array/castArray.ts","../src/compat/_internal/toArray.ts","../src/compat/predicate/isArrayLike.ts","../src/predicate/isLength.ts","../src/compat/array/chunk.ts","../src/array/chunk.ts","../src/compat/array/compact.ts","../src/array/compact.ts","../src/array/flatten.ts","../src/compat/array/concat.ts","../src/function/identity.ts","../src/_internal/isUnsafeProperty.ts","../src/compat/_internal/isDeepKey.ts","../src/compat/_internal/toKey.ts","../src/compat/util/toPath.ts","../src/compat/object/get.ts","../src/compat/object/property.ts","../src/compat/predicate/isObject.ts","../src/predicate/isPrimitive.ts","../src/compat/util/eq.ts","../src/compat/predicate/isMatchWith.ts","../src/compat/predicate/isMatch.ts","../src/compat/_internal/getSymbols.ts","../src/compat/_internal/getTag.ts","../src/compat/_internal/tags.ts","../src/predicate/isTypedArray.ts","../src/object/cloneDeepWith.ts","../src/object/cloneDeep.ts","../src/compat/predicate/matches.ts","../src/compat/object/cloneDeepWith.ts","../src/compat/object/cloneDeep.ts","../src/compat/_internal/isIndex.ts","../src/compat/predicate/isArguments.ts","../src/compat/object/has.ts","../src/compat/predicate/matchesProperty.ts","../src/compat/util/iteratee.ts","../src/compat/array/countBy.ts","../src/array/difference.ts","../src/compat/predicate/isObjectLike.ts","../src/compat/predicate/isArrayLikeObject.ts","../src/compat/array/difference.ts","../src/array/last.ts","../src/compat/array/last.ts","../src/compat/_internal/flattenArrayLike.ts","../src/compat/array/differenceBy.ts","../src/array/differenceBy.ts","../src/compat/array/differenceWith.ts","../src/array/differenceWith.ts","../src/compat/predicate/isSymbol.ts","../src/compat/util/toNumber.ts","../src/compat/util/toFinite.ts","../src/compat/util/toInteger.ts","../src/compat/array/drop.ts","../src/array/drop.ts","../src/compat/array/dropRight.ts","../src/array/dropRight.ts","../src/array/dropRightWhile.ts","../src/compat/array/dropRightWhile.ts","../src/array/dropWhile.ts","../src/compat/array/dropWhile.ts","../src/math/range.ts","../src/compat/array/forEach.ts","../src/compat/array/forEachRight.ts","../src/compat/_internal/isIterateeCall.ts","../src/compat/array/every.ts","../src/compat/predicate/isString.ts","../src/compat/array/fill.ts","../src/array/fill.ts","../src/compat/array/filter.ts","../src/compat/array/find.ts","../src/compat/array/findIndex.ts","../src/compat/array/findLast.ts","../src/compat/array/findLastIndex.ts","../src/compat/array/head.ts","../src/array/head.ts","../src/compat/array/flatten.ts","../src/compat/array/flattenDepth.ts","../src/compat/array/map.ts","../src/predicate/isNil.ts","../src/compat/array/flatMap.ts","../src/compat/array/flatMapDepth.ts","../src/compat/array/flatMapDeep.ts","../src/compat/array/flattenDeep.ts","../src/compat/array/groupBy.ts","../src/array/groupBy.ts","../src/compat/array/includes.ts","../src/compat/array/indexOf.ts","../src/compat/array/initial.ts","../src/array/initial.ts","../src/array/intersection.ts","../src/array/uniq.ts","../src/compat/array/intersection.ts","../src/array/intersectionBy.ts","../src/compat/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/compat/array/uniq.ts","../src/compat/array/intersectionWith.ts","../src/predicate/isBuffer.ts","../src/predicate/isPlainObject.ts","../src/predicate/isEqualWith.ts","../src/function/noop.ts","../src/predicate/isEqual.ts","../src/predicate/isFunction.ts","../src/predicate/isNull.ts","../src/predicate/isSymbol.ts","../src/predicate/isUndefined.ts","../src/compat/array/invokeMap.ts","../src/compat/array/join.ts","../src/compat/array/reduce.ts","../src/compat/array/keyBy.ts","../src/compat/array/lastIndexOf.ts","../src/compat/array/nth.ts","../src/compat/_internal/compareValues.ts","../src/compat/_internal/isKey.ts","../src/compat/array/orderBy.ts","../src/compat/array/partition.ts","../src/array/pull.ts","../src/compat/array/pull.ts","../src/compat/array/pullAll.ts","../src/compat/array/pullAllBy.ts","../src/compat/array/pullAllWith.ts","../src/compat/_internal/copyArray.ts","../src/compat/object/at.ts","../src/compat/object/unset.ts","../src/compat/predicate/isArray.ts","../src/compat/array/pullAt.ts","../src/compat/array/reduceRight.ts","../src/compat/function/negate.ts","../src/compat/array/reject.ts","../src/compat/array/remove.ts","../src/array/remove.ts","../src/compat/array/reverse.ts","../src/array/sample.ts","../src/compat/array/sample.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/compat/math/clamp.ts","../src/math/clamp.ts","../src/compat/predicate/isMap.ts","../src/predicate/isMap.ts","../src/compat/util/toArray.ts","../src/compat/array/sampleSize.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/compat/object/values.ts","../src/compat/predicate/isNil.ts","../src/compat/array/shuffle.ts","../src/compat/array/size.ts","../src/compat/array/slice.ts","../src/compat/array/some.ts","../src/compat/array/sortBy.ts","../src/compat/predicate/isNaN.ts","../src/compat/array/sortedIndexBy.ts","../src/compat/predicate/isNumber.ts","../src/compat/array/sortedIndex.ts","../src/compat/array/sortedIndexOf.ts","../src/compat/array/sortedLastIndexBy.ts","../src/compat/array/sortedLastIndex.ts","../src/compat/array/sortedLastIndexOf.ts","../src/compat/array/tail.ts","../src/array/tail.ts","../src/compat/array/take.ts","../src/array/take.ts","../src/compat/array/takeRight.ts","../src/array/takeRight.ts","../src/compat/array/takeRightWhile.ts","../src/function/negate.ts","../src/compat/function/identity.ts","../src/compat/array/takeWhile.ts","../src/compat/array/union.ts","../src/array/uniqBy.ts","../src/compat/array/unionBy.ts","../src/array/uniqWith.ts","../src/compat/array/unionWith.ts","../src/compat/array/uniqBy.ts","../src/compat/array/uniqWith.ts","../src/array/unzip.ts","../src/compat/array/unzip.ts","../src/compat/array/unzipWith.ts","../src/compat/array/without.ts","../src/array/without.ts","../src/compat/array/xor.ts","../src/array/windowed.ts","../src/compat/array/xorBy.ts","../src/compat/array/xorWith.ts","../src/array/zip.ts","../src/compat/array/zip.ts","../src/compat/_internal/assignValue.ts","../src/compat/array/zipObject.ts","../src/compat/object/updateWith.ts","../src/compat/object/set.ts","../src/compat/array/zipObjectDeep.ts","../src/compat/array/zipWith.ts","../src/compat/function/after.ts","../src/compat/function/ary.ts","../src/function/ary.ts","../src/compat/function/attempt.ts","../src/compat/function/before.ts","../src/compat/function/bind.ts","../src/compat/function/bindKey.ts","../src/compat/function/curry.ts","../src/compat/function/curryRight.ts","../src/function/debounce.ts","../src/compat/function/debounce.ts","../src/compat/function/defer.ts","../src/compat/function/delay.ts","../src/compat/function/flip.ts","../src/function/flow.ts","../src/compat/function/flow.ts","../src/compat/function/flowRight.ts","../src/function/flowRight.ts","../src/compat/function/memoize.ts","../src/compat/function/nthArg.ts","../src/compat/function/once.ts","../src/function/once.ts","../src/compat/function/overArgs.ts","../src/compat/function/partial.ts","../src/function/partial.ts","../src/compat/function/partialRight.ts","../src/function/partialRight.ts","../src/compat/function/rearg.ts","../src/compat/function/rest.ts","../src/function/rest.ts","../src/compat/function/spread.ts","../src/compat/function/throttle.ts","../src/compat/function/unary.ts","../src/compat/function/wrap.ts","../src/compat/util/toString.ts","../src/compat/math/add.ts","../src/compat/_internal/decimalAdjust.ts","../src/compat/math/ceil.ts","../src/compat/math/divide.ts","../src/compat/math/floor.ts","../src/compat/math/inRange.ts","../src/math/inRange.ts","../src/compat/math/max.ts","../src/compat/math/maxBy.ts","../src/array/maxBy.ts","../src/compat/math/sumBy.ts","../src/compat/math/sum.ts","../src/compat/math/mean.ts","../src/compat/math/meanBy.ts","../src/math/meanBy.ts","../src/math/mean.ts","../src/math/sum.ts","../src/compat/math/min.ts","../src/compat/math/minBy.ts","../src/array/minBy.ts","../src/compat/math/multiply.ts","../src/compat/math/parseInt.ts","../src/compat/math/random.ts","../src/compat/math/range.ts","../src/compat/math/rangeRight.ts","../src/compat/math/round.ts","../src/compat/math/subtract.ts","../src/compat/function/noop.ts","../src/compat/_internal/isPrototype.ts","../src/compat/predicate/isTypedArray.ts","../src/compat/util/times.ts","../src/compat/object/keys.ts","../src/compat/object/assign.ts","../src/compat/object/keysIn.ts","../src/compat/object/assignIn.ts","../src/compat/object/assignInWith.ts","../src/compat/object/assignWith.ts","../src/compat/object/clone.ts","../src/compat/object/cloneWith.ts","../src/compat/object/create.ts","../src/compat/object/defaults.ts","../src/compat/predicate/isPlainObject.ts","../src/compat/object/defaultsDeep.ts","../src/compat/object/findKey.ts","../src/object/findKey.ts","../src/compat/object/findLastKey.ts","../src/compat/object/forIn.ts","../src/compat/object/forInRight.ts","../src/compat/object/forOwn.ts","../src/compat/object/forOwnRight.ts","../src/compat/object/fromPairs.ts","../src/compat/object/functions.ts","../src/compat/object/functionsIn.ts","../src/compat/object/hasIn.ts","../src/compat/object/invert.ts","../src/object/invert.ts","../src/compat/object/invertBy.ts","../src/compat/object/mapKeys.ts","../src/object/mapKeys.ts","../src/compat/object/mapValues.ts","../src/object/mapValues.ts","../src/compat/object/mergeWith.ts","../src/object/clone.ts","../src/compat/object/merge.ts","../src/compat/object/omit.ts","../src/compat/_internal/getSymbolsIn.ts","../src/compat/object/omitBy.ts","../src/compat/object/pick.ts","../src/compat/object/pickBy.ts","../src/compat/object/propertyOf.ts","../src/compat/object/result.ts","../src/compat/object/setWith.ts","../src/compat/object/toDefaulted.ts","../src/compat/_internal/mapToEntries.ts","../src/compat/_internal/setToEntries.ts","../src/compat/object/toPairs.ts","../src/compat/object/toPairsIn.ts","../src/compat/predicate/isBuffer.ts","../src/compat/object/transform.ts","../src/compat/object/update.ts","../src/compat/object/valuesIn.ts","../src/compat/predicate/isFunction.ts","../src/compat/predicate/isLength.ts","../src/compat/predicate/isNative.ts","../src/compat/predicate/isNull.ts","../src/compat/predicate/isUndefined.ts","../src/compat/predicate/conformsTo.ts","../src/compat/predicate/conforms.ts","../src/compat/predicate/isArrayBuffer.ts","../src/predicate/isArrayBuffer.ts","../src/compat/predicate/isBoolean.ts","../src/compat/predicate/isDate.ts","../src/predicate/isDate.ts","../src/compat/predicate/isElement.ts","../src/compat/predicate/isEmpty.ts","../src/function/after.ts","../src/compat/predicate/isEqualWith.ts","../src/compat/predicate/isError.ts","../src/compat/predicate/isFinite.ts","../src/compat/predicate/isInteger.ts","../src/compat/predicate/isRegExp.ts","../src/predicate/isRegExp.ts","../src/compat/predicate/isSafeInteger.ts","../src/compat/predicate/isSet.ts","../src/predicate/isSet.ts","../src/compat/predicate/isWeakMap.ts","../src/predicate/isWeakMap.ts","../src/compat/predicate/isWeakSet.ts","../src/predicate/isWeakSet.ts","../src/string/capitalize.ts","../src/compat/string/capitalize.ts","../src/compat/util/bindAll.ts","../src/string/words.ts","../src/compat/_internal/normalizeForCase.ts","../src/compat/string/camelCase.ts","../src/string/camelCase.ts","../src/string/deburr.ts","../src/compat/string/deburr.ts","../src/compat/string/endsWith.ts","../src/string/escape.ts","../src/compat/string/escape.ts","../src/compat/string/escapeRegExp.ts","../src/string/escapeRegExp.ts","../src/compat/string/kebabCase.ts","../src/string/kebabCase.ts","../src/compat/string/lowerCase.ts","../src/string/lowerCase.ts","../src/compat/string/lowerFirst.ts","../src/string/lowerFirst.ts","../src/compat/string/pad.ts","../src/string/pad.ts","../src/compat/string/padEnd.ts","../src/compat/string/padStart.ts","../src/compat/string/repeat.ts","../src/compat/string/replace.ts","../src/compat/string/snakeCase.ts","../src/string/snakeCase.ts","../src/compat/string/split.ts","../src/compat/string/startCase.ts","../src/compat/string/startsWith.ts","../src/compat/string/template.ts","../src/compat/string/toLower.ts","../src/compat/string/toUpper.ts","../src/string/trimEnd.ts","../src/string/trimStart.ts","../src/string/trim.ts","../src/compat/string/trim.ts","../src/compat/string/trimEnd.ts","../src/compat/string/trimStart.ts","../src/compat/string/truncate.ts","../src/string/unescape.ts","../src/compat/string/unescape.ts","../src/compat/string/upperCase.ts","../src/string/upperCase.ts","../src/compat/string/upperFirst.ts","../src/string/upperFirst.ts","../src/compat/string/words.ts","../src/compat/util/cond.ts","../src/compat/util/constant.ts","../src/compat/util/defaultTo.ts","../src/compat/util/gt.ts","../src/compat/util/gte.ts","../src/compat/util/invoke.ts","../src/compat/util/lt.ts","../src/compat/util/lte.ts","../src/compat/util/method.ts","../src/compat/util/methodOf.ts","../src/compat/util/now.ts","../src/compat/util/over.ts","../src/compat/util/overEvery.ts","../src/compat/util/overSome.ts","../src/compat/util/stubArray.ts","../src/compat/util/stubFalse.ts","../src/compat/util/stubObject.ts","../src/compat/util/stubString.ts","../src/compat/util/stubTrue.ts","../src/compat/util/toLength.ts","../src/compat/_internal/MAX_ARRAY_LENGTH.ts","../src/compat/util/toPlainObject.ts","../src/compat/_internal/MAX_SAFE_INTEGER.ts","../src/compat/util/toSafeInteger.ts","../src/compat/util/uniqueId.ts","../src/compat/toolkit.ts"],"sourcesContent":["/**\n * Casts value as an array if it's not one.\n *\n * @template T The type of elements in the array.\n * @param {T | T[]} value The value to be cast to an array.\n * @returns {T[]} An array containing the input value if it wasn't an array, or the original array if it was.\n *\n * @example\n * const arr1 = castArray(1);\n * // Returns: [1]\n *\n * const arr2 = castArray([1]);\n * // Returns: [1]\n *\n * const arr3 = castArray({'a': 1});\n * // Returns: [{'a': 1}]\n *\n * const arr4 = castArray(null);\n * // Returns: [null]\n *\n * const arr5 = castArray(undefined);\n * // Returns: [undefined]\n *\n * const arr6 = castArray();\n * // Returns: []\n */\n\nexport function castArray<T>(value?: T | readonly T[]): T[] {\n  if (arguments.length === 0) {\n    return [];\n  }\n\n  return Array.isArray(value) ? value : ([value] as T[]);\n}\n","export function toArray<T>(value: ArrayLike<T>): T[] {\n  return Array.isArray(value) ? value : Array.from(value);\n}\n","import { isLength } from '../../predicate/isLength.ts';\n\n/**\n * Checks if `value` is array-like. This overload is for compatibility with lodash type checking.\n *\n * @param {T} t The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nexport function isArrayLike<T extends { __lodashAnyHack: any }>(t: T): boolean;\n\n/**\n * Checks if `value` is array-like. Functions, null, and undefined are never array-like.\n *\n * @param {((...args: any[]) => any) | null | undefined} value The value to check.\n * @returns {value is never} Returns `false` for functions, null, and undefined.\n */\nexport function isArrayLike(value: ((...args: any[]) => any) | null | undefined): value is never;\n\n/**\n * Checks if `value` is array-like.\n *\n * @param {any} value The value to check.\n * @returns {value is { length: number }} Returns `true` if `value` is array-like, else `false`.\n */\nexport function isArrayLike(value: any): value is { length: number };\n\n/**\n * Checks if `value` is array-like.\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n *\n * @example\n * isArrayLike([1, 2, 3]); // true\n * isArrayLike('abc'); // true\n * isArrayLike({ 0: 'a', length: 1 }); // true\n * isArrayLike({}); // false\n * isArrayLike(null); // false\n * isArrayLike(undefined); // false\n */\nexport function isArrayLike(value?: any): boolean {\n  return value != null && typeof value !== 'function' && isLength((value as ArrayLike<unknown>).length);\n}\n","/**\n * Checks if a given value is a valid length.\n *\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\n * It returns `true` if the value is a valid length, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\n * argument to a valid length (`number`).\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n *\n * @example\n * isLength(0); // true\n * isLength(42); // true\n * isLength(-1); // false\n * isLength(1.5); // false\n * isLength(Number.MAX_SAFE_INTEGER); // true\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\n */\nexport function isLength(value?: any): boolean {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n","import { chunk as chunkToolkit } from '../../array/chunk.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: ArrayLike<T> | null | undefined, size = 1): T[][] {\n  size = Math.max(Math.floor(size), 0);\n\n  if (size === 0 || !isArrayLike(arr)) {\n    return [];\n  }\n\n  return chunkToolkit(toArray(arr), size);\n}\n","/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n * @throws {Error} Throws an error if `size` is not a positive integer.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: readonly T[], size: number): T[][] {\n  if (!Number.isInteger(size) || size <= 0) {\n    throw new Error('Size must be an integer greater than zero.');\n  }\n\n  const chunkLength = Math.ceil(arr.length / size);\n  const result: T[][] = Array(chunkLength);\n\n  for (let index = 0; index < chunkLength; index++) {\n    const start = index * size;\n    const end = start + size;\n\n    result[index] = arr.slice(start, end);\n  }\n\n  return result;\n}\n","import { compact as compactToolkit } from '../../array/compact.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\ntype Falsey = false | null | 0 | 0n | '' | undefined;\n\n/**\n * Removes falsey values (false, null, 0, 0n, '', undefined, NaN) from an array.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T | Falsey> | null | undefined} arr - The input array to remove falsey values.\n * @returns {Array<Exclude<T, false | null | 0 | 0n | '' | undefined>>} - A new array with all falsey values removed.\n *\n * @example\n * compact([0, 0n, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\n * Returns: [1, 2, 3, 4, 5]\n */\nexport function compact<T>(arr: ArrayLike<T | Falsey> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return compactToolkit(Array.from(arr));\n}\n","type NotFalsey<T> = Exclude<T, false | null | 0 | 0n | '' | undefined>;\n\n/**\n * Removes falsey values (false, null, 0, -0, 0n, '', undefined, NaN) from an array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The input array to remove falsey values.\n * @returns {Array<Exclude<T, false | null | 0 | 0n | '' | undefined>>} - A new array with all falsey values removed.\n *\n * @example\n * compact([0, -0, 0n, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\n * Returns: [1, 2, 3, 4, 5]\n */\nexport function compact<T>(arr: readonly T[]): Array<NotFalsey<T>> {\n  const result: Array<NotFalsey<T>> = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (item) {\n      result.push(item as NotFalsey<T>);\n    }\n  }\n\n  return result;\n}\n","/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\n        recursive(item, currentDepth + 1);\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(arr, 0);\n  return result;\n}\n","import { flatten } from '../../array/flatten.ts';\n\n/**\n * Concatenates multiple arrays and values into a single array.\n *\n * @template T The type of elements in the array.\n * @param {...(T | T[])} values - The values and/or arrays to concatenate.\n * @returns {T[]} A new array containing all the input values.\n *\n * @example\n * // Concatenate individual values\n * concat(1, 2, 3);\n * // returns [1, 2, 3]\n *\n * @example\n * // Concatenate arrays of values\n * concat([1, 2], [3, 4]);\n * // returns [1, 2, 3, 4]\n *\n * @example\n * // Concatenate a mix of individual values and arrays\n * concat(1, [2, 3], 4);\n * // returns [1, 2, 3, 4]\n *\n * @example\n * // Concatenate nested arrays\n * concat([1, [2, 3]], 4);\n * // returns [1, [2, 3], 4]\n */\nexport function concat<T>(...values: Array<T | readonly T[]>): T[] {\n  return flatten(values) as T[];\n}\n","/**\n * Returns the input value unchanged.\n *\n * @template T - The type of the input value.\n * @param {T} x - The value to be returned.\n * @returns {T} The input value.\n *\n * @example\n * // Returns 5\n * identity(5);\n *\n * @example\n * // Returns 'hello'\n * identity('hello');\n *\n * @example\n * // Returns { key: 'value' }\n * identity({ key: 'value' });\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","/**\n * Checks if a property key is unsafe to modify directly.\n *\n * This function is used in functions like `merge` to prevent prototype pollution attacks\n * by identifying property keys that could modify the object's prototype chain or constructor.\n *\n * @param key - The property key to check\n * @returns `true` if the property is unsafe to modify directly, `false` otherwise\n * @internal\n */\nexport function isUnsafeProperty(key: PropertyKey) {\n  return key === '__proto__';\n}\n","/**\n * Checks if a given key is a deep key.\n *\n * A deep key is a string that contains a dot (.) or square brackets with a property accessor.\n *\n * @param {PropertyKey} key - The key to check.\n * @returns {boolean} - Returns true if the key is a deep key, otherwise false.\n *\n * Examples:\n *\n * isDeepKey('a.b') // true\n * isDeepKey('a[b]') // true\n * isDeepKey('a') // false\n * isDeepKey(123) // false\n * isDeepKey('a.b.c') // true\n * isDeepKey('a[b][c]') // true\n */\nexport function isDeepKey(key: PropertyKey): boolean {\n  switch (typeof key) {\n    case 'number':\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return key.includes('.') || key.includes('[') || key.includes(']');\n    }\n  }\n}\n","/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nexport function toKey(value: any) {\n  if (typeof value === 'string' || typeof value === 'symbol') {\n    return value;\n  }\n  if (Object.is(value?.valueOf?.(), -0)) {\n    return '-0';\n  }\n  return String(value);\n}\n","/**\n * Converts a deep key string into an array of path segments.\n *\n * This function takes a string representing a deep key (e.g., 'a.b.c' or 'a[b][c]') and breaks it down into an array of strings, each representing a segment of the path.\n *\n * @param {any} deepKey - The deep key string to convert.\n * @returns {string[]} An array of strings, each representing a segment of the path.\n *\n * Examples:\n *\n * toPath('a.b.c') // Returns ['a', 'b', 'c']\n * toPath('a[b][c]') // Returns ['a', 'b', 'c']\n * toPath('.a.b.c') // Returns ['', 'a', 'b', 'c']\n * toPath('a[\"b.c\"].d') // Returns ['a', 'b.c', 'd']\n * toPath('') // Returns []\n * toPath('.a[b].c.d[e][\"f.g\"].h') // Returns ['', 'a', 'b', 'c', 'd', 'e', 'f.g', 'h']\n */\nexport function toPath(deepKey: any): string[] {\n  const result: string[] = [];\n  const length = deepKey.length;\n\n  if (length === 0) {\n    return result;\n  }\n\n  let index = 0;\n  let key = '';\n  let quoteChar = '';\n  let bracket = false;\n\n  // Leading dot\n  if (deepKey.charCodeAt(0) === 46) {\n    result.push('');\n    index++;\n  }\n\n  while (index < length) {\n    const char = deepKey[index];\n\n    if (quoteChar) {\n      if (char === '\\\\' && index + 1 < length) {\n        // Escape character\n        index++;\n        key += deepKey[index];\n      } else if (char === quoteChar) {\n        // End of quote\n        quoteChar = '';\n      } else {\n        key += char;\n      }\n    } else if (bracket) {\n      if (char === '\"' || char === \"'\") {\n        // Start of quoted string inside brackets\n        quoteChar = char;\n      } else if (char === ']') {\n        // End of bracketed segment\n        bracket = false;\n        result.push(key);\n        key = '';\n      } else {\n        key += char;\n      }\n    } else {\n      if (char === '[') {\n        // Start of bracketed segment\n        bracket = true;\n        if (key) {\n          result.push(key);\n          key = '';\n        }\n      } else if (char === '.') {\n        if (key) {\n          result.push(key);\n          key = '';\n        }\n      } else {\n        key += char;\n      }\n    }\n\n    index++;\n  }\n\n  if (key) {\n    result.push(key);\n  }\n\n  return result;\n}\n","import type { Get } from './get.types.ts';\nimport { isUnsafeProperty } from '../../_internal/isUnsafeProperty.ts';\nimport { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey\n * @param {TObject} object - The object to query.\n * @param {TKey | [TKey]} path - The path of the property to get.\n * @returns {TObject[TKey]} Returns the resolved value.\n *\n * @example\n * const object = { 'a': [{ 'b': { 'c': 3 } }] };\n * get(object, 'a[0].b.c');\n * // => 3\n */\nexport function get<TObject extends object, TKey extends keyof TObject>(\n  object: TObject,\n  path: TKey | [TKey]\n): TObject[TKey];\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey\n * @param {TObject | null | undefined} object - The object to query.\n * @param {TKey | [TKey]} path - The path of the property to get.\n * @returns {TObject[TKey] | undefined} Returns the resolved value.\n *\n * @example\n * const object = { 'a': [{ 'b': { 'c': 3 } }] };\n * get(object, 'a[0].b.c');\n * // => 3\n */\nexport function get<TObject extends object, TKey extends keyof TObject>(\n  object: TObject | null | undefined,\n  path: TKey | [TKey]\n): TObject[TKey] | undefined;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey\n * @template TDefault\n * @param {TObject | null | undefined} object - The object to query.\n * @param {TKey | [TKey]} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<TObject[TKey], undefined> | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { 'a': [{ 'b': { 'c': 3 } }] };\n * get(object, 'a[0].b.c', 'default');\n * // => 3\n */\nexport function get<TObject extends object, TKey extends keyof TObject, TDefault>(\n  object: TObject | null | undefined,\n  path: TKey | [TKey],\n  defaultValue: TDefault\n): Exclude<TObject[TKey], undefined> | TDefault;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @param {TObject} object - The object to query.\n * @param {[TKey1, TKey2]} path - The path of the property to get.\n * @returns {TObject[TKey1][TKey2]} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': 2 } };\n * get(object, ['a', 'b']);\n * // => 2\n */\nexport function get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(\n  object: TObject,\n  path: [TKey1, TKey2]\n): TObject[TKey1][TKey2];\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2]} path - The path of the property to get.\n * @returns {NonNullable<TObject[TKey1]>[TKey2] | undefined} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': 2 } };\n * get(object, ['a', 'b']);\n * // => 2\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof NonNullable<TObject[TKey1]>,\n>(object: TObject | null | undefined, path: [TKey1, TKey2]): NonNullable<TObject[TKey1]>[TKey2] | undefined;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TDefault\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2]} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<NonNullable<TObject[TKey1]>[TKey2], undefined> | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': 2 } };\n * get(object, ['a', 'b'], 'default');\n * // => 2\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof NonNullable<TObject[TKey1]>,\n  TDefault,\n>(\n  object: TObject | null | undefined,\n  path: [TKey1, TKey2],\n  defaultValue: TDefault\n): Exclude<NonNullable<TObject[TKey1]>[TKey2], undefined> | TDefault;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @param {TObject} object - The object to query.\n * @param {[TKey1, TKey2, TKey3]} path - The path of the property to get.\n * @returns {TObject[TKey1][TKey2][TKey3]} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': 3 } } };\n * get(object, ['a', 'b', 'c']);\n * // => 3\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof TObject[TKey1],\n  TKey3 extends keyof TObject[TKey1][TKey2],\n>(object: TObject, path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2, TKey3]} path - The path of the property to get.\n * @returns {NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3] | undefined} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': 3 } } };\n * get(object, ['a', 'b', 'c']);\n * // => 3\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof NonNullable<TObject[TKey1]>,\n  TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>,\n>(\n  object: TObject | null | undefined,\n  path: [TKey1, TKey2, TKey3]\n): NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3] | undefined;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @template TDefault\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2, TKey3]} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3], undefined> | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': 3 } } };\n * get(object, ['a', 'b', 'c'], 'default');\n * // => 3\n */\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @template TDefault\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2, TKey3]} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3], undefined> | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': 3 } } };\n * get(object, ['a', 'b', 'c'], 'default');\n * // => 3\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof NonNullable<TObject[TKey1]>,\n  TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>,\n  TDefault,\n>(\n  object: TObject | null | undefined,\n  path: [TKey1, TKey2, TKey3],\n  defaultValue: TDefault\n): Exclude<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3], undefined> | TDefault;\n\n/**\n * Gets the value at path of object.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @template TKey4\n * @param {TObject} object - The object to query.\n * @param {[TKey1, TKey2, TKey3, TKey4]} path - The path of the property to get.\n * @returns {TObject[TKey1][TKey2][TKey3][TKey4]} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': { 'd': 4 } } } };\n * get(object, ['a', 'b', 'c', 'd']);\n * // => 4\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof TObject[TKey1],\n  TKey3 extends keyof TObject[TKey1][TKey2],\n  TKey4 extends keyof TObject[TKey1][TKey2][TKey3],\n>(object: TObject, path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, undefined is returned.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @template TKey4\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2, TKey3, TKey4]} path - The path of the property to get.\n * @returns {NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>[TKey4] | undefined} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': { 'd': 4 } } } };\n * get(object, ['a', 'b', 'c', 'd']);\n * // => 4\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof NonNullable<TObject[TKey1]>,\n  TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>,\n  TKey4 extends keyof NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>,\n>(\n  object: TObject | null | undefined,\n  path: [TKey1, TKey2, TKey3, TKey4]\n): NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>[TKey4] | undefined;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TObject\n * @template TKey1\n * @template TKey2\n * @template TKey3\n * @template TKey4\n * @template TDefault\n * @param {TObject | null | undefined} object - The object to query.\n * @param {[TKey1, TKey2, TKey3, TKey4]} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>[TKey4], undefined> | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { 'a': { 'b': { 'c': { 'd': 4 } } } };\n * get(object, ['a', 'b', 'c', 'd'], 'default');\n * // => 4\n */\nexport function get<\n  TObject extends object,\n  TKey1 extends keyof TObject,\n  TKey2 extends keyof NonNullable<TObject[TKey1]>,\n  TKey3 extends keyof NonNullable<NonNullable<TObject[TKey1]>[TKey2]>,\n  TKey4 extends keyof NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>,\n  TDefault,\n>(\n  object: TObject | null | undefined,\n  path: [TKey1, TKey2, TKey3, TKey4],\n  defaultValue: TDefault\n): Exclude<NonNullable<NonNullable<NonNullable<TObject[TKey1]>[TKey2]>[TKey3]>[TKey4], undefined> | TDefault;\n\n/**\n * Gets the value at path of object.\n *\n * @template T\n * @param {Record<number, T>} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T} Returns the resolved value.\n *\n * @example\n * const object = { 0: 'a', 1: 'b', 2: 'c' };\n * get(object, 1);\n * // => 'b'\n */\nexport function get<T>(object: Record<number, T>, path: number): T;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, undefined is returned.\n *\n * @template T\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T | undefined} Returns the resolved value.\n *\n * @example\n * const object = { 0: 'a', 1: 'b', 2: 'c' };\n * get(object, 1);\n * // => 'b'\n */\nexport function get<T>(object: Record<number, T> | null | undefined, path: number): T | undefined;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template T\n * @template TDefault\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {T | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { 0: 'a', 1: 'b', 2: 'c' };\n * get(object, 1, 'default');\n * // => 'b'\n */\nexport function get<T, TDefault>(\n  object: Record<number, T> | null | undefined,\n  path: number,\n  defaultValue: TDefault\n): T | TDefault;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned in its place.\n *\n * @template TDefault\n * @param {null | undefined} object - The object to query.\n * @param {PropertyPath} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {TDefault} Returns the default value.\n *\n * @example\n * get(null, 'a.b.c', 'default');\n * // => 'default'\n */\nexport function get<TDefault>(object: null | undefined, path: PropertyPath, defaultValue: TDefault): TDefault;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, undefined is returned.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyPath} path - The path of the property to get.\n * @returns {undefined} Returns undefined.\n *\n * @example\n * get(null, 'a.b.c');\n * // => undefined\n */\nexport function get(object: null | undefined, path: PropertyPath): undefined;\n\n/**\n * Gets the value at path of object using type-safe path.\n *\n * @template TObject\n * @template TPath\n * @param {TObject} data - The object to query.\n * @param {TPath} path - The path of the property to get.\n * @returns {string extends TPath ? any : Get<TObject, TPath>} Returns the resolved value.\n *\n * @example\n * const object = { a: { b: { c: 1 } } };\n * get(object, 'a.b.c');\n * // => 1\n */\nexport function get<TObject, TPath extends string>(\n  data: TObject,\n  path: TPath\n): string extends TPath ? any : Get<TObject, TPath>;\n\n/**\n * Gets the value at path of object using type-safe path. If the resolved value is undefined, the defaultValue is returned.\n *\n * @template TObject\n * @template TPath\n * @template TDefault\n * @param {TObject} data - The object to query.\n * @param {TPath} path - The path of the property to get.\n * @param {TDefault} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<Get<TObject, TPath>, null | undefined> | TDefault} Returns the resolved value.\n *\n * @example\n * const object = { a: { b: { c: 1 } } };\n * get(object, 'a.b.d', 'default');\n * // => 'default'\n */\nexport function get<TObject, TPath extends string, TDefault = Get<TObject, TPath>>(\n  data: TObject,\n  path: TPath,\n  defaultValue: TDefault\n): Exclude<Get<TObject, TPath>, null | undefined> | TDefault;\n\n/**\n * Gets the value at path of object. If the resolved value is undefined, the defaultValue is returned.\n *\n * @param {any} object - The object to query.\n * @param {PropertyPath} path - The path of the property to get.\n * @param {any} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} Returns the resolved value.\n *\n * @example\n * const object = { a: { b: { c: 1 } } };\n * get(object, 'a.b.c', 'default');\n * // => 1\n */\nexport function get(object: any, path: PropertyPath, defaultValue?: any): any;\n\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @param {any} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @param {any} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} Returns the resolved value.\n *\n * @example\n * const object = { a: { b: { c: 1 } } };\n * get(object, 'a.b.c');\n * // => 1\n *\n * get(object, ['a', 'b', 'c']);\n * // => 1\n *\n * get(object, 'a.b.d', 'default');\n * // => 'default'\n */\nexport function get(object: any, path: PropertyKey | readonly PropertyKey[], defaultValue?: any): any {\n  if (object == null) {\n    return defaultValue;\n  }\n\n  switch (typeof path) {\n    case 'string': {\n      if (isUnsafeProperty(path)) {\n        return defaultValue;\n      }\n\n      const result = object[path];\n\n      if (result === undefined) {\n        if (isDeepKey(path)) {\n          return get(object, toPath(path), defaultValue);\n        } else {\n          return defaultValue;\n        }\n      }\n\n      return result;\n    }\n    case 'number':\n    case 'symbol': {\n      if (typeof path === 'number') {\n        path = toKey(path);\n      }\n\n      const result = object[path as PropertyKey];\n\n      if (result === undefined) {\n        return defaultValue;\n      }\n\n      return result;\n    }\n    default: {\n      if (Array.isArray(path)) {\n        return getWithPath(object, path, defaultValue);\n      }\n\n      if (Object.is(path?.valueOf(), -0)) {\n        path = '-0';\n      } else {\n        path = String(path);\n      }\n\n      if (isUnsafeProperty(path)) {\n        return defaultValue;\n      }\n\n      const result = object[path];\n\n      if (result === undefined) {\n        return defaultValue;\n      }\n\n      return result;\n    }\n  }\n}\n\nfunction getWithPath(object: any, path: readonly PropertyKey[], defaultValue?: any): any {\n  if (path.length === 0) {\n    return defaultValue;\n  }\n\n  let current = object;\n\n  for (let index = 0; index < path.length; index++) {\n    if (current == null) {\n      return defaultValue;\n    }\n\n    if (isUnsafeProperty(path[index])) {\n      return defaultValue;\n    }\n\n    current = current[path[index]];\n  }\n\n  if (current === undefined) {\n    return defaultValue;\n  }\n\n  return current;\n}\n","import { get } from './get.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\n\nexport function property<T, R>(path: PropertyPath): (obj: T) => R;\n\n/**\n * Creates a function that returns the value at a given path of an object.\n *\n * @template T - The type of object.\n * @template R - The type of the value to return.\n * @param {PropertyPath} path - The path of the property to get.\n * @returns {(object: T) => R} - Returns a new function that takes an object and returns the value at the specified path.\n *\n * @example\n * const getObjectValue = property('a.b.c');\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n *\n * @example\n * const getObjectValue = property(['a', 'b', 'c']);\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n */\nexport function property<T, R>(path: PropertyPath): (object: T) => R {\n  return function (object: T) {\n    return get(object, path);\n  };\n}\n","/**\n * Checks if the given value is an object. An object is a value that is\n * not a primitive type (string, number, boolean, symbol, null, or undefined).\n *\n * This function tests whether the provided value is an object or not.\n * It returns `true` if the value is an object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object value.\n *\n * @param {any} value - The value to check if it is an object.\n * @returns {value is object} `true` if the value is an object, `false` otherwise.\n *\n * @example\n * const value1 = {};\n * const value2 = [1, 2, 3];\n * const value3 = () => {};\n * const value4 = null;\n *\n * console.log(isObject(value1)); // true\n * console.log(isObject(value2)); // true\n * console.log(isObject(value3)); // true\n * console.log(isObject(value4)); // false\n */\n\nexport function isObject(value?: any): value is object {\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n","/**\n * Checks whether a value is a JavaScript primitive.\n * JavaScript primitives include null, undefined, strings, numbers, booleans, symbols, and bigints.\n *\n * @param {unknown} value The value to check.\n * @returns {value is\n *     null\n *   | undefined\n *   | string\n *   | number\n *   | boolean\n *   | symbol\n *   | bigint} Returns true if `value` is a primitive, false otherwise.\n *\n * @example\n * isPrimitive(null); // true\n * isPrimitive(undefined); // true\n * isPrimitive('123'); // true\n * isPrimitive(false); // true\n * isPrimitive(true); // true\n * isPrimitive(Symbol('a')); // true\n * isPrimitive(123n); // true\n * isPrimitive({}); // false\n * isPrimitive(new Date()); // false\n * isPrimitive(new Map()); // false\n * isPrimitive(new Set()); // false\n * isPrimitive([1, 2, 3]); // false\n */\nexport function isPrimitive(value: unknown): value is null | undefined | string | number | boolean | symbol | bigint {\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n","/**\n * Performs a `SameValueZero` comparison between two values to determine if they are equivalent.\n *\n * @param {any} value - The value to compare.\n * @param {any} other - The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n *\n * @example\n * eq(1, 1); // true\n * eq(0, -0); // true\n * eq(NaN, NaN); // true\n * eq('a', Object('a')); // false\n */\nexport function eq(value: any, other: any): boolean {\n  return value === other || (Number.isNaN(value) && Number.isNaN(other));\n}\n","import { isMatch } from './isMatch.ts';\nimport { isObject } from './isObject.ts';\nimport { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport type { IsMatchWithCustomizer } from '../_internal/IsMatchWithCustomizer.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Performs a deep comparison between a target value and a source pattern to determine if they match,\n * using a custom comparison function for fine-grained control over the matching logic.\n *\n * @param {object} target - The value to be tested for matching\n * @param {object} source - The pattern/template to match against\n * @param {IsMatchWithCustomizer} compare - Custom comparison function for fine-grained control\n * @returns {boolean} `true` if the target matches the source pattern, `false` otherwise\n *\n * @example\n * // Basic matching with custom comparator\n * const caseInsensitiveCompare = (objVal, srcVal) => {\n *   if (typeof objVal === 'string' && typeof srcVal === 'string') {\n *     return objVal.toLowerCase() === srcVal.toLowerCase();\n *   }\n *   return undefined;\n * };\n *\n * isMatchWith(\n *   { name: 'JOHN', age: 30 },\n *   { name: 'john' },\n *   caseInsensitiveCompare\n * ); // true\n */\nexport function isMatchWith(target: object, source: object, compare: IsMatchWithCustomizer): boolean;\n\n/**\n * Performs a deep comparison between a target value and a source pattern to determine if they match,\n * using a custom comparison function for fine-grained control over the matching logic.\n *\n * This function recursively traverses both values, calling the custom compare function for each\n * property/element pair. If the compare function returns a boolean, that result is used directly.\n * If it returns undefined, the default matching behavior continues recursively.\n *\n * The matching behavior varies by data type:\n * - **Objects**: Matches if all properties in the source exist in the target and match\n * - **Arrays**: Matches if all elements in the source array can be found in the target array (order-independent)\n * - **Maps**: Matches if all key-value pairs in the source Map exist and match in the target Map\n * - **Sets**: Matches if all elements in the source Set can be found in the target Set\n * - **Functions**: Matches using strict equality, or object comparison if the function has properties\n * - **Primitives**: Matches using strict equality\n *\n * Special cases:\n * - Empty objects, arrays, Maps, and Sets always match any target\n * - `null` and `undefined` source values have specific matching rules\n * - Circular references are handled using an internal stack to prevent infinite recursion\n *\n * @param {object} target - The value to be tested for matching\n * @param {object} source - The pattern/template to match against\n * @param {function} [compare] - Optional custom comparison function that receives:\n *   - `objValue` - The value from the target at the current path\n *   - `srcValue` - The value from the source at the current path\n *   - `key` - The property key or array index being compared\n *   - `object` - The parent object/array from the target\n *   - `source` - The parent object/array from the source\n *   - `stack` - Internal Map used for circular reference detection\n *   Should return `true` for a match, `false` for no match, or `undefined` to continue with default behavior\n *\n * @returns {boolean} `true` if the target matches the source pattern, `false` otherwise\n *\n * @example\n * // Basic matching without custom comparator\n * isMatchWith({ a: 1, b: 2 }, { a: 1 }); // true\n * isMatchWith([1, 2, 3], [1, 3]); // true\n *\n * @example\n * // Custom comparison for case-insensitive string matching\n * const caseInsensitiveCompare = (objVal, srcVal) => {\n *   if (typeof objVal === 'string' && typeof srcVal === 'string') {\n *     return objVal.toLowerCase() === srcVal.toLowerCase();\n *   }\n *   return undefined; // Use default behavior for non-strings\n * };\n *\n * isMatchWith(\n *   { name: 'JOHN', age: 30 },\n *   { name: 'john' },\n *   caseInsensitiveCompare\n * ); // true\n *\n * @example\n * // Custom comparison for range matching\n * const rangeCompare = (objVal, srcVal, key) => {\n *   if (key === 'age' && typeof srcVal === 'object' && srcVal.min !== undefined) {\n *     return objVal >= srcVal.min && objVal <= srcVal.max;\n *   }\n *   return undefined;\n * };\n *\n * isMatchWith(\n *   { name: 'John', age: 25 },\n *   { age: { min: 18, max: 30 } },\n *   rangeCompare\n * ); // true\n */\nexport function isMatchWith(\n  target: object,\n  source: object,\n  compare: (\n    value: any,\n    other: any,\n    indexOrKey: PropertyKey,\n    object: object,\n    source: object,\n    stack?: Map<any, any>\n  ) => boolean | undefined\n): boolean {\n  if (typeof compare !== 'function') {\n    return isMatch(target, source);\n  }\n\n  return isMatchWithInternal(\n    target,\n    source,\n    function doesMatch(objValue, srcValue, key, object, source, stack): boolean | undefined {\n      const isEqual = compare(objValue, srcValue, key, object, source, stack);\n\n      if (isEqual !== undefined) {\n        return Boolean(isEqual);\n      }\n\n      return isMatchWithInternal(objValue, srcValue, doesMatch, stack);\n    },\n    new Map()\n  );\n}\n\nfunction isMatchWithInternal(\n  target: any,\n  source: any,\n  compare: (\n    objValue: any,\n    srcValue: any,\n    key: PropertyKey,\n    object: any,\n    source: any,\n    stack?: Map<any, any>\n  ) => boolean | undefined,\n  stack?: Map<any, any>\n): boolean {\n  if (source === target) {\n    return true;\n  }\n\n  switch (typeof source) {\n    case 'object': {\n      return isObjectMatch(target, source, compare, stack);\n    }\n    case 'function': {\n      const sourceKeys = Object.keys(source);\n\n      if (sourceKeys.length > 0) {\n        return isMatchWithInternal(target, { ...source }, compare, stack);\n      }\n\n      return eq(target, source);\n    }\n    default: {\n      if (!isObject(target)) {\n        return eq(target, source);\n      }\n\n      if (typeof source === 'string') {\n        return source === '';\n      }\n\n      return true;\n    }\n  }\n}\n\nfunction isObjectMatch(\n  target: any,\n  source: any,\n  compare: (\n    objValue: any,\n    srcValue: any,\n    key: PropertyKey,\n    object: any,\n    source: any,\n    stack?: Map<any, any>\n  ) => boolean | undefined,\n  stack: Map<any, any> | undefined\n): boolean {\n  if (source == null) {\n    return true;\n  }\n\n  if (Array.isArray(source)) {\n    return isArrayMatch(target, source, compare, stack);\n  }\n\n  if (source instanceof Map) {\n    return isMapMatch(target, source, compare, stack);\n  }\n\n  if (source instanceof Set) {\n    return isSetMatch(target, source, compare, stack);\n  }\n\n  const keys = Object.keys(source as any);\n\n  if (target == null) {\n    return keys.length === 0;\n  }\n\n  if (keys.length === 0) {\n    return true;\n  }\n\n  if (stack && stack.has(source)) {\n    return stack.get(source) === target;\n  }\n\n  if (stack) {\n    stack.set(source, target);\n  }\n\n  try {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      if (!isPrimitive(target) && !(key in target)) {\n        return false;\n      }\n\n      if (source[key] === undefined && target[key] !== undefined) {\n        return false;\n      }\n\n      if (source[key] === null && target[key] !== null) {\n        return false;\n      }\n\n      const isEqual = compare(target[key], source[key], key, target, source, stack);\n\n      if (!isEqual) {\n        return false;\n      }\n    }\n\n    return true;\n  } finally {\n    if (stack) {\n      stack.delete(source);\n    }\n  }\n}\n\nfunction isMapMatch(\n  target: unknown,\n  source: Map<any, any>,\n  compare: (\n    objValue: any,\n    srcValue: any,\n    key: PropertyKey,\n    object: any,\n    source: any,\n    stack?: Map<any, any>\n  ) => boolean | undefined,\n  stack: Map<any, any> | undefined\n): boolean {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Map)) {\n    return false;\n  }\n\n  for (const [key, sourceValue] of source.entries()) {\n    const targetValue = target.get(key);\n\n    const isEqual = compare(targetValue, sourceValue, key, target, source, stack);\n\n    if (isEqual === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isArrayMatch(\n  target: unknown,\n  source: readonly unknown[],\n  compare: (\n    objValue: any,\n    srcValue: any,\n    key: PropertyKey,\n    object: any,\n    source: any,\n    stack?: Map<any, any>\n  ) => boolean | undefined,\n  stack: Map<any, any> | undefined\n): boolean {\n  if (source.length === 0) {\n    return true;\n  }\n\n  if (!Array.isArray(target)) {\n    return false;\n  }\n\n  const countedIndex = new Set<number>();\n\n  for (let i = 0; i < source.length; i++) {\n    const sourceItem = source[i];\n    let found = false;\n\n    for (let j = 0; j < target.length; j++) {\n      if (countedIndex.has(j)) {\n        continue;\n      }\n\n      const targetItem = target[j];\n      let matches = false;\n\n      const isEqual = compare(targetItem, sourceItem, i, target, source, stack);\n\n      if (isEqual) {\n        matches = true;\n      }\n\n      if (matches) {\n        countedIndex.add(j);\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isSetMatch(\n  target: unknown,\n  source: Set<any>,\n  compare: (\n    objValue: any,\n    srcValue: any,\n    key: PropertyKey,\n    object: any,\n    source: any,\n    stack?: Map<any, any>\n  ) => boolean | undefined,\n  stack?: Map<any, any>\n): boolean {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Set)) {\n    return false;\n  }\n\n  return isArrayMatch([...target], [...source], compare, stack);\n}\n","import { isMatchWith } from './isMatchWith.ts';\n\n/**\n * Checks if the target matches the source by comparing their structures and values.\n * This function supports deep comparison for objects, arrays, maps, and sets.\n *\n * @param {object} target - The target value to match against.\n * @param {object} source - The source value to match with.\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\n *\n * @example\n * // Matching arrays\n * isMatch([1, 2, 3], [1, 2, 3]); // true\n *\n * @example\n * // Matching maps\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\n * const sourceMap = new Map([['key1', 'value1']]);\n * isMatch(targetMap, sourceMap); // true\n *\n * @example\n * // Matching sets\n * const targetSet = new Set([1, 2, 3]);\n * const sourceSet = new Set([1, 2]);\n * isMatch(targetSet, sourceSet); // true\n */\nexport function isMatch(target: object, source: object): boolean {\n  return isMatchWith(target, source, () => undefined);\n}\n","export function getSymbols(object: any) {\n  return Object.getOwnPropertySymbols(object).filter(symbol =>\n    Object.prototype.propertyIsEnumerable.call(object, symbol)\n  );\n}\n","/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {T} value The value to query.\n * @returns {string} Returns the `Object.prototype.toString.call` result.\n */\nexport function getTag<T>(value: T) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n  return Object.prototype.toString.call(value);\n}\n","export const regexpTag = '[object RegExp]';\nexport const stringTag = '[object String]';\nexport const numberTag = '[object Number]';\nexport const booleanTag = '[object Boolean]';\nexport const argumentsTag = '[object Arguments]';\nexport const symbolTag = '[object Symbol]';\nexport const dateTag = '[object Date]';\nexport const mapTag = '[object Map]';\nexport const setTag = '[object Set]';\nexport const arrayTag = '[object Array]';\nexport const functionTag = '[object Function]';\nexport const arrayBufferTag = '[object ArrayBuffer]';\nexport const objectTag = '[object Object]';\nexport const errorTag = '[object Error]';\nexport const dataViewTag = '[object DataView]';\nexport const uint8ArrayTag = '[object Uint8Array]';\nexport const uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nexport const uint16ArrayTag = '[object Uint16Array]';\nexport const uint32ArrayTag = '[object Uint32Array]';\nexport const bigUint64ArrayTag = '[object BigUint64Array]';\nexport const int8ArrayTag = '[object Int8Array]';\nexport const int16ArrayTag = '[object Int16Array]';\nexport const int32ArrayTag = '[object Int32Array]';\nexport const bigInt64ArrayTag = '[object BigInt64Array]';\nexport const float32ArrayTag = '[object Float32Array]';\nexport const float64ArrayTag = '[object Float64Array]';\n","/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *     Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n *\n * @example\n * const arr = new Uint8Array([1, 2, 3]);\n * isTypedArray(arr); // true\n *\n * const regularArray = [1, 2, 3];\n * isTypedArray(regularArray); // false\n *\n * const buffer = new ArrayBuffer(16);\n * isTypedArray(buffer); // false\n */\nexport function isTypedArray(\n  x: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n","import { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Deeply clones the given object.\n *\n * You can customize the deep cloning process using the `cloneValue` function.\n * The function takes the current value `value`, the property name `key`, and the entire object `obj` as arguments.\n * If the function returns a value, that value is used;\n * if it returns `undefined`, the default cloning method is used.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @param {Function} [cloneValue] - A function to customize the cloning process.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive value\n * const num = 29;\n * const clonedNum = cloneDeepWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num); // true\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an array with a customizer\n * const arr = [1, 2, 3];\n * const clonedArr = cloneDeepWith(arr, (value) => {\n *   return value + 1; // Increment each value\n * });\n * console.log(clonedArr); // [2, 3, 4]\n * console.log(clonedArr === arr); // false\n */\nexport function cloneDeepWith<T>(\n  obj: T,\n  cloneValue: (value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any\n): T {\n  return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\n\nexport function cloneDeepWithImpl<T>(\n  valueToClone: any,\n  keyToClone: PropertyKey | undefined,\n  objectToClone: T,\n  stack = new Map<any, any>(),\n  cloneValue: ((value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any) | undefined = undefined\n): T {\n  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n\n  if (cloned != null) {\n    return cloned;\n  }\n\n  if (isPrimitive(valueToClone)) {\n    return valueToClone as T;\n  }\n\n  if (stack.has(valueToClone)) {\n    return stack.get(valueToClone) as T;\n  }\n\n  if (Array.isArray(valueToClone)) {\n    const result: any = new Array(valueToClone.length);\n    stack.set(valueToClone, result);\n\n    for (let i = 0; i < valueToClone.length; i++) {\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    }\n\n    // For RegExpArrays\n    if (Object.hasOwn(valueToClone, 'index')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.index = valueToClone.index;\n    }\n    if (Object.hasOwn(valueToClone, 'input')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.input = valueToClone.input;\n    }\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Date) {\n    return new Date(valueToClone.getTime()) as T;\n  }\n\n  if (valueToClone instanceof RegExp) {\n    const result = new RegExp(valueToClone.source, valueToClone.flags);\n\n    result.lastIndex = valueToClone.lastIndex;\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Map) {\n    const result = new Map();\n    stack.set(valueToClone, result);\n\n    for (const [key, value] of valueToClone) {\n      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n    }\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Set) {\n    const result = new Set();\n    stack.set(valueToClone, result);\n\n    for (const value of valueToClone) {\n      result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n    }\n\n    return result as T;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return valueToClone.subarray() as T;\n  }\n\n  if (isTypedArray(valueToClone)) {\n    const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n    stack.set(valueToClone, result);\n\n    for (let i = 0; i < valueToClone.length; i++) {\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    }\n\n    return result as T;\n  }\n\n  if (\n    valueToClone instanceof ArrayBuffer ||\n    (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)\n  ) {\n    return valueToClone.slice(0) as T;\n  }\n\n  if (valueToClone instanceof DataView) {\n    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  // For legacy NodeJS support\n  if (typeof File !== 'undefined' && valueToClone instanceof File) {\n    const result = new File([valueToClone], valueToClone.name, {\n      type: valueToClone.type,\n    });\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Blob) {\n    const result = new Blob([valueToClone], { type: valueToClone.type });\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Error) {\n    const result = new (valueToClone.constructor as { new (): Error })();\n    stack.set(valueToClone, result);\n\n    result.message = valueToClone.message;\n    result.name = valueToClone.name;\n    result.stack = valueToClone.stack;\n    result.cause = valueToClone.cause;\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n    const result = Object.create(Object.getPrototypeOf(valueToClone));\n\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  return valueToClone;\n}\n\nexport function copyProperties<T>(\n  target: any,\n  source: any,\n  objectToClone: T = target,\n  stack?: Map<any, any> | undefined,\n  cloneValue?: ((value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any) | undefined\n): void {\n  const keys = [...Object.keys(source), ...getSymbols(source)];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const descriptor = Object.getOwnPropertyDescriptor(target, key);\n\n    if (descriptor == null || descriptor.writable) {\n      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n    }\n  }\n}\n\nfunction isCloneableObject(object: object) {\n  switch (getTag(object)) {\n    case argumentsTag:\n    case arrayTag:\n    case arrayBufferTag:\n    case dataViewTag:\n    case booleanTag:\n    case dateTag:\n    case float32ArrayTag:\n    case float64ArrayTag:\n    case int8ArrayTag:\n    case int16ArrayTag:\n    case int32ArrayTag:\n    case mapTag:\n    case numberTag:\n    case objectTag:\n    case regexpTag:\n    case setTag:\n    case stringTag:\n    case symbolTag:\n    case uint8ArrayTag:\n    case uint8ClampedArrayTag:\n    case uint16ArrayTag:\n    case uint32ArrayTag: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n","import { cloneDeepWithImpl } from './cloneDeepWith.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepWithImpl(obj, undefined, obj, new Map(), undefined);\n}\n","import { isMatch } from './isMatch.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\n\n/**\n * Creates a function that performs a deep comparison between a given target and the source object.\n *\n * @template T\n * @param {T} source - The source object to create the matcher from.\n * @returns {(value: any) => boolean} Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * const matcher = matches({ a: 1, b: 2 });\n * matcher({ a: 1, b: 2, c: 3 }); // true\n * matcher({ a: 1, c: 3 }); // false\n */\nexport function matches<T>(source: T): (value: any) => boolean;\n\n/**\n * Creates a function that performs a deep comparison between a given target and the source object.\n *\n * @template T\n * @template V\n * @param {T} source - The source object to create the matcher from.\n * @returns {(value: V) => boolean} Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * const matcher = matches<{ a: number }, { a: number; b?: number }>({ a: 1 });\n * matcher({ a: 1, b: 2 }); // true\n * matcher({ a: 2 }); // false\n */\nexport function matches<T, V>(source: T): (value: V) => boolean;\n\n/**\n * Creates a function that performs a deep comparison between a given target and the source object.\n *\n * @template T\n * @template V\n * @param {T} source - The source object to create the matcher from.\n * @returns {(target: V) => boolean} Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * const matcher = matches({ a: 1, b: 2 });\n * matcher({ a: 1, b: 2, c: 3 }); // true\n * matcher({ a: 1, c: 3 }); // false\n *\n * @example\n * // Matching arrays\n * const arrayMatcher = matches([1, 2, 3]);\n * arrayMatcher([1, 2, 3, 4]); // true\n * arrayMatcher([4, 5, 6]); // false\n *\n * @example\n * // Matching objects with nested structures\n * const nestedMatcher = matches({ a: { b: 2 } });\n * nestedMatcher({ a: { b: 2, c: 3 } }); // true\n * nestedMatcher({ a: { c: 3 } }); // false\n */\nexport function matches<T, V>(source: T): (target: V) => boolean {\n  source = cloneDeep(source);\n\n  return (target?: unknown): boolean => {\n    return isMatch(target as object, source as object);\n  };\n}\n","import { cloneDeepWith as cloneDeepWithToolkit } from '../../object/cloneDeepWith.ts';\nimport { copyProperties } from '../../object/cloneDeepWith.ts';\nimport { argumentsTag, booleanTag, numberTag, stringTag } from '../_internal/tags.ts';\n\ntype CloneDeepWithCustomizer<TObject> = (\n  value: any,\n  key: number | string | undefined,\n  object: TObject | undefined,\n  stack: any\n) => any;\n\n/**\n * Creates a deep clone of the given value using a customizer function.\n *\n * @template T - The type of the value.\n * @param {T} value - The value to clone.\n * @param {CloneDeepWithCustomizer<T>} customizer - A function to customize the cloning process.\n * @returns {any} - A deep clone of the given value.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2;\n *   }\n * });\n * // => { a: 2, b: 4 }\n */\nexport function cloneDeepWith<T>(value: T, customizer: CloneDeepWithCustomizer<T>): any;\n\n/**\n * Creates a deep clone of the given value.\n *\n * @template T - The type of the value.\n * @param {T} value - The value to clone.\n * @returns {T} - A deep clone of the given value.\n *\n * @example\n * const obj = { a: 1, b: { c: 2 } };\n * const clonedObj = cloneDeepWith(obj);\n * // => { a: 1, b: { c: 2 } }\n */\nexport function cloneDeepWith<T>(value: T): T;\n\n/**\n * Creates a deep clone of the given object using a customizer function.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @param {Function} [cloneValue] - A function to customize the cloning process.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive value\n * const num = 29;\n * const clonedNum = cloneDeepWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num); // true\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an array with a customizer\n * const arr = [1, 2, 3];\n * const clonedArr = cloneDeepWith(arr, (value) => {\n *   return value + 1; // Increment each value\n * });\n * console.log(clonedArr); // [2, 3, 4]\n * console.log(clonedArr === arr); // false\n */\nexport function cloneDeepWith<T>(obj: T, customizer?: CloneDeepWithCustomizer<T>): any | T {\n  return cloneDeepWithToolkit(obj, (value, key, object, stack) => {\n    const cloned = customizer?.(value, key as any, object, stack);\n\n    if (cloned != null) {\n      return cloned;\n    }\n\n    if (typeof obj !== 'object') {\n      return undefined;\n    }\n\n    switch (Object.prototype.toString.call(obj)) {\n      case numberTag:\n      case stringTag:\n      case booleanTag: {\n        // eslint-disable-next-line\n        // @ts-ignore\n        const result = new obj.constructor(obj?.valueOf()) as T;\n        copyProperties(result, obj);\n        return result;\n      }\n\n      case argumentsTag: {\n        const result = {} as any;\n\n        copyProperties(result, obj);\n\n        // eslint-disable-next-line\n        // @ts-ignore\n        result.length = obj.length;\n        // eslint-disable-next-line\n        // @ts-ignore\n        result[Symbol.iterator] = obj[Symbol.iterator];\n\n        return result as T;\n      }\n\n      default: {\n        return undefined;\n      }\n    }\n  });\n}\n","import { cloneDeepWith } from './cloneDeepWith.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepWith(obj);\n}\n","const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\\d*)$/;\n\nexport function isIndex(value: PropertyKey, length = Number.MAX_SAFE_INTEGER): boolean {\n  switch (typeof value) {\n    case 'number': {\n      return Number.isInteger(value) && value >= 0 && value < length;\n    }\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return IS_UNSIGNED_INTEGER.test(value);\n    }\n  }\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if the given value is an arguments object.\n *\n * This function tests whether the provided value is an arguments object or not.\n * It returns `true` if the value is an arguments object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an arguments object.\n *\n * @param {any} value - The value to test if it is an arguments object.\n * @returns {value is IArguments} `true` if the value is an arguments, `false` otherwise.\n *\n * @example\n * const args = (function() { return arguments; })();\n * const strictArgs = (function() { 'use strict'; return arguments; })();\n * const value = [1, 2, 3];\n *\n * console.log(isArguments(args)); // true\n * console.log(isArguments(strictArgs)); // true\n * console.log(isArguments(value)); // false\n */\nexport function isArguments(value?: any): value is IArguments {\n  return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Checks if a given path exists within an object.\n *\n * @template T\n * @template K\n * @param {T} object - The object to query.\n * @param {K} path - The path to check.\n * @returns {object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown } & { [key: symbol]: unknown }} Returns a type guard indicating if the path exists in the object.\n *\n * @example\n * const obj = { a: 1, b: { c: 2 } };\n *\n * if (has(obj, 'a')) {\n *   console.log(obj.a); // TypeScript knows obj.a exists\n * }\n *\n * if (has(obj, 'b')) {\n *   console.log(obj.b.c); // TypeScript knows obj.b exists\n * }\n */\nexport function has<T, K extends PropertyKey>(\n  object: T,\n  path: K\n): object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown } & {\n  [key: symbol]: unknown;\n};\n\n/**\n * Checks if a given path exists within an object.\n *\n * @template T\n * @param {T} object - The object to query.\n * @param {PropertyPath} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has<T>(object: T, path: PropertyPath): boolean;\n\n/**\n * Checks if a given path exists within an object.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @param {any} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has(object: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  let resolvedPath;\n\n  if (Array.isArray(path)) {\n    resolvedPath = path;\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\n    resolvedPath = toPath(path);\n  } else {\n    resolvedPath = [path];\n  }\n\n  if (resolvedPath.length === 0) {\n    return false;\n  }\n\n  let current = object;\n\n  for (let i = 0; i < resolvedPath.length; i++) {\n    const key = resolvedPath[i];\n\n    // Check if the current key is a direct property of the current object\n    if (current == null || !Object.hasOwn(current, key)) {\n      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;\n\n      if (!isSparseIndex) {\n        return false;\n      }\n    }\n\n    current = current[key];\n  }\n\n  return true;\n}\n","import { isMatch } from './isMatch.ts';\nimport type { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { cloneDeep } from '../object/cloneDeep.ts';\nimport { get } from '../object/get.ts';\nimport { has } from '../object/has.ts';\n\n/**\n * Creates a function that checks if a given target object matches a specific property value.\n *\n * @template T\n * @template V\n * @param {PropertyPath} path - The property path to check within the target object.\n * @param {T} srcValue - The value to compare against the property value in the target object.\n * @returns {(value: any) => boolean} Returns a function that takes a target object and returns\n *     `true` if the property value at the given path in the target object matches the provided value,\n *     otherwise returns `false`.\n *\n * @example\n * const checkName = matchesProperty('name', 'Alice');\n * console.log(checkName({ name: 'Alice' })); // true\n * console.log(checkName({ name: 'Bob' })); // false\n */\nexport function matchesProperty<T>(path: PropertyPath, srcValue: T): (value: any) => boolean;\n\n/**\n * Creates a function that checks if a given target object matches a specific property value.\n *\n * @template T\n * @template V\n * @param {PropertyPath} path - The property path to check within the target object.\n * @param {T} srcValue - The value to compare against the property value in the target object.\n * @returns {(value: V) => boolean} Returns a function that takes a target object and returns\n *     `true` if the property value at the given path in the target object matches the provided value,\n *     otherwise returns `false`.\n *\n * @example\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\n * console.log(checkNested({ address: { city: 'New York' } })); // true\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\n */\nexport function matchesProperty<T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean;\n\n/**\n * Creates a function that checks if a given target object matches a specific property value.\n *\n * The returned function takes a target object and determines if the property at the\n * specified path within the target object is equal to the given value.\n *\n * @param {PropertyPath} property - The property path to check within the target object.\n *     This can be a single property key or an array of property keys.\n * @param {T} source - The value to compare against the property value in the target object.\n *\n * @returns {(target?: V) => boolean} - A function that takes a target object and returns\n *     `true` if the property value at the given path in the target object matches the provided value,\n *     otherwise returns `false`.\n *\n * @example\n * // Using a single property key\n * const checkName = matchesProperty('name', 'Alice');\n * console.log(checkName({ name: 'Alice' })); // true\n * console.log(checkName({ name: 'Bob' })); // false\n *\n * // Using an array of property keys\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\n * console.log(checkNested({ address: { city: 'New York' } })); // true\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\n */\nexport function matchesProperty<T, V>(property: PropertyPath, source: T): (target?: V) => boolean {\n  switch (typeof property) {\n    case 'object': {\n      if (Object.is(property?.valueOf(), -0)) {\n        property = '-0';\n      }\n      break;\n    }\n    case 'number': {\n      property = toKey(property);\n      break;\n    }\n  }\n\n  source = cloneDeep(source);\n\n  return function (target?: unknown) {\n    const result = get(target, property as PropertyKey | PropertyKey[]);\n\n    if (result === undefined) {\n      return has(target, property as PropertyKey | PropertyKey[]);\n    }\n\n    if (source === undefined) {\n      return result === undefined;\n    }\n\n    return isMatch(result, source as object);\n  };\n}\n","import { identity } from '../../function/identity.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Returns the provided function as-is when it is a function type.\n *\n * @template F - The function type\n * @param {F} func - The function to return\n * @returns {F} Returns the provided function unchanged\n *\n * @example\n * const fn = (x: number) => x * 2;\n * const iterateeFn = iteratee(fn);\n * iterateeFn(4); // => 8\n */\nexport function iteratee<F extends (...args: any[]) => any>(func: F): F;\n\n/**\n * Creates an iteratee function based on the provided property key or object.\n * If given a property key, returns a function that gets that property from objects.\n * If given an object, returns a function that matches objects against the provided one.\n *\n * @param {PropertyKey | object} func - The value to convert to an iteratee\n * @returns {Function} Returns the iteratee function\n *\n * @example\n * // With property key\n * const getLength = iteratee('length');\n * getLength([1,2,3]); // => 3\n *\n * // With object\n * const matchObj = iteratee({ x: 1, y: 2 });\n * matchObj({ x: 1, y: 2, z: 3 }); // => true\n */\nexport function iteratee(func: PropertyKey | object): (...args: any[]) => any;\n\n/**\n * Creates a function that returns a value from an element in a collection.\n *\n * You can call `iteratee` with the following types of arguments:\n *\n * - **Function**: Returns the function as-is, which will be called with the element from the collection.\n * - **Property name**: Returns the value of the specified property from the element.\n * - **Property-value pair**: Returns a boolean indicating whether the element's property matches the given value.\n * - **Partial object**: Returns a boolean indicating whether the element matches the properties of the partial object.\n *\n * If you don't provide any arguments or pass `null`, this function will return a function that simply returns its input unchanged.\n *\n * @param {symbol | number | string | object | null | ((...args: any[]) => any)} value - The value to convert to an iteratee.\n * @returns {(...args: any[]) => unknown} - Returns the new iteratee function.\n * @example\n * const func = iteratee();\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [{ a: 1 }, { a: 2 }, { a: 3 }]\n *\n * const func = iteratee((object) => object.a);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee('a');\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee({ a: 1 });\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n *\n * const func = iteratee(['a', 1]);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n */\nexport function iteratee(\n  value?: symbol | number | string | object | null | ((...args: any[]) => unknown)\n): (...args: any[]) => any {\n  if (value == null) {\n    return identity;\n  }\n\n  switch (typeof value) {\n    case 'function': {\n      return value as any;\n    }\n    case 'object': {\n      if (Array.isArray(value) && value.length === 2) {\n        return matchesProperty(value[0], value[1]);\n      }\n\n      return matches(value);\n    }\n    case 'string':\n    case 'symbol':\n    case 'number': {\n      return property(value);\n    }\n  }\n}\n","import { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Creates an object composed of keys generated from the results of running each element of collection through\n * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The\n * iteratee is invoked with one argument: (value).\n *\n * @param collection The collection to iterate over.\n * @param iteratee The function invoked per iteration.\n * @return Returns the composed aggregate object.\n *\n * @example\n * countBy([6.1, 4.2, 6.3], Math.floor); // => { '4': 1, '6': 2 }\n * countBy(['one', 'two', 'three'], 'length'); // => { '3': 2, '5': 1 }\n */\nexport function countBy<T>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIteratee<T>\n): Record<string, number>;\n\nexport function countBy<T extends object>(\n  collection: T | null | undefined,\n  iteratee?: ValueIteratee<T[keyof T]>\n): Record<string, number>;\n\nexport function countBy(collection: any, iteratee?: any): Record<string, number> {\n  if (collection == null) {\n    return {} as Record<string, number>;\n  }\n\n  const array = isArrayLike(collection) ? Array.from(collection) : Object.values(collection);\n  const mapper = iterateeToolkit(iteratee ?? undefined) as (value: any) => any;\n\n  const result = Object.create(null) as Record<string, number>;\n\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    const key = mapper(item);\n    result[key] = (result[key] ?? 0) + 1;\n  }\n\n  return result;\n}\n","/**\n * Computes the difference between two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements\n * that are present in the first array but not in the second array. It effectively\n * filters out any elements from the first array that also appear in the second array.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\n * from which elements will be compared and filtered.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * Each element in this array will be checked against the first array, and if a match is found,\n * that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the first array but not\n * in the second array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const result = difference(array1, array2);\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\n */\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => !secondSet.has(item));\n}\n","/**\n * Checks if the given value is object-like.\n *\n * A value is object-like if its type is object and it is not null.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object-like value.\n *\n * @param {any} value - The value to test if it is an object-like.\n * @returns {boolean} `true` if the value is an object-like, `false` otherwise.\n *\n * @example\n * const value1 = { a: 1 };\n * const value2 = [1, 2, 3];\n * const value3 = 'abc';\n * const value4 = () => {};\n * const value5 = null;\n *\n * console.log(isObjectLike(value1)); // true\n * console.log(isObjectLike(value2)); // true\n * console.log(isObjectLike(value3)); // false\n * console.log(isObjectLike(value4)); // false\n * console.log(isObjectLike(value5)); // false\n */\n\nexport function isObjectLike(value?: any): boolean {\n  return typeof value === 'object' && value !== null;\n}\n","import { isArrayLike } from './isArrayLike.ts';\nimport { isObjectLike } from './isObjectLike.ts';\n\nexport function isArrayLikeObject<T extends { __lodashAnyHack: any }>(value: T): boolean;\nexport function isArrayLikeObject(\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  value: ((...args: any[]) => any) | Function | string | boolean | number | null | undefined\n): value is never;\nexport function isArrayLikeObject(value: any): value is object & { length: number };\n\n/**\n * Checks if the given value is a non-primitive, array-like object.\n *\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-primitive, array-like object, `false` otherwise.\n *\n * @example\n * isArrayLikeObject([1, 2, 3]); // true\n * isArrayLikeObject({ 0: 'a', length: 1 }); // true\n * isArrayLikeObject('abc'); // false\n * isArrayLikeObject(()=>{}); // false\n */\nexport function isArrayLikeObject(value?: any): boolean {\n  return isObjectLike(value) && isArrayLike(value);\n}\n","import { difference as differenceToolkit } from '../../array/difference.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Computes the difference between an array and multiple arrays.\n *\n * @template T\n * @param {ArrayLike<T> | undefined | null} arr - The primary array from which to derive the difference. This is the main array\n * from which elements will be compared and filtered.\n * @param {Array<ArrayLike<T>>} values - Multiple arrays containing elements to be excluded from the primary array.\n * These arrays will be flattened into a single array, and each element in this array will be checked against the primary array.\n * If a match is found, that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the primary array but not\n * in the flattened array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const array3 = [5, 6];\n * const result = difference(array1, array2, array3);\n * // result will be [1, 3] since 2, 4, and 5 are in the other arrays and are excluded from the result.\n *\n * @example\n * const arrayLike1 = { 0: 1, 1: 2, 2: 3, length: 3 };\n * const arrayLike2 = { 0: 2, 1: 4, length: 2 };\n * const result = difference(arrayLike1, arrayLike2);\n * // result will be [1, 3] since 2 is in both array-like objects and is excluded from the result.\n */\nexport function difference<T>(arr: ArrayLike<T> | undefined | null, ...values: Array<ArrayLike<T>>): T[] {\n  if (!isArrayLikeObject(arr)) {\n    return [];\n  }\n\n  const arr1 = toArray(arr);\n  const arr2 = [];\n\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (isArrayLikeObject(value)) {\n      arr2.push(...Array.from(value));\n    }\n  }\n\n  return differenceToolkit(arr1, arr2);\n}\n","/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {[...T[], T]} arr - The array from which to get the last element.\n * @returns {T} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly [...T[], T]): T;\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly T[]): T | undefined;\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n","import { last as lastToolkit } from '../../array/last.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(array: ArrayLike<T> | null | undefined): T | undefined {\n  if (!isArrayLike(array)) {\n    return undefined;\n  }\n  return lastToolkit(toArray(array));\n}\n","import { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\nexport function flattenArrayLike<T>(values: Array<ArrayLike<T>>): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < values.length; i++) {\n    const arrayLike = values[i];\n\n    if (!isArrayLikeObject(arrayLike)) {\n      continue;\n    }\n\n    for (let j = 0; j < arrayLike.length; j++) {\n      result.push(arrayLike[j] as T);\n    }\n  }\n\n  return result;\n}\n","import { last } from './last.ts';\nimport { difference as differenceToolkit } from '../../array/difference.ts';\nimport { differenceBy as differenceByToolkit } from '../../array/differenceBy.ts';\nimport { flattenArrayLike } from '../_internal/flattenArrayLike.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates an array of array values not included in the other given arrays using an iteratee function.\n *\n * @template T1, T2\n * @param {ArrayLike<T1> | null | undefined} array The array to inspect\n * @param {ArrayLike<T2>} values The values to exclude\n * @param {ValueIteratee<T1 | T2>} iteratee The iteratee invoked per element\n * @returns {T1[]} Returns the new array of filtered values\n * @example\n * differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor)\n * // => [1.2]\n */\nexport function differenceBy<T1, T2>(\n  array: ArrayLike<T1> | null | undefined,\n  values: ArrayLike<T2>,\n  iteratee: ValueIteratee<T1 | T2>\n): T1[];\n\n/**\n * Creates an array of array values not included in the other given arrays using an iteratee function.\n *\n * @template T1, T2, T3\n * @param {ArrayLike<T1> | null | undefined} array The array to inspect\n * @param {ArrayLike<T2>} values1 The first array of values to exclude\n * @param {ArrayLike<T3>} values2 The second array of values to exclude\n * @param {ValueIteratee<T1 | T2 | T3>} iteratee The iteratee invoked per element\n * @returns {T1[]} Returns the new array of filtered values\n * @example\n * differenceBy([2.1, 1.2], [2.3], [1.4], Math.floor)\n * // => []\n */\nexport function differenceBy<T1, T2, T3>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  iteratee: ValueIteratee<T1 | T2 | T3>\n): T1[];\n\n/**\n * Creates an array of array values not included in the other given arrays using an iteratee function.\n *\n * @template T1, T2, T3, T4\n * @param {ArrayLike<T1> | null | undefined} array The array to inspect\n * @param {ArrayLike<T2>} values1 The first array of values to exclude\n * @param {ArrayLike<T3>} values2 The second array of values to exclude\n * @param {ArrayLike<T4>} values3 The third array of values to exclude\n * @param {ValueIteratee<T1 | T2 | T3 | T4>} iteratee The iteratee invoked per element\n * @returns {T1[]} Returns the new array of filtered values\n * @example\n * differenceBy([2.1, 1.2, 3.5], [2.3], [1.4], [3.2], Math.floor)\n * // => []\n */\nexport function differenceBy<T1, T2, T3, T4>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  values3: ArrayLike<T4>,\n  iteratee: ValueIteratee<T1 | T2 | T3 | T4>\n): T1[];\n\n/**\n * Creates an array of array values not included in the other given arrays using an iteratee function.\n *\n * @template T1, T2, T3, T4, T5\n * @param {ArrayLike<T1> | null | undefined} array The array to inspect\n * @param {ArrayLike<T2>} values1 The first array of values to exclude\n * @param {ArrayLike<T3>} values2 The second array of values to exclude\n * @param {ArrayLike<T4>} values3 The third array of values to exclude\n * @param {ArrayLike<T5>} values4 The fourth array of values to exclude\n * @param {ValueIteratee<T1 | T2 | T3 | T4 | T5>} iteratee The iteratee invoked per element\n * @returns {T1[]} Returns the new array of filtered values\n * @example\n * differenceBy([2.1, 1.2, 3.5, 4.8], [2.3], [1.4], [3.2], [4.1], Math.floor)\n * // => []\n */\nexport function differenceBy<T1, T2, T3, T4, T5>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  values3: ArrayLike<T4>,\n  values4: ArrayLike<T5>,\n  iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>\n): T1[];\n\n/**\n * Creates an array of array values not included in the other given arrays using an iteratee function.\n *\n * @template T1, T2, T3, T4, T5, T6\n * @param {ArrayLike<T1> | null | undefined} array The array to inspect\n * @param {ArrayLike<T2>} values1 The first array of values to exclude\n * @param {ArrayLike<T3>} values2 The second array of values to exclude\n * @param {ArrayLike<T4>} values3 The third array of values to exclude\n * @param {ArrayLike<T5>} values4 The fourth array of values to exclude\n * @param {ArrayLike<T6>} values5 The fifth array of values to exclude\n * @param {ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>} iteratee The iteratee invoked per element\n * @returns {T1[]} Returns the new array of filtered values\n * @example\n * differenceBy([2.1, 1.2, 3.5, 4.8, 5.3], [2.3], [1.4], [3.2], [4.1], [5.8], Math.floor)\n * // => []\n */\nexport function differenceBy<T1, T2, T3, T4, T5, T6>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  values3: ArrayLike<T4>,\n  values4: ArrayLike<T5>,\n  values5: ArrayLike<T6>,\n  iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>\n): T1[];\n\n/**\n * Creates an array of array values not included in the other given arrays using an iteratee function.\n *\n * @template T1, T2, T3, T4, T5, T6, T7\n * @param {ArrayLike<T1> | null | undefined} array The array to inspect\n * @param {ArrayLike<T2>} values1 The first array of values to exclude\n * @param {ArrayLike<T3>} values2 The second array of values to exclude\n * @param {ArrayLike<T4>} values3 The third array of values to exclude\n * @param {ArrayLike<T5>} values4 The fourth array of values to exclude\n * @param {ArrayLike<T6>} values5 The fifth array of values to exclude\n * @param {...(ArrayLike<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>)[]} values Additional arrays of values to exclude and iteratee\n * @returns {T1[]} Returns the new array of filtered values\n * @example\n * differenceBy([2.1, 1.2, 3.5, 4.8, 5.3, 6.7], [2.3], [1.4], [3.2], [4.1], [5.8], [6.2], Math.floor)\n * // => []\n */\nexport function differenceBy<T1, T2, T3, T4, T5, T6, T7>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  values3: ArrayLike<T4>,\n  values4: ArrayLike<T5>,\n  values5: ArrayLike<T6>,\n  ...values: Array<ArrayLike<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>\n): T1[];\n\n/**\n * Creates an array of array values not included in the other given arrays.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array The array to inspect\n * @param {...Array<ArrayLike<T>>} values The arrays of values to exclude\n * @returns {T[]} Returns the new array of filtered values\n * @example\n * differenceBy([2, 1], [2, 3])\n * // => [1]\n */\nexport function differenceBy<T>(array: ArrayLike<T> | null | undefined, ...values: Array<ArrayLike<T>>): T[];\n\n/**\n * Computes the difference between an array and multiple arrays using an iteratee function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The primary array from which to derive the difference.\n * @param {...any[]} values - Multiple arrays containing elements to be excluded from the primary array.\n * @returns {T[]} A new array containing the elements that are present in the primary array but not in the values arrays.\n */\nexport function differenceBy<T>(arr: ArrayLike<T> | null | undefined, ..._values: any[]): T[] {\n  if (!isArrayLikeObject(arr)) {\n    return [];\n  }\n\n  const iteratee = last(_values);\n  const values = flattenArrayLike<T>(_values);\n\n  if (isArrayLikeObject(iteratee)) {\n    return differenceToolkit(Array.from(arr), values);\n  }\n\n  return differenceByToolkit(Array.from(arr), values, createIteratee(iteratee));\n}\n","/**\n * Computes the difference between two arrays after mapping their elements through a provided function.\n *\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\n * that are present in the first array but not in the second array, based on the identity calculated\n * by the mapper function.\n *\n * Essentially, it filters out any elements from the first array that, when\n * mapped, match an element in the mapped version of the second array.\n *\n * @template T, U\n * @param {T[]} firstArr - The primary array from which to derive the difference.\n * @param {U[]} secondArr - The array containing elements to be excluded from the first array.\n * @param {(value: T | U) => unknown} mapper - The function to map the elements of both arrays. This function\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\n * mapped identity in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [2, 4];\n * const mapper = item => (typeof item === 'object' ? item.id : item);\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since 2 is present in both arrays after mapping, and is excluded from the result.\n */\nexport function differenceBy<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  mapper: (value: T | U) => unknown\n): T[] {\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\n\n  return firstArr.filter(item => {\n    return !mappedSecondSet.has(mapper(item));\n  });\n}\n","import { last } from './last.ts';\nimport { difference as differenceToolkit } from '../../array/difference.ts';\nimport { differenceWith as differenceWithToolkit } from '../../array/differenceWith.ts';\nimport { flattenArrayLike } from '../_internal/flattenArrayLike.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Computes the difference between the primary array and another array using a comparator function.\n *\n * @template T1, T2\n * @param {ArrayLike<T1> | null | undefined} array - The primary array to compare elements against.\n * @param {ArrayLike<T2>} values - The array containing elements to compare with the primary array.\n * @param {(a: T1, b: T2) => boolean} comparator - A function to determine if two elements are considered equal.\n * @returns {T1[]} A new array containing the elements from the primary array that do not match any elements in `values` based on the comparator.\n *\n * @example\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const values = [{ id: 2 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values, comparator);\n * // result will be [{ id: 1 }, { id: 3 }]\n */\nexport function differenceWith<T1, T2>(\n  array: ArrayLike<T1> | null | undefined,\n  values: ArrayLike<T2>,\n  comparator: (a: T1, b: T2) => boolean\n): T1[];\n\n/**\n * Computes the difference between the primary array and two arrays using a comparator function.\n *\n * @template T1, T2, T3\n * @param {ArrayLike<T1> | null | undefined} array - The primary array to compare elements against.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to compare with the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to compare with the primary array.\n * @param {(a: T1, b: T2 | T3) => boolean} comparator - A function to determine if two elements are considered equal.\n * @returns {T1[]} A new array containing the elements from the primary array that do not match any elements in `values1` or `values2` based on the comparator.\n *\n * @example\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const values1 = [{ id: 2 }];\n * const values2 = [{ id: 3 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values1, values2, comparator);\n * // result will be [{ id: 1 }]\n */\nexport function differenceWith<T1, T2, T3>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  comparator: (a: T1, b: T2 | T3) => boolean\n): T1[];\n\n/**\n * Computes the difference between the primary array and multiple arrays using a comparator function.\n *\n * @template T1, T2, T3, T4\n * @param {ArrayLike<T1> | null | undefined} array - The primary array to compare elements against.\n * @param {ArrayLike<T2>} values1 - The first array containing elements to compare with the primary array.\n * @param {ArrayLike<T3>} values2 - The second array containing elements to compare with the primary array.\n * @param {...Array<ArrayLike<T4> | ((a: T1, b: T2 | T3 | T4) => boolean)>} values - Additional arrays and an optional comparator function to determine if two elements are considered equal.\n * @returns {T1[]} A new array containing the elements from the primary array that do not match any elements\n * in `values1`, `values2`, or subsequent arrays. If a comparator function is provided, it will be used to compare elements;\n * otherwise, [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero) algorithm will be used.\n *\n * @example\n * // Example with comparator function\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }];\n * const values1 = [{ id: 2 }];\n * const values2 = [{ id: 3 }];\n * const values3 = [{ id: 4 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values1, values2, values3, comparator);\n * // result will be [{ id: 1 }]\n *\n * @example\n * // Example without comparator function (behaves like `difference`)\n * const array = [1, 2, 3, 4];\n * const values1 = [2];\n * const values2 = [3];\n * const values3 = [4];\n *\n * const result = differenceWith(array, values1, values2, values3);\n * // result will be [1]\n */\nexport function differenceWith<T1, T2, T3, T4>(\n  array: ArrayLike<T1> | null | undefined,\n  values1: ArrayLike<T2>,\n  values2: ArrayLike<T3>,\n  ...values: Array<ArrayLike<T4> | ((a: T1, b: T2 | T3 | T4) => boolean)>\n): T1[];\n\n/**\n * Computes the difference between the primary array and one or more arrays without using a comparator function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The primary array to compare elements against.\n * @param {...Array<ArrayLike<T>>} values - One or more arrays containing elements to compare with the primary array.\n * @returns {T[]} A new array containing the elements from the primary array that do not match any elements in the provided arrays.\n *\n * @example\n * const array = [1, 2, 3];\n * const values1 = [2];\n * const values2 = [3];\n *\n * const result = differenceWith(array, values1, values2);\n * // result will be [1]\n */\nexport function differenceWith<T>(array: ArrayLike<T> | null | undefined, ...values: Array<ArrayLike<T>>): T[];\n\n/**\n * Computes the difference between the primary array and one or more arrays using an optional comparator function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The primary array to compare elements against.\n * @param {...Array<ArrayLike<unknown> | ((a: unknown, b: unknown) => boolean)>} values - One or more arrays to compare with the primary array, and an optional comparator function to determine if two elements are considered equal.\n * @returns {T[]} A new array containing the elements from the primary array that do not match any elements in the provided arrays or those compared using the comparator function.\n *\n * @example\n * // Example with a comparator function\n * const array = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const values1 = [{ id: 2 }];\n * const values2 = [{ id: 3 }];\n * const comparator = (a, b) => a.id === b.id;\n *\n * const result = differenceWith(array, values1, values2, comparator);\n * // result will be [{ id: 1 }]\n *\n * @example\n * // Example without a comparator function\n * const array = [1, 2, 3];\n * const values1 = [2];\n * const values2 = [3];\n *\n * const result = differenceWith(array, values1, values2);\n * // result will be [1]\n */\nexport function differenceWith<T>(\n  array: ArrayLike<T> | null | undefined,\n  ...values: Array<ArrayLike<unknown> | ((a: unknown, b: unknown) => boolean)>\n): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  const comparator = last(values);\n  const flattenedValues = flattenArrayLike(values as Array<ArrayLike<T>>);\n\n  if (typeof comparator === 'function') {\n    return differenceWithToolkit(Array.from(array), flattenedValues, comparator);\n  }\n\n  return differenceToolkit(Array.from(array), flattenedValues);\n}\n","/**\n * Computes the difference between two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a new array containing\n * the elements that are present in the first array but not in the second array. The comparison to determine\n * if elements are equal is made using the provided custom function.\n *\n * @template T, U\n * @param {T[]} firstArr - The array from which to get the difference.\n * @param {U[]} secondArr - The array containing elements to exclude from the first array.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\n * according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the element with id 2 is considered equal to the second array's element and is excluded from the result.\n */\nexport function differenceWith<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  areItemsEqual: (x: T, y: U) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.every(secondItem => {\n      return !areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n * @example\n * isSymbol(Symbol.iterator);\n * // => true\n *\n * isSymbol('abc');\n * // => false\n */\nexport function isSymbol(value: any): value is symbol {\n  return typeof value === 'symbol' || value instanceof Symbol;\n}\n","import { isSymbol } from '../predicate/isSymbol.ts';\n\n/**\n * Converts `value` to a number.\n *\n * Unlike `Number()`, this function returns `NaN` for symbols.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toNumber(3.2); // => 3.2\n * toNumber(Number.MIN_VALUE); // => 5e-324\n * toNumber(Infinity); // => Infinity\n * toNumber('3.2'); // => 3.2\n * toNumber(Symbol.iterator); // => NaN\n * toNumber(NaN); // => NaN\n */\nexport function toNumber(value: any): number {\n  if (isSymbol(value)) {\n    return NaN;\n  }\n\n  return Number(value);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Converts `value` to a finite number.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toNumber(3.2); // => 3.2\n * toNumber(Number.MIN_VALUE); // => 5e-324\n * toNumber(Infinity); // => 1.7976931348623157e+308\n * toNumber('3.2'); // => 3.2\n * toNumber(Symbol.iterator); // => 0\n * toNumber(NaN); // => 0\n */\nexport function toFinite(value: any): number {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n\n  value = toNumber(value);\n\n  if (value === Infinity || value === -Infinity) {\n    const sign = value < 0 ? -1 : 1;\n    return sign * Number.MAX_VALUE;\n  }\n\n  return value === value ? (value as number) : 0;\n}\n","import { toFinite } from './toFinite.ts';\n\n/**\n * Converts `value` to an integer.\n *\n * This function first converts `value` to a finite number. If the result has any decimal places,\n * they are removed by rounding down to the nearest whole number.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toInteger(3.2); // => 3\n * toInteger(Number.MIN_VALUE); // => 0\n * toInteger(Infinity); // => 1.7976931348623157e+308\n * toInteger('3.2'); // => 3\n * toInteger(Symbol.iterator); // => 0\n * toInteger(NaN); // => 0\n */\nexport function toInteger(value: any): number {\n  const finite = toFinite(value);\n  const remainder = finite % 1;\n\n  return remainder ? finite - remainder : finite;\n}\n","import { drop as dropToolkit } from '../../array/drop.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Removes a specified number of elements from the beginning of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the start.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} collection - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array with the specified number of elements removed from the start.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = drop(array, 2);\n * result will be [3, 4, 5] since the first two elements are dropped.\n */\nexport function drop<T>(array: ArrayLike<T> | null | undefined, n?: number): T[];\n\nexport function drop<T>(collection: ArrayLike<T> | null | undefined, itemsCount = 1, guard?: unknown): T[] {\n  if (!isArrayLike(collection)) {\n    return [];\n  }\n  itemsCount = guard ? 1 : toInteger(itemsCount);\n\n  return dropToolkit(toArray(collection), itemsCount);\n}\n","/**\n * Removes a specified number of elements from the beginning of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the start.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the start.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = drop(array, 2);\n * // result will be [3, 4, 5] since the first two elements are dropped.\n */\nexport function drop<T>(arr: readonly T[], itemsCount: number): T[] {\n  itemsCount = Math.max(itemsCount, 0);\n\n  return arr.slice(itemsCount);\n}\n","import { dropRight as dropRightToolkit } from '../../array/dropRight.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} collection - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(array: ArrayLike<T> | null | undefined, n?: number): T[];\n\n/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} collection - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(collection: ArrayLike<T> | null | undefined, itemsCount = 1, guard?: unknown): T[] {\n  if (!isArrayLike(collection)) {\n    return [];\n  }\n  itemsCount = guard ? 1 : toInteger(itemsCount);\n\n  return dropRightToolkit(toArray(collection), itemsCount);\n}\n","/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(arr: readonly T[], itemsCount: number): T[] {\n  itemsCount = Math.min(-itemsCount, 0);\n\n  if (itemsCount === 0) {\n    return arr.slice();\n  }\n\n  return arr.slice(0, itemsCount);\n}\n","/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array from the end and drops elements until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element from the end,\n * and dropping continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRightWhile(array, x => x > 3);\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\n */\nexport function dropRightWhile<T>(\n  arr: readonly T[],\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => boolean\n): T[] {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (!canContinueDropping(arr[i], i, arr)) {\n      return arr.slice(0, i + 1);\n    }\n  }\n\n  return [];\n}\n","import { dropRightWhile as dropRightWhileToolkit } from '../../array/dropRightWhile.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Creates a slice of array excluding elements dropped from the end until predicate returns falsey.\n * The predicate is invoked with three arguments: (value, index, array).\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {ListIteratee<T>} [predicate] - The function invoked per iteration.\n * @returns {T[]} Returns the slice of array.\n * @example\n *\n * const users = [\n *   { user: 'barney', active: true },\n *   { user: 'fred', active: false },\n *   { user: 'pebbles', active: false }\n * ];\n *\n * // Using function predicate\n * dropRightWhile(users, user => !user.active);\n * // => [{ user: 'barney', active: true }]\n *\n * // Using matches shorthand\n * dropRightWhile(users, { user: 'pebbles', active: false });\n * // => [{ user: 'barney', active: true }, { user: 'fred', active: false }]\n *\n * // Using matchesProperty shorthand\n * dropRightWhile(users, ['active', false]);\n * // => [{ user: 'barney', active: true }]\n *\n * // Using property shorthand\n * dropRightWhile(users, 'active');\n * // => [{ user: 'barney', active: true }]\n */\nexport function dropRightWhile<T>(array: ArrayLike<T> | null | undefined, predicate?: ListIteratee<T>): T[];\n\n/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the end until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => unknown} predicate - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, index, and array, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [3, 2, 1];\n * const result = dropRightWhile(array, (item, index, arr) => index >= 1);\n * // Returns: [3]\n */\nexport function dropRightWhile<T>(\n  arr: ArrayLike<T> | null | undefined,\n  predicate:\n    | ((item: T, index: number, arr: readonly T[]) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey = identity\n): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return dropRightWhileImpl(Array.from(arr), predicate);\n}\n\nfunction dropRightWhileImpl<T>(\n  arr: readonly T[],\n  predicate: ((item: T, index: number, arr: readonly T[]) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey\n): T[] {\n  switch (typeof predicate) {\n    case 'function': {\n      return dropRightWhileToolkit(arr, (item, index, arr) => Boolean(predicate(item, index, arr)));\n    }\n    case 'object': {\n      if (Array.isArray(predicate) && predicate.length === 2) {\n        const key = predicate[0];\n        const value = predicate[1];\n\n        return dropRightWhileToolkit(arr, matchesProperty(key, value));\n      } else {\n        return dropRightWhileToolkit(arr, matches(predicate));\n      }\n    }\n    case 'symbol':\n    case 'number':\n    case 'string': {\n      return dropRightWhileToolkit(arr, property(predicate));\n    }\n  }\n}\n","/**\n * Removes elements from the beginning of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the start until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropWhile(array, x => x < 3);\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\n */\nexport function dropWhile<T>(\n  arr: readonly T[],\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => boolean\n): T[] {\n  const dropEndIndex = arr.findIndex((item, index, arr) => !canContinueDropping(item, index, arr));\n\n  if (dropEndIndex === -1) {\n    return [];\n  }\n\n  return arr.slice(dropEndIndex);\n}\n","import { dropWhile as dropWhileToolkit } from '../../array/dropWhile.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Creates a slice of array excluding elements dropped from the beginning.\n * Elements are dropped until predicate returns falsey.\n * The predicate is invoked with three arguments: (value, index, array).\n *\n * @template T - The type of elements in the array\n * @param {ArrayLike<T> | null | undefined} arr - The array to query\n * @param {ListIteratee<T>} [predicate=identity] - The function invoked per iteration\n * @returns {T[]} Returns the slice of array\n *\n * @example\n * dropWhile([1, 2, 3], n => n < 3)\n * // => [3]\n *\n * dropWhile([{ a: 1, b: 2 }, { a: 1, b: 3 }], { a: 1 })\n * // => [{ a: 1, b: 3 }]\n *\n * dropWhile([{ a: 1, b: 2 }, { a: 1, b: 3 }], ['a', 1])\n * // => [{ a: 1, b: 3 }]\n *\n * dropWhile([{ a: 1, b: 2 }, { a: 1, b: 3 }], 'a')\n * // => []\n */\nexport function dropWhile<T>(arr: ArrayLike<T> | null | undefined, predicate: ListIteratee<T> = identity): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return dropWhileImpl(toArray(arr), predicate);\n}\n\nfunction dropWhileImpl<T>(arr: readonly T[], predicate: ListIteratee<T>): T[] {\n  switch (typeof predicate) {\n    case 'function': {\n      return dropWhileToolkit(arr, (item, index, arr) => Boolean(predicate(item, index, arr)));\n    }\n    case 'object': {\n      if (Array.isArray(predicate) && predicate.length === 2) {\n        const key = predicate[0];\n        const value = predicate[1];\n\n        return dropWhileToolkit(arr, matchesProperty(key, value));\n      } else {\n        return dropWhileToolkit(arr, matches(predicate));\n      }\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      return dropWhileToolkit(arr, property(predicate));\n    }\n  }\n}\n","/**\n * Returns an array of numbers from `0` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `0` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n */\nexport function range(end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [1, 2, 3]\n * range(1, 4);\n */\nexport function range(start: number, end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n *\n * @example\n * // Returns [0, 5, 10, 15]\n * range(0, 20, 5);\n */\nexport function range(start: number, end: number, step: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n */\nexport function range(start: number, end?: number, step = 1): number[] {\n  if (end == null) {\n    end = start;\n    start = 0;\n  }\n\n  if (!Number.isInteger(step) || step === 0) {\n    throw new Error(`The step value must be a non-zero integer.`);\n  }\n\n  const length = Math.max(Math.ceil((end - start) / step), 0);\n  const result = new Array<number>(length);\n\n  for (let i = 0; i < length; i++) {\n    result[i] = start + i * step;\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { ArrayIterator } from '../_internal/ArrayIterator.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\nimport { StringIterator } from '../_internal/StringIterator.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Iterates over elements of array and invokes iteratee for each element.\n *\n * @template T\n * @param {T[]} collection - The array to iterate over.\n * @param {ArrayIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {T[]} Returns array.\n *\n * @example\n * forEach([1, 2], value => console.log(value));\n * // => Logs `1` then `2`.\n */\nexport function forEach<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[];\n\n/**\n * Iterates over characters of string and invokes iteratee for each character.\n *\n * @param {string} collection - The string to iterate over.\n * @param {StringIterator<any>} [iteratee] - The function invoked per iteration.\n * @returns {string} Returns string.\n *\n * @example\n * forEach('abc', char => console.log(char));\n * // => Logs 'a', 'b', then 'c'.\n */\nexport function forEach(collection: string, iteratee?: StringIterator<any>): string;\n\n/**\n * Iterates over elements of collection and invokes iteratee for each element.\n *\n * @template T\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {ListIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {ArrayLike<T>} Returns collection.\n *\n * @example\n * forEach({ 0: 'a', 1: 'b', length: 2 }, value => console.log(value));\n * // => Logs 'a' then 'b'.\n */\nexport function forEach<T>(collection: ArrayLike<T>, iteratee?: ListIterator<T, any>): ArrayLike<T>;\n\n/**\n * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.\n *\n * @template T\n * @param {T} collection - The object to iterate over.\n * @param {ObjectIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {T} Returns object.\n *\n * @example\n * forEach({ a: 1, b: 2 }, (value, key) => console.log(key));\n * // => Logs 'a' then 'b'.\n */\nexport function forEach<T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T;\n\n/**\n * Iterates over elements of array and invokes iteratee for each element.\n *\n * @template T, U\n * @param {U & (T[] | null | undefined)} collection - The array to iterate over.\n * @param {ArrayIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {U} Returns the array.\n *\n * @example\n * forEach([1, 2], value => console.log(value));\n * // => Logs `1` then `2`.\n */\nexport function forEach<T, U extends T[] | null | undefined>(\n  collection: U & (T[] | null | undefined),\n  iteratee?: ArrayIterator<T, any>\n): U;\n\n/**\n * Iterates over characters of string and invokes iteratee for each character.\n *\n * @template T\n * @param {T} collection - The string to iterate over.\n * @param {StringIterator<any>} [iteratee] - The function invoked per iteration.\n * @returns {T} Returns the string.\n *\n * @example\n * forEach('abc', char => console.log(char));\n * // => Logs 'a', 'b', then 'c'.\n */\nexport function forEach<T extends string | null | undefined>(collection: T, iteratee?: StringIterator<any>): T;\n\n/**\n * Iterates over elements of collection and invokes iteratee for each element.\n *\n * @template T, L\n * @param {L & (ArrayLike<T> | null | undefined)} collection - The collection to iterate over.\n * @param {ListIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {L} Returns the collection.\n *\n * @example\n * forEach({ 0: 'a', 1: 'b', length: 2 }, value => console.log(value));\n * // => Logs 'a' then 'b'.\n */\nexport function forEach<T, L extends ArrayLike<T> | null | undefined>(\n  collection: L & (ArrayLike<T> | null | undefined),\n  iteratee?: ListIterator<T, any>\n): L;\n\n/**\n * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ObjectIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {T | null | undefined} Returns the object.\n *\n * @example\n * forEach({ a: 1, b: 2 }, (value, key) => console.log(key));\n * // => Logs 'a' then 'b'.\n */\nexport function forEach<T extends object>(\n  collection: T | null | undefined,\n  iteratee?: ObjectIterator<T, any>\n): T | null | undefined;\n\n/**\n * Iterates over each element of the object invoking the provided callback function for each property.\n *\n * @template T - The type of object.\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} [callback] - The function invoked for each property.\n * The callback function receives three arguments:\n *  - 'value': The current property being processed in the object.\n *  - 'key': The key of the current property being processed in the object.\n *  - 'object': The object 'forEach' was called upon.\n * @returns {T} Returns the original object.\n *\n * @example\n * forEach({'a': 1, 'b': 2 }, (value, key, object) => console.log(value, key));\n * // Output:\n * // 1 'a'\n * // 2 'b'\n */\nexport function forEach<T>(\n  collection: ArrayLike<T> | Record<any, any> | string | null | undefined,\n  callback: (item: any, index: any, arr: any) => unknown = identity\n): ArrayLike<T> | Record<any, any> | string | null | undefined {\n  if (!collection) {\n    return collection;\n  }\n\n  const keys: PropertyKey[] =\n    isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    const result = callback(value, key, collection);\n\n    if (result === false) {\n      break;\n    }\n  }\n\n  return collection;\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { ArrayIterator } from '../_internal/ArrayIterator.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\nimport { StringIterator } from '../_internal/StringIterator.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Iterates over elements of array from right to left and invokes iteratee for each element.\n *\n * @template T\n * @param {T[]} collection - The array to iterate over.\n * @param {ArrayIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {T[]} Returns array.\n *\n * @example\n * forEachRight([1, 2], value => console.log(value));\n * // => Logs `2` then `1`.\n */\nexport function forEachRight<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[];\n\n/**\n * Iterates over characters of string from right to left and invokes iteratee for each character.\n *\n * @param {string} collection - The string to iterate over.\n * @param {StringIterator<any>} [iteratee] - The function invoked per iteration.\n * @returns {string} Returns string.\n *\n * @example\n * forEachRight('abc', char => console.log(char));\n * // => Logs 'c', 'b', then 'a'.\n */\nexport function forEachRight(collection: string, iteratee?: StringIterator<any>): string;\n\n/**\n * Iterates over elements of collection from right to left and invokes iteratee for each element.\n *\n * @template T\n * @param {ArrayLike<T>} collection - The collection to iterate over.\n * @param {ListIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {ArrayLike<T>} Returns collection.\n *\n * @example\n * forEachRight({ 0: 'a', 1: 'b', length: 2 }, value => console.log(value));\n * // => Logs 'b' then 'a'.\n */\nexport function forEachRight<T>(collection: ArrayLike<T>, iteratee?: ListIterator<T, any>): ArrayLike<T>;\n\n/**\n * Iterates over own enumerable string keyed properties of an object from right to left and invokes iteratee for each property.\n *\n * @template T\n * @param {T} collection - The object to iterate over.\n * @param {ObjectIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {T} Returns object.\n *\n * @example\n * forEachRight({ a: 1, b: 2 }, (value, key) => console.log(key));\n * // => Logs 'b' then 'a'.\n */\nexport function forEachRight<T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T;\n\n/**\n * Iterates over elements of array from right to left and invokes iteratee for each element.\n *\n * @template T, U\n * @param {U & (T[] | null | undefined)} collection - The array to iterate over.\n * @param {ArrayIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {U} Returns the array.\n *\n * @example\n * forEachRight([1, 2], value => console.log(value));\n * // => Logs `2` then `1`.\n */\nexport function forEachRight<T, U extends T[] | null | undefined>(\n  collection: U & (T[] | null | undefined),\n  iteratee?: ArrayIterator<T, any>\n): U;\n\n/**\n * Iterates over characters of string from right to left and invokes iteratee for each character.\n *\n * @template T\n * @param {T} collection - The string to iterate over.\n * @param {StringIterator<any>} [iteratee] - The function invoked per iteration.\n * @returns {T} Returns the string.\n *\n * @example\n * forEachRight('abc', char => console.log(char));\n * // => Logs 'c', 'b', then 'a'.\n */\nexport function forEachRight<T extends string | null | undefined>(collection: T, iteratee?: StringIterator<any>): T;\n\n/**\n * Iterates over elements of collection from right to left and invokes iteratee for each element.\n *\n * @template T, L\n * @param {L & (ArrayLike<T> | null | undefined)} collection - The collection to iterate over.\n * @param {ListIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {L} Returns the collection.\n *\n * @example\n * forEachRight({ 0: 'a', 1: 'b', length: 2 }, value => console.log(value));\n * // => Logs 'b' then 'a'.\n */\nexport function forEachRight<T, L extends ArrayLike<T> | null | undefined>(\n  collection: L & (ArrayLike<T> | null | undefined),\n  iteratee?: ListIterator<T, any>\n): L;\n\n/**\n * Iterates over own enumerable string keyed properties of an object from right to left and invokes iteratee for each property.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ObjectIterator<T, any>} [iteratee] - The function invoked per iteration.\n * @returns {T | null | undefined} Returns the object.\n *\n * @example\n * forEachRight({ a: 1, b: 2 }, (value, key) => console.log(key));\n * // => Logs 'b' then 'a'.\n */\nexport function forEachRight<T extends object>(\n  collection: T | null | undefined,\n  iteratee?: ObjectIterator<T, any>\n): T | null | undefined;\n\n/**\n * Iterates over elements of 'array' from right to left and invokes 'callback' for each element.\n *\n * @template T - The type of object.\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} [callback] - The function invoked for each property.\n * The callback function receives three arguments:\n *  - 'value': The current property being processed in the object.\n *  - 'key': The key of the current property being processed in the object.\n *  - 'object': The object 'forEachRight' was called upon.\n * @returns {T} Returns the original object.\n *\n * @example\n * forEachRight({'a': 1, 'b': 2 }, (value, key, object) => console.log(value, key));\n * // Output:\n * // 2 'b'\n * // 1 'a'\n */\nexport function forEachRight<T>(\n  collection: ArrayLike<T> | Record<any, any> | string | null | undefined,\n  callback: (item: any, index: any, arr: any) => unknown = identity\n): ArrayLike<T> | Record<any, any> | string | null | undefined {\n  if (!collection) {\n    return collection;\n  }\n\n  const keys: PropertyKey[] = isArrayLike(collection) ? range(0, collection.length) : Object.keys(collection);\n\n  for (let i = keys.length - 1; i >= 0; i--) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    const result = callback(value, key, collection);\n\n    if (result === false) {\n      break;\n    }\n  }\n\n  return collection;\n}\n","import { isIndex } from './isIndex.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { eq } from '../util/eq.ts';\n\nexport function isIterateeCall(value: unknown, index: unknown, object: unknown): boolean {\n  if (!isObject(object)) {\n    return false;\n  }\n\n  if (\n    (typeof index === 'number' && isArrayLike(object) && isIndex(index) && index < object.length) ||\n    (typeof index === 'string' && index in object)\n  ) {\n    return eq((object as any)[index], value);\n  }\n\n  return false;\n}\n","import { identity } from '../../function/identity.ts';\nimport { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { ObjectIterateeCustom } from '../_internal/ObjectIteratee.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Checks if all elements in a collection pass the predicate check.\n * The predicate is invoked with three arguments: (value, index|key, collection).\n *\n * @template T - The type of elements in the collection\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over\n * @param {ListIterateeCustom<T, boolean>} [predicate=identity] - The function invoked per iteration\n * @returns {boolean} Returns true if all elements pass the predicate check, else false\n *\n * @example\n * // Using a function predicate\n * every([true, 1, null, 'yes'], Boolean)\n * // => false\n *\n * // Using property shorthand\n * const users = [{ user: 'barney', age: 36 }, { user: 'fred', age: 40 }]\n * every(users, 'age')\n * // => true\n *\n * // Using matches shorthand\n * every(users, { age: 36 })\n * // => false\n *\n * // Using matchesProperty shorthand\n * every(users, ['age', 36])\n * // => false\n */\nexport function every<T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate?: ListIterateeCustom<T, boolean>\n): boolean;\n\n/**\n * Checks if all elements in an object pass the predicate check.\n * The predicate is invoked with three arguments: (value, key, object).\n *\n * @template T - The type of the object\n * @param {T | null | undefined} collection - The object to iterate over\n * @param {ObjectIterateeCustom<T, boolean>} [predicate=identity] - The function invoked per iteration\n * @returns {boolean} Returns true if all elements pass the predicate check, else false\n *\n * @example\n * // Using a function predicate\n * every({ a: true, b: 1, c: null }, Boolean)\n * // => false\n *\n * // Using property shorthand\n * const users = {\n *   barney: { active: true, age: 36 },\n *   fred: { active: true, age: 40 }\n * }\n * every(users, 'active')\n * // => true\n *\n * // Using matches shorthand\n * every(users, { active: true })\n * // => true\n *\n * // Using matchesProperty shorthand\n * every(users, ['age', 36])\n * // => false\n */\nexport function every<T extends object>(\n  collection: T | null | undefined,\n  predicate?: ObjectIterateeCustom<T, boolean>\n): boolean;\n\n/**\n * Checks if every item in an object has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {T extends Record<string, unknown> ? T : never} object - The object to check through.\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The source array or object to check through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\n * @param {PropertyKey} propertyToCheck - The property name to check.\n * @param {unknown} guard - Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} - `true` if every property value has the specified property, or `false` if at least one does not match.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = every(obj, 'name');\n * console.log(result); // true\n */\nexport function every<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  doesMatch?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  guard?: unknown\n): boolean {\n  if (!source) {\n    return true;\n  }\n\n  if (guard && isIterateeCall(source, doesMatch, guard)) {\n    doesMatch = undefined;\n  }\n\n  if (!doesMatch) {\n    doesMatch = identity;\n  }\n\n  let predicate: (value: any, index: number, collection: any) => boolean;\n\n  switch (typeof doesMatch) {\n    case 'function': {\n      predicate = doesMatch as any;\n      break;\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n        predicate = matchesProperty(key, value);\n      } else {\n        predicate = matches(doesMatch);\n      }\n      break;\n    }\n    case 'symbol':\n    case 'number':\n    case 'string': {\n      predicate = property(doesMatch);\n    }\n  }\n\n  if (!isArrayLike(source)) {\n    const keys = Object.keys(source) as Array<keyof typeof source>;\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = source[key];\n\n      if (!predicate(value, key, source)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  for (let i = 0; i < source.length; i++) {\n    if (!predicate((source as ArrayLike<T>)[i], i, source)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Checks if a given value is string.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\n *\n * @param {unknown} value The value to check if it is string.\n * @returns {value is string} Returns `true` if `value` is a string, else `false`.\n *\n * @example\n * const value1 = 'abc';\n * const value2 = 123;\n * const value3 = true;\n *\n * console.log(isString(value1)); // true\n * console.log(isString(value2)); // false\n * console.log(isString(value3)); // false\n */\n\nexport function isString(value?: any): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n","import { fill as fillToolkit } from '../../array/fill.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isString } from '../predicate/isString.ts';\n\n/**\n * Fills an array with a value.\n * @template T\n * @param {any[] | null | undefined} array - The array to fill\n * @param {T} value - The value to fill array with\n * @returns {T[]} Returns the filled array\n * @example\n * fill([1, 2, 3], 'a')\n * // => ['a', 'a', 'a']\n */\nexport function fill<T>(array: any[] | null | undefined, value: T): T[];\n\n/**\n * Fills an array-like object with a value.\n * @template T, U\n * @param {U extends readonly any[] ? never : U | null | undefined} array - The array-like object to fill\n * @param {T} value - The value to fill array with\n * @returns {ArrayLike<T>} Returns the filled array-like object\n * @example\n * fill({ length: 3 }, 2)\n * // => { 0: 2, 1: 2, 2: 2, length: 3 }\n */\nexport function fill<T, U extends ArrayLike<any>>(\n  array: U extends readonly any[] ? never : U | null | undefined,\n  value: T\n): ArrayLike<T>;\n\n/**\n * Fills an array with a value from start up to end.\n * @template T, U\n * @param {U[] | null | undefined} array - The array to fill\n * @param {T} value - The value to fill array with\n * @param {number} [start=0] - The start position\n * @param {number} [end=array.length] - The end position\n * @returns {Array<T | U>} Returns the filled array\n * @example\n * fill([1, 2, 3], 'a', 1, 2)\n * // => [1, 'a', 3]\n */\nexport function fill<T, U>(array: U[] | null | undefined, value: T, start?: number, end?: number): Array<T | U>;\n\n/**\n * Fills an array-like object with a value from start up to end.\n * @template T, U\n * @param {U extends readonly any[] ? never : U | null | undefined} array - The array-like object to fill\n * @param {T} value - The value to fill array with\n * @param {number} [start=0] - The start position\n * @param {number} [end=array.length] - The end position\n * @returns {ArrayLike<T | U[0]>} Returns the filled array-like object\n * @example\n * fill({ 0: 1, 1: 2, 2: 3, length: 3 }, 'a', 1, 2)\n * // => { 0: 1, 1: 'a', 2: 3, length: 3 }\n */\nexport function fill<T, U extends ArrayLike<any>>(\n  array: U extends readonly any[] ? never : U | null | undefined,\n  value: T,\n  start?: number,\n  end?: number\n): ArrayLike<T | U[0]>;\n\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {ArrayLike<T | U> | null | undefined} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {ArrayLike<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(\n  array: ArrayLike<T | U> | null | undefined,\n  value: U,\n  start = 0,\n  end = array ? array.length : 0\n): ArrayLike<T | U> {\n  if (!isArrayLike(array)) {\n    return [];\n  }\n  if (isString(array)) {\n    // prevent TypeError: Cannot assign to read only property of string\n    return array;\n  }\n  start = Math.floor(start);\n  end = Math.floor(end);\n\n  if (!start) {\n    start = 0;\n  }\n  if (!end) {\n    end = 0;\n  }\n\n  return fillToolkit(array as any, value, start, end);\n}\n","/**\n * Fills the whole array with a specified value.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T>(array: unknown[], value: T): T[];\n/**\n * Fills elements of an array with a specified value from the start position up to the end of the array.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number): Array<T | U>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(array: Array<T | U>, value: U, start: number, end: number): Array<T | U>;\n/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array.\n *\n * @template T, U\n * @param {Array<T | U>} array - The array to fill.\n * @param {U} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | U>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n *\n * const result = fill(array, '*', -2, -1);\n * // => [1, '*', 3]\n */\nexport function fill<T, U>(array: Array<T | U>, value: U, start = 0, end = array.length): Array<T | U> {\n  const length = array.length;\n  const finalStart = Math.max(start >= 0 ? start : length + start, 0);\n  const finalEnd = Math.min(end >= 0 ? end : length + end, length);\n\n  for (let i = finalStart; i < finalEnd; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n","import { identity } from '../../function/identity.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { ListIteratorTypeGuard } from '../_internal/ListIteratorTypeGuard.ts';\nimport { ObjectIterateeCustom } from '../_internal/ObjectIteratee.ts';\nimport { ObjectIteratorTypeGuard } from '../_internal/ObjectIterator.ts';\nimport { StringIterator } from '../_internal/StringIterator.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Filters characters in a string based on the predicate function.\n *\n * @param collection - The string to filter\n * @param predicate - The function to test each character\n * @returns An array of characters that pass the predicate test\n *\n * @example\n * filter('123', char => char === '2')\n * // => ['2']\n */\nexport function filter(collection: string | null | undefined, predicate?: StringIterator<boolean>): string[];\n\n/**\n * Filters elements in an array-like object using a type guard predicate.\n *\n * @param collection - The array-like object to filter\n * @param predicate - The type guard function to test each element\n * @returns An array of elements that are of type U\n *\n * @example\n * filter([1, '2', 3], (x): x is number => typeof x === 'number')\n * // => [1, 3]\n */\nexport function filter<T, U extends T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate: ListIteratorTypeGuard<T, U>\n): U[];\n\n/**\n * Filters elements in an array-like object based on the predicate.\n *\n * @param collection - The array-like object to filter\n * @param predicate - The function or shorthand to test each element\n * @returns An array of elements that pass the predicate test\n *\n * @example\n * filter([1, 2, 3], x => x > 1)\n * // => [2, 3]\n *\n * filter([{ a: 1 }, { a: 2 }], { a: 1 })\n * // => [{ a: 1 }]\n */\nexport function filter<T>(collection: ArrayLike<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>): T[];\n\n/**\n * Filters values in an object using a type guard predicate.\n *\n * @param collection - The object to filter\n * @param predicate - The type guard function to test each value\n * @returns An array of values that are of type U\n *\n * @example\n * filter({ a: 1, b: '2', c: 3 }, (x): x is number => typeof x === 'number')\n * // => [1, 3]\n */\nexport function filter<T extends object, U extends T[keyof T]>(\n  collection: T | null | undefined,\n  predicate: ObjectIteratorTypeGuard<T, U>\n): U[];\n\n/**\n * Filters values in an object based on the predicate.\n *\n * @param collection - The object to filter\n * @param predicate - The function or shorthand to test each value\n * @returns An array of values that pass the predicate test\n *\n * @example\n * filter({ a: 1, b: 2 }, x => x > 1)\n * // => [2]\n *\n * filter({ a: { x: 1 }, b: { x: 2 } }, { x: 1 })\n * // => [{ x: 1 }]\n */\nexport function filter<T extends object>(\n  collection: T | null | undefined,\n  predicate?: ObjectIterateeCustom<T, boolean>\n): Array<T[keyof T]>;\n\n/**\n * Iterates over the collection and filters elements based on the given predicate.\n * If a function is provided, it is invoked for each element in the collection.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The array or object to iterate over.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate=identity] - The function invoked per iteration.\n * @returns {T[]} - Returns a new array of filtered elements that satisfy the predicate.\n *\n * @example\n * filter([{ a: 1 }, { a: 2 }, { b: 1 }], 'a');\n * // => [{ a: 1 }, { a: 2 }]\n *\n * filter([{ a: 1 }, { a: 2 }, { b: 1 }], { b: 1 });\n * // => [{ b: 1 }]\n *\n * filter({ item1: { a: 0, b: true }, item2: { a: 1, b: true }, item3: { a: 2, b: false }}, { b: false })\n * // => [{ a: 2, b: false }]\n *\n * filter([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => [{ a: 2 }]\n */\nexport function filter<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  predicate: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey = identity\n): T[] {\n  if (!source) {\n    return [];\n  }\n\n  predicate = iteratee(predicate);\n\n  if (!Array.isArray(source)) {\n    const result: T[] = [];\n    const keys = Object.keys(source) as Array<keyof T>;\n    const length = isArrayLike(source) ? source.length : keys.length;\n\n    for (let i = 0; i < length; i++) {\n      const key = keys[i];\n      const value = source[key] as T;\n\n      if (predicate(value, key as number, source)) {\n        result.push(value);\n      }\n    }\n\n    return result;\n  }\n\n  const result: T[] = [];\n  const length = source.length;\n\n  for (let i = 0; i < length; i++) {\n    const value = source[i];\n    if (predicate(value, i, source)) {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { ListIteratorTypeGuard } from '../_internal/ListIteratorTypeGuard.ts';\nimport { ObjectIterateeCustom } from '../_internal/ObjectIteratee.ts';\nimport { ObjectIteratorTypeGuard } from '../_internal/ObjectIterator.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Finds the first element in an array-like object that matches a type guard predicate.\n *\n * @param collection - The array-like object to search\n * @param predicate - The type guard function to test each element\n * @param fromIndex - The index to start searching from\n * @returns The first element that matches the type guard, or undefined if none found\n *\n * @example\n * find([1, '2', 3], (x): x is number => typeof x === 'number')\n * // => 1\n */\nexport function find<T, U extends T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate: ListIteratorTypeGuard<T, U>,\n  fromIndex?: number\n): U | undefined;\n\n/**\n * Finds the first element in an array-like object that matches a predicate.\n *\n * @param collection - The array-like object to search\n * @param predicate - The function or shorthand to test each element\n * @param fromIndex - The index to start searching from\n * @returns The first matching element, or undefined if none found\n *\n * @example\n * find([1, 2, 3], x => x > 2)\n * // => 3\n *\n * find([{ a: 1 }, { a: 2 }], { a: 2 })\n * // => { a: 2 }\n */\nexport function find<T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate?: ListIterateeCustom<T, boolean>,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the first value in an object that matches a type guard predicate.\n *\n * @param collection - The object to search\n * @param predicate - The type guard function to test each value\n * @param fromIndex - The index to start searching from\n * @returns The first value that matches the type guard, or undefined if none found\n *\n * @example\n * find({ a: 1, b: '2', c: 3 }, (x): x is number => typeof x === 'number')\n * // => 1\n */\nexport function find<T extends object, U extends T[keyof T]>(\n  collection: T | null | undefined,\n  predicate: ObjectIteratorTypeGuard<T, U>,\n  fromIndex?: number\n): U | undefined;\n\n/**\n * Finds the first value in an object that matches a predicate.\n *\n * @param collection - The object to search\n * @param predicate - The function or shorthand to test each value\n * @param fromIndex - The index to start searching from\n * @returns The first matching value, or undefined if none found\n *\n * @example\n * find({ a: 1, b: 2 }, x => x > 1)\n * // => 2\n *\n * find({ a: { x: 1 }, b: { x: 2 } }, { x: 2 })\n * // => { x: 2 }\n */\nexport function find<T extends object>(\n  collection: T | null | undefined,\n  predicate?: ObjectIterateeCustom<T, boolean>,\n  fromIndex?: number\n): T[keyof T] | undefined;\n\n/**\n * Finds the first item in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The source array or object to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {T | undefined} - The first property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } };\n * const result = find(obj, 'name');\n * console.log(result); // { id: 1, name: 'Alice' }\n */\nexport function find<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  _doesMatch:\n    | ((item: T, index: number, arr: any) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey = identity,\n  fromIndex = 0\n): T | undefined {\n  if (!source) {\n    return undefined;\n  }\n  if (fromIndex < 0) {\n    fromIndex = Math.max(source.length + fromIndex, 0);\n  }\n\n  const doesMatch = iteratee(_doesMatch);\n  if (typeof doesMatch === 'function' && !Array.isArray(source)) {\n    const keys = Object.keys(source) as Array<keyof T>;\n\n    for (let i = fromIndex; i < keys.length; i++) {\n      const key = keys[i];\n      const value = source[key] as T;\n\n      if (doesMatch(value, key as number, source)) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n\n  const values = Array.isArray(source) ? source.slice(fromIndex) : Object.values(source).slice(fromIndex);\n  return values.find(doesMatch);\n}\n","import { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Finds the index of the first item in an array that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match against the items in the array. This can be a function, a partial object, a key-value pair, or a property name.\n * @param {PropertyKey} propertyToCheck - The property name to check for in the items of the array.\n * @param {number} [fromIndex=0] - The index to start the search from, defaults to 0.\n * @returns {number} - The index of the first item that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * const result = findIndex(items, 'name');\n * console.log(result); // 0\n */\nexport function findIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch?: ListIterateeCustom<T, boolean>,\n  fromIndex = 0\n): number {\n  if (!arr) {\n    return -1;\n  }\n  if (fromIndex < 0) {\n    fromIndex = Math.max(arr.length + fromIndex, 0);\n  }\n  const subArray = Array.from(arr).slice(fromIndex);\n  let index = -1;\n  switch (typeof doesMatch) {\n    case 'function': {\n      index = subArray.findIndex(doesMatch);\n      break;\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        index = subArray.findIndex(matchesProperty(key, value));\n      } else {\n        index = subArray.findIndex(matches(doesMatch));\n      }\n      break;\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      index = subArray.findIndex(property(doesMatch));\n    }\n  }\n  return index === -1 ? -1 : index + fromIndex;\n}\n","import { identity } from '../../function/identity.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { ListIteratorTypeGuard } from '../_internal/ListIteratorTypeGuard.ts';\nimport { ObjectIterateeCustom } from '../_internal/ObjectIteratee.ts';\nimport { ObjectIteratorTypeGuard } from '../_internal/ObjectIterator.ts';\nimport { iteratee } from '../util/iteratee.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Finds the last element in a collection that satisfies the predicate.\n *\n * @template T, S\n * @param {ArrayLike<T> | null | undefined} collection - The collection to search.\n * @param {ListIteratorTypeGuard<T, S>} predicate - The predicate function with type guard.\n * @param {number} [fromIndex] - The index to start searching from.\n * @returns {S | undefined} The last element that satisfies the predicate.\n *\n * @example\n * const users = [{ user: 'barney', age: 36 }, { user: 'fred', age: 40 }, { user: 'pebbles', age: 18 }];\n * findLast(users, (o): o is { user: string; age: number } => o.age < 40);\n * // => { user: 'pebbles', age: 18 }\n */\nexport function findLast<T, S extends T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate: ListIteratorTypeGuard<T, S>,\n  fromIndex?: number\n): S | undefined;\n\n/**\n * Finds the last element in a collection that satisfies the predicate.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection - The collection to search.\n * @param {ListIterateeCustom<T, boolean>} [predicate] - The predicate function, partial object, property-value pair, or property name.\n * @param {number} [fromIndex] - The index to start searching from.\n * @returns {T | undefined} The last element that satisfies the predicate.\n *\n * @example\n * const users = [{ user: 'barney', age: 36 }, { user: 'fred', age: 40 }, { user: 'pebbles', age: 18 }];\n * findLast(users, o => o.age < 40);\n * // => { user: 'pebbles', age: 18 }\n *\n * findLast(users, { age: 36 });\n * // => { user: 'barney', age: 36 }\n *\n * findLast(users, ['age', 18]);\n * // => { user: 'pebbles', age: 18 }\n *\n * findLast(users, 'age');\n * // => { user: 'fred', age: 40 }\n */\nexport function findLast<T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate?: ListIterateeCustom<T, boolean>,\n  fromIndex?: number\n): T | undefined;\n\n/**\n * Finds the last element in an object that satisfies the predicate with type guard.\n *\n * @template T, S\n * @param {T | null | undefined} collection - The object to search.\n * @param {ObjectIteratorTypeGuard<T, S>} predicate - The predicate function with type guard.\n * @param {number} [fromIndex] - The index to start searching from.\n * @returns {S | undefined} The last element that satisfies the predicate.\n *\n * @example\n * const obj = { a: 1, b: 'hello', c: 3 };\n * findLast(obj, (value): value is string => typeof value === 'string');\n * // => 'hello'\n */\nexport function findLast<T extends object, S extends T[keyof T]>(\n  collection: T | null | undefined,\n  predicate: ObjectIteratorTypeGuard<T, S>,\n  fromIndex?: number\n): S | undefined;\n\n/**\n * Finds the last element in an object that satisfies the predicate.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to search.\n * @param {ObjectIterateeCustom<T, boolean>} [predicate] - The predicate function, partial object, property-value pair, or property name.\n * @param {number} [fromIndex] - The index to start searching from.\n * @returns {T[keyof T] | undefined} The last element that satisfies the predicate.\n *\n * @example\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2 }, c: { id: 3, name: 'Bob' } };\n * findLast(obj, o => o.id > 1);\n * // => { id: 3, name: 'Bob' }\n *\n * findLast(obj, { name: 'Bob' });\n * // => { id: 3, name: 'Bob' }\n *\n * findLast(obj, 'name');\n * // => { id: 3, name: 'Bob' }\n */\nexport function findLast<T extends object>(\n  collection: T | null | undefined,\n  predicate?: ObjectIterateeCustom<T, boolean>,\n  fromIndex?: number\n): T[keyof T] | undefined;\n\n/**\n * Finds the last item in an object that has a specific property, where the property name is provided as a PropertyKey.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The source array or object to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The criteria to match. It can be a function, a partial object, a key-value pair, or a property name.\n * @param {number} [fromIndex] - The index to start the search from, defaults to source.length-1 for arrays or Object.keys(source).length-1 for objects.\n * @returns {T | undefined} - The last property value that has the specified property, or `undefined` if no match is found.\n *\n * @example\n * // Using a property name\n * const obj = { a: { id: 1, name: 'Alice' }, b: { id: 2 }, c: { id: 3, name: 'Bob' } };\n * const result = findLast(obj, 'name');\n * console.log(result); // { id: 3, name: 'Bob' }\n */\nexport function findLast<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  _doesMatch:\n    | ((item: T, index: number, arr: any) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey = identity,\n  fromIndex?: number\n): T | undefined {\n  if (!source) {\n    return undefined;\n  }\n\n  const length = Array.isArray(source) ? source.length : Object.keys(source).length;\n\n  fromIndex = toInteger(fromIndex ?? length - 1);\n\n  if (fromIndex < 0) {\n    fromIndex = Math.max(length + fromIndex, 0);\n  } else {\n    fromIndex = Math.min(fromIndex, length - 1);\n  }\n\n  const doesMatch = iteratee(_doesMatch);\n\n  if (typeof doesMatch === 'function' && !Array.isArray(source)) {\n    const keys = Object.keys(source) as Array<keyof T>;\n\n    for (let i = fromIndex; i >= 0; i--) {\n      const key = keys[i];\n      const value = source[key] as T;\n\n      if (doesMatch(value, key as number, source)) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n\n  const values = Array.isArray(source) ? source.slice(0, fromIndex + 1) : Object.values(source).slice(0, fromIndex + 1);\n  return values.findLast(doesMatch);\n}\n","import { identity } from '../../function/identity.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Finds the index of the last element in the array that satisfies the predicate.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to search through.\n * @param {ListIterateeCustom<T, boolean>} [predicate] - The predicate function, partial object, property-value pair, or property name.\n * @param {number} [fromIndex] - The index to start searching from.\n * @returns {number} The index of the last matching element, or -1 if not found.\n *\n * @example\n * const users = [\n *   { user: 'barney', active: true },\n *   { user: 'fred', active: false },\n *   { user: 'pebbles', active: false }\n * ];\n *\n * findLastIndex(users, o => o.user === 'pebbles');\n * // => 2\n *\n * findLastIndex(users, { user: 'barney', active: true });\n * // => 0\n *\n * findLastIndex(users, ['active', false]);\n * // => 2\n *\n * findLastIndex(users, 'active');\n * // => 0\n */\nexport function findLastIndex<T>(\n  array: ArrayLike<T> | null | undefined,\n  predicate?: ListIterateeCustom<T, boolean>,\n  fromIndex?: number\n): number;\n\n/**\n * Finds the index of the last element in the array that satisfies the predicate.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arr - The array to search through.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} doesMatch - The predicate function, partial object, property-value pair, or property name.\n * @param {number} [fromIndex=arr.length - 1] - The index to start the search from, defaults to the last index of the array.\n * @returns {number} The index of the last matching element, or -1 if not found.\n *\n * @example\n * const items = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n * findLastIndex(items, 'name');\n * // => 1\n */\nexport function findLastIndex<T>(\n  arr: ArrayLike<T> | null | undefined,\n  doesMatch: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey = identity,\n  fromIndex: number = arr ? arr.length - 1 : 0\n): number {\n  if (!arr) {\n    return -1;\n  }\n  if (fromIndex < 0) {\n    fromIndex = Math.max(arr.length + fromIndex, 0);\n  } else {\n    fromIndex = Math.min(fromIndex, arr.length - 1);\n  }\n\n  const subArray = toArray(arr).slice(0, fromIndex + 1);\n\n  switch (typeof doesMatch) {\n    case 'function': {\n      return subArray.findLastIndex(doesMatch);\n    }\n    case 'object': {\n      if (Array.isArray(doesMatch) && doesMatch.length === 2) {\n        const key = doesMatch[0];\n        const value = doesMatch[1];\n\n        return subArray.findLastIndex(matchesProperty(key, value));\n      } else {\n        return subArray.findLastIndex(matches(doesMatch));\n      }\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      return subArray.findLastIndex(property(doesMatch));\n    }\n  }\n}\n","import { head as headToolkit } from '../../array/head.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * @template T - The type of elements in the array.\n * @param {readonly [T, ...unknown[]]} array - A non-empty tuple with at least one element.\n * @returns {T} The first element of the array.\n *\n * @example\n * const arr = [1, 2, 3] as const;\n * const first = head(arr);\n * // first will be 1\n */\nexport function head<T>(array: readonly [T, ...unknown[]]): T;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty/null/undefined.\n *\n * @example\n * const arr = [1, 2, 3];\n * const first = head(arr);\n * // first will be 1\n *\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(array: ArrayLike<T> | null | undefined): T | undefined;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | undefined | null} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: ArrayLike<T> | undefined | null): T | undefined {\n  if (!isArrayLike(arr)) {\n    return undefined;\n  }\n  return headToolkit(toArray(arr));\n}\n","/**\n * Returns the first element of an array.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} arr - A non-empty array from which to get the first element.\n * @returns {T} The first element of the array.\n *\n * @example\n * const arr = [1, 2, 3];\n * const firstElement = head(arr);\n * // firstElement will be 1\n */\nexport function head<T>(arr: readonly [T, ...T[]]): T;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly T[]): T | undefined;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Flattens array up to depth times.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} value - The array to flatten.\n * @param {number} depth - The maximum recursion depth.\n * @returns {any[]} Returns the new flattened array.\n *\n * @example\n * flatten([1, [2, [3, [4]], 5]], 2);\n * // => [1, 2, 3, [4], 5]\n */\nexport function flatten<T>(value: ArrayLike<T | readonly T[]> | null | undefined): T[];\n\nexport function flatten<T>(value: ArrayLike<T | readonly T[]> | null | undefined, depth = 1): T[] {\n  const result: T[] = [];\n  const flooredDepth = Math.floor(depth);\n\n  if (!isArrayLike(value)) {\n    return result as T[];\n  }\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (\n        currentDepth < flooredDepth &&\n        (Array.isArray(item) ||\n          Boolean(item?.[Symbol.isConcatSpreadable as keyof object]) ||\n          (item !== null && typeof item === 'object' && Object.prototype.toString.call(item) === '[object Arguments]'))\n      ) {\n        if (Array.isArray(item)) {\n          recursive(item, currentDepth + 1);\n        } else {\n          recursive(Array.from(item as T[]), currentDepth + 1);\n        }\n      } else {\n        result.push(item);\n      }\n    }\n  };\n\n  recursive(Array.from(value) as any, 0);\n\n  return result;\n}\n","import { flatten } from './flatten.ts';\nimport { ListOfRecursiveArraysOrValues } from '../_internal/ListOfRecursiveArraysOrValues.ts';\n\n/**\n * Recursively flattens array up to depth times.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to flatten.\n * @param {number} [depth=1] - The maximum recursion depth.\n * @returns {T[]} Returns the new flattened array.\n *\n * @example\n * const array = [1, [2, [3, [4]], 5]];\n *\n * flattenDepth(array, 1);\n * // => [1, 2, [3, [4]], 5]\n *\n * flattenDepth(array, 2);\n * // => [1, 2, 3, [4], 5]\n */\nexport function flattenDepth<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, depth = 1): T[] {\n  return (flatten as any)(array, depth) as T[];\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { ArrayIterator } from '../_internal/ArrayIterator.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\nimport { TupleIterator } from '../_internal/TupleIterator.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Maps each element in a tuple to a new tuple of values using an iteratee.\n *\n * @param {T} collection - The tuple to iterate over\n * @param {TupleIterator<T, U>} iteratee - The function invoked per iteration\n * @returns {{ [K in keyof T]: U }} - Returns the new mapped tuple\n *\n * @example\n * // Using a transformation function on a tuple\n * const tuple = [1, 'hello', true] as const;\n * map(tuple, value => String(value)); // => ['1', 'hello', 'true']\n */\nexport function map<T extends readonly [unknown, ...unknown[]], U>(\n  collection: T,\n  iteratee: TupleIterator<T, U>\n): { [K in keyof T]: U };\n\n/**\n * Maps each element in an array to a new array using an iteratee.\n *\n * @param {T[] | null | undefined} collection - The array to iterate over\n * @param {ArrayIterator<T, U>} iteratee - The function invoked per iteration\n * @returns {U[]} - Returns the new mapped array\n *\n * @example\n * // Using a transformation function on an array\n * const array = [1, 2, 3];\n * map(array, x => x * 2); // => [2, 4, 6]\n */\nexport function map<T, U>(collection: T[] | null | undefined, iteratee: ArrayIterator<T, U>): U[];\n\n/**\n * Maps each element in an array-like object to a new array using an iteratee.\n *\n * @param {ArrayLike<T> | null | undefined} collection - The array-like object to iterate over\n * @param {ListIterator<T, U>} iteratee - The function invoked per iteration\n * @returns {U[]} - Returns the new mapped array\n *\n * @example\n * // Using a transformation function on an array-like object\n * const arrayLike = { length: 2, 0: 'a', 1: 'b' };\n * map(arrayLike, x => x.toUpperCase()); // => ['A', 'B']\n */\nexport function map<T, U>(collection: ArrayLike<T> | null | undefined, iteratee: ListIterator<T, U>): U[];\n\n/**\n * Maps each value in an object to a new array.\n *\n * @param {Record<string, T> | Record<number, T> | null | undefined} collection - The object to iterate over\n * @returns {T[]} - Returns an array of the object's values\n *\n * @example\n * // Converting an object's values to an array\n * const obj = { a: 1, b: 2, c: 3 };\n * map(obj); // => [1, 2, 3]\n */\nexport function map<T>(collection: Record<string, T> | Record<number, T> | null | undefined): T[];\n\n/**\n * Maps each element in an object to a new array using an iteratee.\n *\n * @param {T | null | undefined} collection - The object to iterate over\n * @param {ObjectIterator<T, U>} iteratee - The function invoked per iteration\n * @returns {U[]} - Returns the new mapped array\n *\n * @example\n * // Using a transformation function on an object\n * const obj = { a: 1, b: 2 };\n * map(obj, (value, key) => `${key}:${value}`); // => ['a:1', 'b:2']\n */\nexport function map<T extends object, U>(collection: T | null | undefined, iteratee: ObjectIterator<T, U>): U[];\n\n/**\n * Maps each element in an object to a new array by plucking the specified property.\n *\n * @param {Record<string, T> | Record<number, T> | null | undefined} collection - The object to iterate over\n * @param {K} iteratee - The property to pluck from each element\n * @returns {Array<T[K]>} - Returns the new array of plucked values\n *\n * @example\n * // Plucking a property from each object\n * const users = [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }];\n * map(users, 'name'); // => ['John', 'Jane']\n */\nexport function map<T, K extends keyof T>(\n  collection: Record<string, T> | Record<number, T> | null | undefined,\n  iteratee: K\n): Array<T[K]>;\n\n/**\n * Maps each element in an object to a new array by plucking the specified string property.\n *\n * @param {Record<string, T> | Record<number, T> | null | undefined} collection - The object to iterate over\n * @param {string} [iteratee] - The string property to pluck from each element\n * @returns {any[]} - Returns the new array of plucked values\n *\n * @example\n * // Plucking a nested property\n * const users = [{ info: { name: 'John' } }, { info: { name: 'Jane' } }];\n * map(users, 'info.name'); // => ['John', 'Jane']\n */\nexport function map<T>(collection: Record<string, T> | Record<number, T> | null | undefined, iteratee?: string): any[];\n\n/**\n * Maps each element in an object to a new array by matching against a source object.\n *\n * @param {Record<string, T> | Record<number, T> | null | undefined} collection - The object to iterate over\n * @param {object} [iteratee] - The object to match against\n * @returns {boolean[]} - Returns an array of boolean values indicating matches\n *\n * @example\n * // Matching against a source object\n * const users = [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }];\n * map(users, { age: 30 }); // => [true, false]\n */\nexport function map<T>(\n  collection: Record<string, T> | Record<number, T> | null | undefined,\n  iteratee?: object\n): boolean[];\n\nexport function map(\n  collection: any[] | ArrayLike<any> | Record<any, any> | null | undefined,\n  _iteratee?: ((value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object | null\n): any[] {\n  if (!collection) {\n    return [];\n  }\n\n  const keys: PropertyKey[] =\n    isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);\n\n  const iteratee = iterateeToolkit(_iteratee ?? identity);\n\n  const result: any[] = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    result[i] = iteratee(value, key, collection);\n  }\n\n  return result;\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x: unknown): x is null | undefined {\n  return x == null;\n}\n","import { flattenDepth } from './flattenDepth.ts';\nimport { map } from './map.ts';\nimport { isNil } from '../../predicate/isNil.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @template T\n * @param {Record<string, Many<T>> | Record<number, Many<T>> | null | undefined} collection - The collection to iterate over.\n * @returns {T[]} Returns the new flattened array.\n *\n * @example\n * const obj = { a: [1, 2], b: [3, 4] };\n * flatMap(obj);\n * // => [1, 2, 3, 4]\n */\nexport function flatMap<T>(collection: Record<string, Many<T>> | Record<number, Many<T>> | null | undefined): T[];\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @returns {any[]} Returns the new flattened array.\n *\n * @example\n * flatMap({ a: 1, b: 2 });\n * // => [1, 2]\n */\nexport function flatMap(collection: object | null | undefined): any[];\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @template T, R\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {ListIterator<T, Many<R>>} iteratee - The function invoked per iteration.\n * @returns {R[]} Returns the new flattened array.\n *\n * @example\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nexport function flatMap<T, R>(collection: ArrayLike<T> | null | undefined, iteratee: ListIterator<T, Many<R>>): R[];\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @template T, R\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ObjectIterator<T, Many<R>>} iteratee - The function invoked per iteration.\n * @returns {R[]} Returns the new flattened array.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * flatMap(obj, (value, key) => [key, value]);\n * // => ['a', 1, 'b', 2]\n */\nexport function flatMap<T extends object, R>(\n  collection: T | null | undefined,\n  iteratee: ObjectIterator<T, Many<R>>\n): R[];\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {string} iteratee - The property name to use as iteratee.\n * @returns {any[]} Returns the new flattened array.\n *\n * @example\n * const users = [\n *   { user: 'barney', hobbies: ['hiking', 'coding'] },\n *   { user: 'fred', hobbies: ['reading'] }\n * ];\n * flatMap(users, 'hobbies');\n * // => ['hiking', 'coding', 'reading']\n */\nexport function flatMap(collection: object | null | undefined, iteratee: string): any[];\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {object} iteratee - The object properties to match.\n * @returns {boolean[]} Returns the new flattened array.\n *\n * @example\n * const users = [\n *   { user: 'barney', age: 36, active: true },\n *   { user: 'fred', age: 40, active: false }\n * ];\n * flatMap(users, { active: false });\n * // => [false]\n */\nexport function flatMap(collection: object | null | undefined, iteratee: object): boolean[];\n\n/**\n * Creates a flattened array of values by running each element in collection through iteratee and flattening the mapped results.\n *\n * @template R\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {any} [iteratee] - The function invoked per iteration.\n * @returns {R[]} Returns the new flattened array.\n *\n * @example\n * flatMap([1, 2], n => [n, n * 2]);\n * // => [1, 2, 2, 4]\n */\nexport function flatMap<R = any>(collection: object | null | undefined, iteratee?: any): R[] {\n  if (isNil(collection)) {\n    return [];\n  }\n\n  // eslint-disable-next-line\n  // @ts-ignore\n  const mapped = isNil(iteratee) ? map(collection) : map(collection, iteratee);\n\n  return flattenDepth(mapped, 1) as R[];\n}\n","import { flatten } from './flatten.ts';\nimport { map } from './map.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { ListOfRecursiveArraysOrValues } from '../_internal/ListOfRecursiveArraysOrValues.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a flattened array of values by running each element through iteratee and flattening the mapped results up to depth times.\n *\n * @template T\n * @param {Record<string, ListOfRecursiveArraysOrValues<T> | T> | Record<number, ListOfRecursiveArraysOrValues<T> | T> | null | undefined} collection - The collection to iterate over.\n * @returns {T[]} Returns the new flattened array.\n *\n * @example\n * const obj = { a: [[1, 2]], b: [[[3]]] };\n * flatMapDepth(obj);\n * // => [1, 2, [3]]\n */\nexport function flatMapDepth<T>(\n  collection:\n    | Record<string, ListOfRecursiveArraysOrValues<T> | T>\n    | Record<number, ListOfRecursiveArraysOrValues<T> | T>\n    | null\n    | undefined\n): T[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and flattening the mapped results up to depth times.\n *\n * @template T, R\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {ListIterator<T, RecursiveArray<R> | R>} iteratee - The function invoked per iteration.\n * @param {number} [depth=1] - The maximum recursion depth.\n * @returns {R[]} Returns the new flattened array.\n *\n * @example\n * function duplicate(n) {\n *   return [[n, n]];\n * }\n *\n * flatMapDepth([1, 2], duplicate, 2);\n * // => [1, 1, 2, 2]\n */\nexport function flatMapDepth<T, R>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<R> | R>,\n  depth?: number\n): R[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and flattening the mapped results up to depth times.\n *\n * @template T, R\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ObjectIterator<T, RecursiveArray<R> | R>} iteratee - The function invoked per iteration.\n * @param {number} [depth=1] - The maximum recursion depth.\n * @returns {R[]} Returns the new flattened array.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * flatMapDepth(obj, (value, key) => [[key, value]], 2);\n * // => ['a', 1, 'b', 2]\n */\nexport function flatMapDepth<T extends object, R>(\n  collection: T | null | undefined,\n  iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<R> | R>,\n  depth?: number\n): R[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and flattening the mapped results up to depth times.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {string} iteratee - The property name to use as iteratee.\n * @param {number} [depth=1] - The maximum recursion depth.\n * @returns {any[]} Returns the new flattened array.\n *\n * @example\n * const users = [\n *   { user: 'barney', hobbies: [['hiking'], ['coding']] },\n *   { user: 'fred', hobbies: [['reading']] }\n * ];\n * flatMapDepth(users, 'hobbies', 2);\n * // => ['hiking', 'coding', 'reading']\n */\nexport function flatMapDepth(collection: object | null | undefined, iteratee: string, depth?: number): any[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and flattening the mapped results up to depth times.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {object} iteratee - The object properties to match.\n * @param {number} [depth=1] - The maximum recursion depth.\n * @returns {boolean[]} Returns the new flattened array.\n *\n * @example\n * const users = [\n *   { user: 'barney', active: [[true], [false]] },\n *   { user: 'fred', active: [[false]] }\n * ];\n * flatMapDepth(users, { active: [[false]] });\n * // => [false]\n */\nexport function flatMapDepth(collection: object | null | undefined, iteratee: object, depth?: number): boolean[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and flattening the mapped results up to depth times.\n *\n * @template T, R\n * @param {Record<string, ArrayLike<T | ListOfRecursiveArraysOrValues<T>> | T> | Record<number, ArrayLike<T | ListOfRecursiveArraysOrValues<T>> | T> | ArrayLike<T> | object | null | undefined} collection - The array or object to iterate over.\n * @param {((value: T, index: number, array: ArrayLike<T>) => ArrayLike<R | RecursiveArray<R>> | R) | ((value: T[keyof T], key: string, object: T) => ArrayLike<R | RecursiveArray<R>> | R) | string | object} [iteratee] - The function that produces the new array elements.\n * @param {number} [depth=1] - The maximum recursion depth.\n * @returns {T[] | R[] | any[] | boolean[]} A new array that has been flattened up to the specified depth.\n *\n * @example\n * flatMapDepth([1, 2, 3], n => [[n, n]], 2);\n * // => [1, 1, 2, 2, 3, 3]\n */\nexport function flatMapDepth<T, R>(\n  collection:\n    | Record<string, ArrayLike<T | ListOfRecursiveArraysOrValues<T>> | T>\n    | Record<number, ArrayLike<T | ListOfRecursiveArraysOrValues<T>> | T>\n    | ArrayLike<T>\n    | object\n    | null\n    | undefined,\n  iteratee:\n    | ((value: T, index: number, array: ArrayLike<T>) => ArrayLike<R | ListOfRecursiveArraysOrValues<R>> | R)\n    | ((value: T[keyof T], key: string, object: T) => ArrayLike<R | ListOfRecursiveArraysOrValues<R>> | R)\n    | string\n    | object = identity,\n  depth = 1\n): T[] | R[] | any[] | boolean[] {\n  if (collection == null) {\n    return [];\n  }\n\n  const iterateeFn = createIteratee(iteratee);\n  const mapped = map(collection, iterateeFn);\n\n  return (flatten as any)(mapped, depth);\n}\n","import { flatMapDepth } from './flatMapDepth.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { ListOfRecursiveArraysOrValues } from '../_internal/ListOfRecursiveArraysOrValues.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\n\ntype RecursiveArray<T> = Array<T | RecursiveArray<T>>;\n\n/**\n * Creates a flattened array of values by running each element through iteratee and recursively flattening the mapped results.\n *\n * @template T\n * @param {Record<string, RecursiveArray<T> | T> | Record<number, RecursiveArray<T> | T> | null | undefined} collection - The collection to iterate over.\n * @returns {T[]} Returns the new deeply flattened array.\n *\n * @example\n * const obj = { a: [[1, 2]], b: [[[3]]] };\n * flatMapDeep(obj);\n * // => [1, 2, 3]\n */\nexport function flatMapDeep<T>(\n  collection:\n    | Record<string, ListOfRecursiveArraysOrValues<T> | T>\n    | Record<number, ListOfRecursiveArraysOrValues<T> | T>\n    | null\n    | undefined\n): T[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and recursively flattening the mapped results.\n *\n * @template T, R\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {ListIterator<T, RecursiveArray<R> | R>} iteratee - The function invoked per iteration.\n * @returns {R[]} Returns the new deeply flattened array.\n *\n * @example\n * function duplicate(n) {\n *   return [[[n, n]]];\n * }\n *\n * flatMapDeep([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nexport function flatMapDeep<T, R>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<R> | R>\n): R[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and recursively flattening the mapped results.\n *\n * @template T, R\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ObjectIterator<T, RecursiveArray<R> | R>} iteratee - The function invoked per iteration.\n * @returns {R[]} Returns the new deeply flattened array.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * flatMapDeep(obj, (value, key) => [[[key, value]]]);\n * // => ['a', 1, 'b', 2]\n */\nexport function flatMapDeep<T extends object, R>(\n  collection: T | null | undefined,\n  iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<R> | R>\n): R[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and recursively flattening the mapped results.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {string} iteratee - The property name to use as iteratee.\n * @returns {any[]} Returns the new deeply flattened array.\n *\n * @example\n * const users = [\n *   { user: 'barney', hobbies: [['hiking', 'coding']] },\n *   { user: 'fred', hobbies: [['reading']] }\n * ];\n * flatMapDeep(users, 'hobbies');\n * // => ['hiking', 'coding', 'reading']\n */\nexport function flatMapDeep(collection: object | null | undefined, iteratee: string): any[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and recursively flattening the mapped results.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {object} iteratee - The object properties to match.\n * @returns {boolean[]} Returns the new deeply flattened array.\n *\n * @example\n * const users = [\n *   { user: 'barney', active: [true, false] },\n *   { user: 'fred', active: [false] }\n * ];\n * flatMapDeep(users, { active: [false] });\n * // => [false]\n */\nexport function flatMapDeep(collection: object | null | undefined, iteratee: object): boolean[];\n\n/**\n * Creates a flattened array of values by running each element through iteratee and recursively flattening the mapped results.\n *\n * @template T, R\n * @param {Record<string, ArrayLike<T | RecursiveArray<T>> | T> | Record<number, ArrayLike<T | RecursiveArray<T>> | T> | ArrayLike<T> | object | null | undefined} collection - The array or object to iterate over.\n * @param {((value: T, index: number, array: ArrayLike<T>) => ArrayLike<R | RecursiveArray<R>> | R) | ((value: T[keyof T], key: string, object: T) => ArrayLike<R | RecursiveArray<R>> | R) | string | object} [iteratee] - The function that produces the new array elements.\n * @returns {T[] | R[] | any[] | boolean[]} A new array that has been deeply flattened.\n *\n * @example\n * flatMapDeep([1, 2, 3], n => [[n, n]]);\n * // => [1, 1, 2, 2, 3, 3]\n */\nexport function flatMapDeep<T, R>(\n  collection:\n    | Record<string, ArrayLike<T | RecursiveArray<T>> | T>\n    | Record<number, ArrayLike<T | RecursiveArray<T>> | T>\n    | ArrayLike<T>\n    | object\n    | null\n    | undefined,\n  iteratee?:\n    | ((value: T, index: number, array: ArrayLike<T>) => ArrayLike<R | RecursiveArray<R>> | R)\n    | ((value: T[keyof T], key: string, object: T) => ArrayLike<R | RecursiveArray<R>> | R)\n    | string\n    | object\n): T[] | R[] | any[] | boolean[] {\n  return flatMapDepth(collection, iteratee as any, Infinity);\n}\n","import { flattenDepth } from './flattenDepth.ts';\nimport { ListOfRecursiveArraysOrValues } from '../_internal/ListOfRecursiveArraysOrValues.ts';\n\n/**\n * Recursively flattens array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to flatten.\n * @returns {Array<ExtractNestedArrayType<T>>} Returns the new flattened array.\n *\n * @example\n * flattenDeep([1, [2, [3, [4]], 5]]);\n * // => [1, 2, 3, 4, 5]\n */\nexport function flattenDeep<T>(\n  value: ListOfRecursiveArraysOrValues<T> | null | undefined\n): Array<T extends string ? T : T extends ArrayLike<any> ? never : T> {\n  return flattenDepth(value, Infinity) as any;\n}\n","import { groupBy as groupByToolkit } from '../../array/groupBy.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates an object composed of keys generated from the results of running each element of collection through iteratee.\n * The order of grouped values is determined by the order they occur in collection.\n *\n * @template T - The type of elements in the array-like collection\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over\n * @param {ValueIteratee<T>} [iteratee=identity] - The iteratee to transform keys\n * @returns {Record<string, T[]>} Returns the composed aggregate object\n *\n * @example\n * groupBy([6.1, 4.2, 6.3], Math.floor)\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * groupBy(['one', 'two', 'three'], 'length')\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nexport function groupBy<T>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIteratee<T>\n): Record<string, T[]>;\n\n/**\n * Creates an object composed of keys generated from the results of running each element of collection through iteratee.\n * The order of grouped values is determined by the order they occur in collection.\n *\n * @template T - The type of the object\n * @param {T | null | undefined} collection - The object to iterate over\n * @param {ValueIteratee<T[keyof T]>} [iteratee=identity] - The iteratee to transform keys\n * @returns {Record<string, Array<T[keyof T]>>} Returns the composed aggregate object\n *\n * @example\n * groupBy({ a: 6.1, b: 4.2, c: 6.3 }, Math.floor)\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n */\nexport function groupBy<T extends object>(\n  collection: T | null | undefined,\n  iteratee?: ValueIteratee<T[keyof T]>\n): Record<string, Array<T[keyof T]>>;\n\n/**\n * Groups the elements of an array or object based on a provided key-generating function.\n *\n * This function takes an array or object and a function that generates a key from each element or value.\n * It returns an object where the keys are the generated keys and the values are arrays of elements that\n * share the same key.\n *\n * @template T - The type of elements in the array or values in the object.\n * @template K - The type of keys.\n * @param {ArrayLike<T> | Record<any, T> | null | undefined} source - The collection to group.\n * @param {Function | PropertyKey | Array | Object} [_getKeyFromItem] - The iteratee to transform keys.\n *   - If a function is provided, it's invoked for each element in the collection.\n *   - If a property name (string) is provided, that property of each element is used as the key.\n *   - If a property-value pair (array) is provided, elements with matching property values are used.\n *   - If a partial object is provided, elements with matching properties are used.\n * @returns {Record<K, T>} An object where each key is associated with an array of elements that\n * share that key.\n *\n * @example\n * // Using an array\n * const array = [6.1, 4.2, 6.3];\n * const result = groupBy(array, Math.floor);\n * // => { 4: [4.2], 6: [6.1, 6.3] }\n *\n * @example\n * // Using a property name\n * const array = ['one', 'two', 'three'];\n * const result = groupBy(array, 'length');\n * // => { 3: ['one', 'two'], 5: ['three'] }\n */\nexport function groupBy<T, K extends PropertyKey>(\n  source: ArrayLike<T> | Record<any, T> | null | undefined,\n  _getKeyFromItem?:\n    | ((item: T, index: number, arr: any) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey\n    | null\n): Record<K, T[]> {\n  if (source == null) {\n    return {} as Record<K, T[]>;\n  }\n\n  const items = isArrayLike(source) ? Array.from(source) : Object.values(source);\n  const getKeyFromItem = createIteratee(_getKeyFromItem ?? identity);\n\n  return groupByToolkit<T, K>(items, getKeyFromItem);\n}\n","/**\n * Groups the elements of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are arrays of elements that share\n * the same key.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array to group.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T[]>} An object where each key is associated with an array of elements that\n * share that key.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = groupBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: [\n * //     { category: 'fruit', name: 'apple' },\n * //     { category: 'fruit', name: 'banana' }\n * //   ],\n * //   vegetable: [\n * //     { category: 'vegetable', name: 'carrot' }\n * //   ]\n * // }\n */\nexport function groupBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = getKeyFromItem(item);\n\n    if (!Object.hasOwn(result, key)) {\n      result[key] = [];\n    }\n\n    result[key].push(item);\n  }\n\n  return result;\n}\n","import { isString } from '../predicate/isString.ts';\nimport { eq } from '../util/eq.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Checks if a specified value exists within a given array-like collection.\n *\n * The comparison uses SameValueZero to check for inclusion.\n *\n * @template T The type of elements in the collection\n * @param collection The array-like collection to search in\n * @param target The value to search for in the collection\n * @param [fromIndex=0] The index to start searching from. If negative, it is treated as an offset from the end\n * @returns `true` if the value is found in the collection, `false` otherwise\n *\n * @example\n * includes([1, 2, 3], 2); // true\n * includes([1, 2, 3], 4); // false\n * includes('hello', 'e'); // true\n * includes(null, 1); // false\n * includes([1, 2, 3], 2, 2); // false\n * includes([1, 2, 3], 2, -2); // true\n */\nexport function includes<T>(\n  collection: Record<string, T> | Record<number, T> | null | undefined,\n  target: T,\n  fromIndex?: number\n): boolean;\n\n/**\n * Checks if a specified value exists within a given source, which can be an array, an object, or a string.\n *\n * The comparison uses SameValueZero to check for inclusion.\n *\n * @param {T[] | Record<string, any> | string} source - The source to search in. It can be an array, an object, or a string.\n * @param {T} [target] - The value to search for in the source.\n * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the source.\n * @returns {boolean} `true` if the value is found in the source, `false` otherwise.\n *\n * @example\n * includes([1, 2, 3], 2); // true\n * includes({ a: 1, b: 'a', c: NaN }, 'a'); // true\n * includes('hello world', 'world'); // true\n * includes('hello world', 'test'); // false\n */\nexport function includes(\n  source: readonly unknown[] | Record<string, any> | string | null | undefined,\n  target?: unknown,\n  fromIndex?: number,\n  guard?: unknown\n): boolean {\n  if (source == null) {\n    return false;\n  }\n\n  if (guard || !fromIndex) {\n    fromIndex = 0;\n  } else {\n    fromIndex = toInteger(fromIndex);\n  }\n\n  if (isString(source)) {\n    if (fromIndex > source.length || target instanceof RegExp) {\n      return false;\n    }\n\n    if (fromIndex < 0) {\n      fromIndex = Math.max(0, source.length + fromIndex);\n    }\n\n    return source.includes(target as any, fromIndex);\n  }\n\n  if (Array.isArray(source)) {\n    return source.includes(target, fromIndex);\n  }\n\n  const keys = Object.keys(source);\n\n  if (fromIndex < 0) {\n    fromIndex = Math.max(0, keys.length + fromIndex);\n  }\n\n  for (let i = fromIndex; i < keys.length; i++) {\n    const value = Reflect.get(source, keys[i]);\n\n    if (eq(value, target)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Finds the index of the first occurrence of a value in an array.\n *\n * This method is similar to `Array.prototype.indexOf`, but it also finds `NaN` values.\n * It uses strict equality (`===`) to compare elements.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to search.\n * @param {T} searchElement - The value to search for.\n * @param {number} [fromIndex] - The index to start the search at.\n * @returns {number} The index (zero-based) of the first occurrence of the value in the array, or `-1` if the value is not found.\n *\n * @example\n * const array = [1, 2, 3, NaN];\n * indexOf(array, 3); // => 2\n * indexOf(array, NaN); // => 3\n */\nexport function indexOf<T>(array: ArrayLike<T> | null | undefined, searchElement: T, fromIndex?: number): number {\n  if (!isArrayLike(array)) {\n    return -1;\n  }\n\n  // `Array.prototype.indexOf` doesn't find `NaN` values, so we need to handle that case separately.\n  if (Number.isNaN(searchElement)) {\n    fromIndex = fromIndex ?? 0;\n\n    if (fromIndex < 0) {\n      fromIndex = Math.max(0, array.length + fromIndex);\n    }\n\n    for (let i = fromIndex; i < array.length; i++) {\n      if (Number.isNaN(array[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  // Array.prototype.indexOf already handles `fromIndex < -array.length`, `fromIndex >= array.length` and converts `fromIndex` to an integer, so we don't need to handle those cases here.\n  // And it uses strict equality (===) to compare elements like `lodash/indexOf` does.\n  return Array.from(array).indexOf(searchElement, fromIndex);\n}\n","import { initial as initialToolkit } from '../../array/initial.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns a new array containing all elements except the last one from the input array.\n * If the input array is empty or has only one element, the function returns an empty array.\n *\n * @template T The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The input array.\n * @returns {T[]} A new array containing all but the last element of the input array.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const result = initial(arr);\n * // result will be [1, 2, 3]\n */\nexport function initial<T>(arr: ArrayLike<T> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n  return initialToolkit(Array.from(arr));\n}\n","/**\n * Returns an empty array when the input is a tuple containing exactly one element.\n *\n * @template T The type of the single element.\n * @param {[T]} arr - A tuple containing exactly one element.\n * @returns {[]} An empty array since there is only one element.\n *\n * @example\n * const array = [100] as const;\n * const result = initial(array);\n * // result will be []\n */\nexport function initial<T>(arr: readonly [T]): [];\n\n/**\n * Returns an empty array when the input array is empty.\n *\n * @returns {[]} Always returns an empty array for an empty input.\n *\n * @example\n * const array = [] as const;\n * const result = initial(array);\n * // result will be []\n */\nexport function initial(arr: readonly []): [];\n\n/**\n * Returns a new array containing all elements except the last one from a tuple with multiple elements.\n *\n * @template T The types of the initial elements.\n * @template U The type of the last element in the tuple.\n * @param {[...T[], U]} arr - A tuple with one or more elements.\n * @returns {T[]} A new array containing all but the last element of the tuple.\n *\n * @example\n * const array = ['apple', 'banana', 'cherry'] as const;\n * const result = initial(array);\n * // result will be ['apple', 'banana']\n */\nexport function initial<T, U>(arr: readonly [...T[], U]): T[];\n\n/**\n * Returns a new array containing all elements except the last one from the input array.\n * If the input array is empty or has only one element, the function returns an empty array.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The input array.\n * @returns {T[]} A new array containing all but the last element of the input array.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const result = initial(arr);\n * // result will be [1, 2, 3]\n */\nexport function initial<T>(arr: readonly T[]): T[];\n\n/**\n * Returns a new array containing all elements except the last one from the input array.\n * If the input array is empty or has only one element, the function returns an empty array.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The input array.\n * @returns {T[]} A new array containing all but the last element of the input array.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const result = initial(arr);\n * // result will be [1, 2, 3]\n */\nexport function initial<T>(arr: readonly T[]): T[] {\n  return arr.slice(0, -1);\n}\n","/**\n * Returns the intersection of two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements that are\n * present in both arrays. It effectively filters out any elements from the first array that\n * are not found in the second array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @returns {T[]} A new array containing the elements that are present in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => {\n    return secondSet.has(item);\n  });\n}\n","/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: readonly T[]): T[] {\n  return Array.from(new Set(arr));\n}\n","import { intersection as intersectionToolkit } from '../../array/intersection.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Returns the intersection of multiple arrays.\n *\n * This function takes multiple arrays and returns a new array containing the elements that are\n * present in all provided arrays. It effectively filters out any elements that are not found\n * in every array.\n *\n * @template T - The type of elements in the arrays.\n * @param {...(ArrayLike<T> | null | undefined)} arrays - The arrays to compare.\n * @returns {T[]} A new array containing the elements that are present in all arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(...arrays: Array<ArrayLike<T> | null | undefined>): T[] {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  if (!isArrayLikeObject(arrays[0])) {\n    return [];\n  }\n\n  let result: T[] = uniq(Array.from(arrays[0]));\n\n  for (let i = 1; i < arrays.length; i++) {\n    const array = arrays[i];\n\n    if (!isArrayLikeObject(array)) {\n      return [];\n    }\n\n    result = intersectionToolkit(result, Array.from(array));\n  }\n\n  return result;\n}\n","/**\n * Returns the intersection of two arrays based on a mapping function.\n *\n * This function takes two arrays and a mapping function. It returns a new array containing\n * the elements from the first array that, when mapped using the provided function, have matching\n * mapped elements in the second array. It effectively filters out any elements from the first array\n * that do not have corresponding mapped values in the second array.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(item: T | U) => unknown} mapper - A function to map the elements of both arrays for comparison.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const mapper = item => (typeof item === 'object' ? item.id : item);\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2, name: 'amy' }] since only this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionBy<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  mapper: (item: T | U) => unknown\n): T[] {\n  const mappedSecondSet = new Set(secondArr.map(mapper));\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\n}\n","import { intersectionBy as intersectionByToolkit } from '../../array/intersectionBy.ts';\nimport { last } from '../../array/last.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { property } from '../object/property.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Creates an array of unique values that are included in all given arrays, using an iteratee to compute equality.\n *\n * @template T, U\n * @param {ArrayLike<T> | null} array - The array to inspect.\n * @param {ArrayLike<U>} values - The values to compare.\n * @param {ValueIteratee<T | U>} iteratee - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // => [2.1]\n */\nexport function intersectionBy<T, U>(\n  array: ArrayLike<T> | null,\n  values: ArrayLike<U>,\n  iteratee: ValueIteratee<T | U>\n): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays, using an iteratee to compute equality.\n *\n * @template T, U, V\n * @param {ArrayLike<T> | null} array - The array to inspect.\n * @param {ArrayLike<U>} values1 - The first values to compare.\n * @param {ArrayLike<V>} values2 - The second values to compare.\n * @param {ValueIteratee<T | U | V>} iteratee - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * intersectionBy([2.1, 1.2], [2.3, 3.4], [2.5], Math.floor);\n * // => [2.1]\n */\nexport function intersectionBy<T, U, V>(\n  array: ArrayLike<T> | null,\n  values1: ArrayLike<U>,\n  values2: ArrayLike<V>,\n  iteratee: ValueIteratee<T | U | V>\n): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays, using an iteratee to compute equality.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T> | null | undefined} array - The array to inspect.\n * @param {ArrayLike<U>} values1 - The first values to compare.\n * @param {ArrayLike<V>} values2 - The second values to compare.\n * @param {...Array<ArrayLike<W> | ValueIteratee<T | U | V | W>>} values - The other arrays to compare, and the iteratee to use.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * intersectionBy([2.1, 1.2], [2.3, 3.4], [2.5], [2.6, 1.7], Math.floor);\n * // => [2.1]\n */\nexport function intersectionBy<T, U, V, W>(\n  array: ArrayLike<T> | null | undefined,\n  values1: ArrayLike<U>,\n  values2: ArrayLike<V>,\n  ...values: Array<ArrayLike<W> | ValueIteratee<T | U | V | W>>\n): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays.\n *\n * @template T\n * @param {ArrayLike<T> | null} [array] - The array to inspect.\n * @param {...Array<ArrayLike<T>>} values - The values to compare.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * intersectionBy([2, 1], [2, 3]);\n * // => [2]\n */\nexport function intersectionBy<T>(array?: ArrayLike<T> | null, ...values: Array<ArrayLike<T>>): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays, using an iteratee to compute equality.\n *\n * @template T\n * @param {...Array<ArrayLike<T> | ValueIteratee<T>>} values - The arrays to compare and the iteratee to use.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // => [2.1]\n */\nexport function intersectionBy<T>(...values: Array<ArrayLike<T> | ValueIteratee<T>>): T[];\n\n/**\n * Returns the intersection of multiple arrays after applying the iteratee function to their elements.\n *\n * This function takes multiple arrays and an optional iteratee function (or property key)\n * to compare the elements after transforming them. It returns a new array containing the elements from\n * the first array that are present in all subsequent arrays after applying the iteratee to each element.\n * If no iteratee is provided, the identity function is used.\n *\n * If the first array is `null` or `undefined`, an empty array is returned.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The first array to compare.\n * @param {...(ArrayLike<T> | ((value: T) => unknown) | string)} values - The arrays to compare, or the iteratee function.\n * @returns {T[]} A new array containing the elements from the first array that are present\n *  in all subsequent arrays after applying the iteratee.\n *\n * @example\n * const array1 = [{ x: 1 }, { x: 2 }, { x: 3 }];\n * const array2 = [{ x: 2 }, { x: 3 }];\n * const result = intersectionBy(array1, array2, 'x');\n * // result will be [{ x: 2 }, { x: 3 }] since these elements have the same `x` property.\n *\n * @example\n * const array1 = [1.1, 2.2, 3.3];\n * const array2 = [2.3, 3.3];\n * const result = intersectionBy(array1, array2, Math.floor);\n * // result will be [2.3, 3.3] since it shares the same integer part when `Math.floor` is applied.\n */\nexport function intersectionBy<T>(array: any, ...values: any[]): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  const lastValue = last(values);\n  if (lastValue === undefined) {\n    return Array.from(array) as T[];\n  }\n\n  let result = uniq(Array.from(array));\n\n  const count = isArrayLikeObject(lastValue) ? values.length : values.length - 1;\n\n  for (let i = 0; i < count; ++i) {\n    const value = values[i];\n\n    if (!isArrayLikeObject(value)) {\n      return [];\n    }\n\n    if (isArrayLikeObject(lastValue)) {\n      result = intersectionByToolkit(result, Array.from(value), identity);\n    } else if (typeof lastValue === 'function') {\n      result = intersectionByToolkit(result, Array.from(value), value => lastValue(value));\n    } else if (typeof lastValue === 'string') {\n      result = intersectionByToolkit(result, Array.from(value), property(lastValue));\n    }\n  }\n\n  return result as T[];\n}\n","/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2, name: 'amy' }] since this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionWith<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  areItemsEqual: (x: T, y: U) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.some(secondItem => {\n      return areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","import { uniq as uniqToolkit } from '../../array/uniq.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: ArrayLike<T> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n  return uniqToolkit(Array.from(arr));\n}\n","import { last } from './last.ts';\nimport { intersectionWith as intersectionWithToolkit } from '../../array/intersectionWith.ts';\nimport { uniq as uniqToolkit } from '../array/uniq.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Creates an array of unique values that are included in all given arrays, using a comparator function for equality comparisons.\n *\n * @template T, U\n * @param {ArrayLike<T> | null | undefined} array - The array to inspect.\n * @param {ArrayLike<U>} values - The values to compare.\n * @param {(a: T, b: T | U) => boolean} comparator - The comparator invoked per element.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * const others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n * intersectionWith(objects, others, (a, b) => a.x === b.x && a.y === b.y);\n * // => [{ 'x': 1, 'y': 2 }]\n */\nexport function intersectionWith<T, U>(\n  array: ArrayLike<T> | null | undefined,\n  values: ArrayLike<U>,\n  comparator: (a: T, b: T | U) => boolean\n): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays, using a comparator function for equality comparisons.\n *\n * @template T, U, V\n * @param {ArrayLike<T> | null | undefined} array - The array to inspect.\n * @param {ArrayLike<U>} values1 - The first values to compare.\n * @param {ArrayLike<V>} values2 - The second values to compare.\n * @param {(a: T, b: T | U | V) => boolean} comparator - The comparator invoked per element.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * const others1 = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n * const others2 = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }];\n * intersectionWith(objects, others1, others2, (a, b) => a.x === b.x && a.y === b.y);\n * // => [{ 'x': 1, 'y': 2 }]\n */\nexport function intersectionWith<T, U, V>(\n  array: ArrayLike<T> | null | undefined,\n  values1: ArrayLike<U>,\n  values2: ArrayLike<V>,\n  comparator: (a: T, b: T | U | V) => boolean\n): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays, using a comparator function for equality comparisons.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T> | null | undefined} array - The array to inspect.\n * @param {ArrayLike<U>} values1 - The first values to compare.\n * @param {ArrayLike<V>} values2 - The second values to compare.\n * @param {...Array<ArrayLike<W> | (a: T, b: T | U | V | W) => boolean>} values - The other arrays to compare, and the comparator to use.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * const others1 = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n * const others2 = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }];\n * const others3 = [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }];\n * intersectionWith(objects, others1, others2, others3, (a, b) => a.x === b.x && a.y === b.y);\n * // => [{ 'x': 1, 'y': 2 }]\n */\nexport function intersectionWith<T, U, V, W>(\n  array: ArrayLike<T> | null | undefined,\n  values1: ArrayLike<U>,\n  values2: ArrayLike<V>,\n  ...values: Array<ArrayLike<W> | ((a: T, b: T | U | V | W) => boolean)>\n): T[];\n\n/**\n * Creates an array of unique values that are included in all given arrays.\n *\n * @template T\n * @param {ArrayLike<T> | null} [array] - The array to inspect.\n * @param {...Array<ArrayLike<T> | (a: T, b: never) => boolean>} values - The values to compare.\n * @returns {T[]} Returns the new array of intersecting values.\n *\n * @example\n * intersectionWith([2, 1], [2, 3]);\n * // => [2]\n */\nexport function intersectionWith<T>(\n  array?: ArrayLike<T> | null,\n  ...values: Array<ArrayLike<T> | ((a: T, b: never) => boolean)>\n): T[];\n\n/**\n * Returns the intersection of multiple arrays based on a custom equality function.\n *\n * @template T - The type of elements in the arrays\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {...(ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean))} otherArrs - Additional arrays and optional equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const result = intersectionWith(arr1, arr2, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T>(firstArr: ArrayLike<T> | null | undefined, ...otherArrs: any[]): T[] {\n  if (firstArr == null) {\n    return [];\n  }\n\n  const _comparator = last(otherArrs);\n  let comparator = eq as (x: T, y: T) => boolean;\n  let uniq: (arr: T[]) => T[] = uniqToolkit;\n\n  if (typeof _comparator === 'function') {\n    comparator = _comparator;\n    uniq = uniqPreserve0;\n    otherArrs.pop();\n  }\n\n  let result = uniq(Array.from(firstArr));\n\n  for (let i = 0; i < otherArrs.length; ++i) {\n    const otherArr = otherArrs[i] as ArrayLike<T>;\n\n    if (otherArr == null) {\n      return [];\n    }\n\n    result = intersectionWithToolkit(result, Array.from(otherArr), comparator);\n  }\n\n  return result;\n}\n\n/**\n * This function is to preserve the sign of `-0`, which is a behavior in lodash.\n */\nfunction uniqPreserve0<T>(arr: T[]): T[] {\n  const result = [];\n  const added = new Set();\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n\n    if (added.has(item)) {\n      continue;\n    }\n\n    result.push(item);\n    added.add(item);\n  }\n\n  return result;\n}\n","declare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Checks if the given value is a Buffer instance.\n *\n * This function tests whether the provided value is an instance of Buffer.\n * It returns `true` if the value is a Buffer, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Buffer`.\n *\n * @param {unknown} x - The value to check if it is a Buffer.\n * @returns {boolean} Returns `true` if `x` is a Buffer, else `false`.\n *\n * @example\n * const buffer = Buffer.from(\"test\");\n * console.log(isBuffer(buffer)); // true\n *\n * const notBuffer = \"not a buffer\";\n * console.log(isBuffer(notBuffer)); // false\n */\nexport function isBuffer(x: unknown): boolean {\n  // eslint-disable-next-line\n  // @ts-ignore\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(x);\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * @param {object} value - The value to check.\n * @returns {value is Record<PropertyKey, any>} - True if the value is a plain object, otherwise false.\n *\n * @example\n * ```typescript\n * //  True\n *\n * isPlainObject({ });                       // \n * isPlainObject({ key: 'value' });          // \n * isPlainObject({ key: new Date() });       // \n * isPlainObject(new Object());              // \n * isPlainObject(Object.create(null));       // \n * isPlainObject({ nested: { key: true} });  // \n * isPlainObject(new Proxy({}, {}));         // \n * isPlainObject({ [Symbol('tag')]: 'A' });  // \n *\n * //  (cross-realms, node context, workers, ...)\n * const runInNewContext = await import('node:vm').then(\n *     (mod) => mod.runInNewContext\n * );\n * isPlainObject(runInNewContext('({})'));   // \n *\n * //  False\n *\n * class Test { };\n * isPlainObject(new Test())           // \n * isPlainObject(10);                  // \n * isPlainObject(null);                // \n * isPlainObject('hello');             // \n * isPlainObject([]);                  // \n * isPlainObject(new Date());          // \n * isPlainObject(new Uint8Array([1])); // \n * isPlainObject(Buffer.from('ABC'));  // \n * isPlainObject(Promise.resolve({})); // \n * isPlainObject(Object.create({}));   // \n * isPlainObject(new (class Cls {}));  // \n * isPlainObject(globalThis);          // ,\n * ```\n */\nexport function isPlainObject(value: unknown): value is Record<PropertyKey, any> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value) as typeof Object.prototype | null;\n\n  const hasObjectPrototype =\n    proto === null ||\n    proto === Object.prototype ||\n    // Required to support node:vm.runInNewContext({})\n    Object.getPrototypeOf(proto) === null;\n\n  if (!hasObjectPrototype) {\n    return false;\n  }\n\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n","import { isPlainObject } from './isPlainObject.ts';\nimport { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  bigInt64ArrayTag,\n  bigUint64ArrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  errorTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  functionTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { eq } from '../compat/util/eq.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Compares two values for equality using a custom comparison function.\n *\n * The custom function allows for fine-tuned control over the comparison process. If it returns a boolean, that result determines the equality. If it returns undefined, the function falls back to the default equality comparison.\n *\n * This function also uses the custom equality function to compare values inside objects,\n * arrays, maps, sets, and other complex structures, ensuring a deep comparison.\n *\n * This approach provides flexibility in handling complex comparisons while maintaining efficient default behavior for simpler cases.\n *\n * The custom comparison function can take up to six parameters:\n * - `x`: The value from the first object `a`.\n * - `y`: The value from the second object `b`.\n * - `property`: The property key used to get `x` and `y`.\n * - `xParent`: The parent of the first value `x`.\n * - `yParent`: The parent of the second value `y`.\n * - `stack`: An internal stack (Map) to handle circular references.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @param {(x: any, y: any, property?: PropertyKey, xParent?: any, yParent?: any, stack?: Map<any, any>) => boolean | void} areValuesEqual - A function to customize the comparison.\n *   If it returns a boolean, that result will be used. If it returns undefined,\n *   the default equality comparison will be used.\n * @returns {boolean} `true` if the values are equal according to the customizer, otherwise `false`.\n *\n * @example\n * const customizer = (a, b) => {\n *   if (typeof a === 'string' && typeof b === 'string') {\n *     return a.toLowerCase() === b.toLowerCase();\n *   }\n * };\n * isEqualWith('Hello', 'hello', customizer); // true\n * isEqualWith({ a: 'Hello' }, { a: 'hello' }, customizer); // true\n * isEqualWith([1, 2, 3], [1, 2, 3], customizer); // true\n */\nexport function isEqualWith(\n  a: any,\n  b: any,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n): boolean {\n  return isEqualWithImpl(a, b, undefined, undefined, undefined, undefined, areValuesEqual);\n}\n\nfunction isEqualWithImpl(\n  a: any,\n  b: any,\n  property: PropertyKey | undefined,\n  aParent: any,\n  bParent: any,\n  stack: Map<any, any> | undefined,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n): boolean {\n  const result = areValuesEqual(a, b, property, aParent, bParent, stack);\n\n  if (result !== undefined) {\n    return result;\n  }\n\n  if (typeof a === typeof b) {\n    switch (typeof a) {\n      case 'bigint':\n      case 'string':\n      case 'boolean':\n      case 'symbol':\n      case 'undefined': {\n        return a === b;\n      }\n      case 'number': {\n        return a === b || Object.is(a, b);\n      }\n      case 'function': {\n        return a === b;\n      }\n      case 'object': {\n        return areObjectsEqual(a, b, stack, areValuesEqual);\n      }\n    }\n  }\n\n  return areObjectsEqual(a, b, stack, areValuesEqual);\n}\n\nfunction areObjectsEqual(\n  a: any,\n  b: any,\n  stack: Map<any, any> | undefined,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  let aTag = getTag(a);\n  let bTag = getTag(b);\n\n  if (aTag === argumentsTag) {\n    aTag = objectTag;\n  }\n\n  if (bTag === argumentsTag) {\n    bTag = objectTag;\n  }\n\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case stringTag:\n      return a.toString() === b.toString();\n\n    case numberTag: {\n      const x = a.valueOf();\n      const y = b.valueOf();\n\n      return eq(x, y);\n    }\n\n    case booleanTag:\n    case dateTag:\n    case symbolTag:\n      return Object.is(a.valueOf(), b.valueOf());\n\n    case regexpTag: {\n      return a.source === b.source && a.flags === b.flags;\n    }\n\n    case functionTag: {\n      return a === b;\n    }\n  }\n\n  stack = stack ?? new Map();\n\n  const aStack = stack.get(a);\n  const bStack = stack.get(b);\n\n  if (aStack != null && bStack != null) {\n    return aStack === b;\n  }\n\n  stack.set(a, b);\n  stack.set(b, a);\n\n  try {\n    switch (aTag) {\n      case mapTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        for (const [key, value] of a.entries()) {\n          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case setTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        const aValues = Array.from(a.values());\n        const bValues = Array.from(b.values());\n\n        for (let i = 0; i < aValues.length; i++) {\n          const aValue = aValues[i];\n          const index = bValues.findIndex(bValue => {\n            return isEqualWithImpl(aValue, bValue, undefined, a, b, stack, areValuesEqual);\n          });\n\n          if (index === -1) {\n            return false;\n          }\n\n          bValues.splice(index, 1);\n        }\n\n        return true;\n      }\n\n      case arrayTag:\n      case uint8ArrayTag:\n      case uint8ClampedArrayTag:\n      case uint16ArrayTag:\n      case uint32ArrayTag:\n      case bigUint64ArrayTag:\n      case int8ArrayTag:\n      case int16ArrayTag:\n      case int32ArrayTag:\n      case bigInt64ArrayTag:\n      case float32ArrayTag:\n      case float64ArrayTag: {\n        // Buffers are also treated as [object Uint8Array]s.\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\n          return false;\n        }\n\n        if (a.length !== b.length) {\n          return false;\n        }\n\n        for (let i = 0; i < a.length; i++) {\n          if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case arrayBufferTag: {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n      }\n\n      case dataViewTag: {\n        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n      }\n\n      case errorTag: {\n        return a.name === b.name && a.message === b.message;\n      }\n\n      case objectTag: {\n        const areEqualInstances =\n          areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) ||\n          (isPlainObject(a) && isPlainObject(b));\n\n        if (!areEqualInstances) {\n          return false;\n        }\n\n        const aKeys = [...Object.keys(a), ...getSymbols(a)];\n        const bKeys = [...Object.keys(b), ...getSymbols(b)];\n\n        if (aKeys.length !== bKeys.length) {\n          return false;\n        }\n\n        for (let i = 0; i < aKeys.length; i++) {\n          const propKey = aKeys[i];\n          const aProp = (a as any)[propKey];\n\n          if (!Object.hasOwn(b, propKey)) {\n            return false;\n          }\n\n          const bProp = (b as any)[propKey];\n\n          if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      default: {\n        return false;\n      }\n    }\n  } finally {\n    stack.delete(a);\n    stack.delete(b);\n  }\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\nexport function noop(): void {}\n","import { isEqualWith } from './isEqualWith.ts';\nimport { noop } from '../function/noop.ts';\n\n/**\n * Checks if two values are equal, including support for `Date`, `RegExp`, and deep object comparison.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @returns {boolean} `true` if the values are equal, otherwise `false`.\n *\n * @example\n * isEqual(1, 1); // true\n * isEqual({ a: 1 }, { a: 1 }); // true\n * isEqual(/abc/g, /abc/g); // true\n * isEqual(new Date('2020-01-01'), new Date('2020-01-01')); // true\n * isEqual([1, 2, 3], [1, 2, 3]); // true\n */\nexport function isEqual(a: any, b: any): boolean {\n  return isEqualWith(a, b, noop);\n}\n","/**\n * Checks if `value` is a function.\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n *\n * @example\n * isFunction(Array.prototype.slice); // true\n * isFunction(async function () {}); // true\n * isFunction(function* () {}); // true\n * isFunction(Proxy); // true\n * isFunction(Int8Array); // true\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Checks if the given value is null.\n *\n * This function tests whether the provided value is strictly equal to `null`.\n * It returns `true` if the value is `null`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\n *\n * @param {unknown} x - The value to test if it is null.\n * @returns {x is null} True if the value is null, false otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n *\n * console.log(isNull(value1)); // true\n * console.log(isNull(value2)); // false\n * console.log(isNull(value3)); // false\n */\nexport function isNull(x: unknown): x is null {\n  return x === null;\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n *\n * @example\n * import { isSymbol } from 'es-toolkit/predicate';\n *\n * isSymbol(Symbol('a')); // true\n * isSymbol(Symbol.for('a')); // true\n * isSymbol(Symbol.iterator); // true\n *\n * isSymbol(null); // false\n * isSymbol(undefined); // false\n * isSymbol('123'); // false\n * isSymbol(false); // false\n * isSymbol(123n); // false\n * isSymbol({}); // false\n * isSymbol([1, 2, 3]); // false\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === 'symbol';\n}\n","/**\n * Checks if the given value is undefined.\n *\n * This function tests whether the provided value is strictly equal to `undefined`.\n * It returns `true` if the value is `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\n *\n * @param {unknown} x - The value to test if it is undefined.\n * @returns {x is undefined} true if the value is undefined, false otherwise.\n *\n * @example\n * const value1 = undefined;\n * const value2 = null;\n * const value3 = 42;\n *\n * console.log(isUndefined(value1)); // true\n * console.log(isUndefined(value2)); // false\n * console.log(isUndefined(value3)); // false\n */\nexport function isUndefined(x: any): x is undefined {\n  return x === undefined;\n}\n","import { isFunction, isNil } from '../../predicate/index.ts';\nimport { get } from '../object/get.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Invokes the method at path of each element in collection.\n *\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {string} methodName - The name of the method to invoke.\n * @param {...any[]} args - The arguments to invoke each method with.\n * @returns {any[]} Returns the array of results.\n *\n * @example\n * invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n * // => [[1, 5, 7], [1, 2, 3]]\n *\n * invokeMap([123, 456], 'toString', 2);\n * // => ['1111011', '111001000']\n */\nexport function invokeMap(collection: object | null | undefined, methodName: string, ...args: any[]): any[];\n\n/**\n * Invokes the method at path of each element in collection.\n *\n * @template R\n * @param {object | null | undefined} collection - The collection to iterate over.\n * @param {(...args: any[]) => R} method - The method to invoke.\n * @param {...any[]} args - The arguments to invoke each method with.\n * @returns {R[]} Returns the array of results.\n *\n * @example\n * invokeMap([5, 1, 7], Array.prototype.slice, 1);\n * // => [[], [], []]\n */\nexport function invokeMap<R>(collection: object | null | undefined, method: (...args: any[]) => R, ...args: any[]): R[];\n\n/**\n * Invokes the method at path of each element in collection.\n *\n * @template T, R\n * @param {ArrayLike<T> | Record<string, T> | null | undefined} collection - The collection to iterate over.\n * @param {string | ((...args: any[]) => R)} path - The path of the method to invoke or the method to invoke.\n * @param {...any[]} args - The arguments to invoke each method with.\n * @returns {Array<R | undefined>} Returns the array of results.\n *\n * @example\n * invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n * // => [[1, 5, 7], [1, 2, 3]]\n */\nexport function invokeMap<T, R>(\n  collection: ArrayLike<T> | Record<string, T> | null | undefined,\n  path: string | ((...args: any[]) => R),\n  ...args: any[]\n): Array<R | undefined> {\n  if (isNil(collection)) {\n    return [];\n  }\n\n  const values = isArrayLike(collection) ? (Array.from(collection) as T[]) : (Object.values(collection) as T[]);\n  const result: Array<R | undefined> = [];\n\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n\n    if (isFunction(path)) {\n      result.push(path.apply(value, args));\n      continue;\n    }\n\n    const method = get(value, path);\n\n    let thisContext = value;\n\n    if (Array.isArray(path)) {\n      const pathExceptLast = path.slice(0, -1);\n      if (pathExceptLast.length > 0) {\n        thisContext = get(value, pathExceptLast);\n      }\n    } else if (typeof path === 'string' && path.includes('.')) {\n      const parts = path.split('.');\n      const pathExceptLast = parts.slice(0, -1).join('.');\n      thisContext = get(value, pathExceptLast);\n    }\n\n    result.push(method == null ? undefined : method.apply(thisContext, args));\n  }\n\n  return result;\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Joins elements of an array into a string.\n *\n * @param {ArrayLike<any> | null | undefined} array - The array to join.\n * @param {string} [separator=','] - The separator used to join the elements, default is common separator `,`.\n * @returns {string} - Returns a string containing all elements of the array joined by the specified separator.\n *\n * @example\n * const arr = [\"a\", \"b\", \"c\"];\n * const result = join(arr, \"~\");\n * console.log(result); // Output: \"a~b~c\"\n */\nexport function join(array: ArrayLike<any> | null | undefined, separator?: string): string {\n  if (!isArrayLike(array)) {\n    return '';\n  }\n  return Array.from(array).join(separator);\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { MemoListIterator } from '../_internal/MemoListIterator.ts';\nimport { MemoObjectIterator } from '../_internal/MemoObjectIterator.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Reduces an array to a single value using an iteratee function.\n *\n * @param {T[] | null | undefined} collection - The array to iterate over\n * @param {MemoListIterator<T, U, T[]>} callback - The function invoked per iteration\n * @param {U} accumulator - The initial value\n * @returns {U} Returns the accumulated value\n *\n * @example\n * const array = [1, 2, 3];\n * reduce(array, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduce<T, U>(\n  collection: T[] | null | undefined,\n  callback: MemoListIterator<T, U, T[]>,\n  accumulator: U\n): U;\n\n/**\n * Reduces an array-like object to a single value using an iteratee function.\n *\n * @param {ArrayLike<T> | null | undefined} collection - The array-like object to iterate over\n * @param {MemoListIterator<T, U, ArrayLike<T>>} callback - The function invoked per iteration\n * @param {U} accumulator - The initial value\n * @returns {U} Returns the accumulated value\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * reduce(arrayLike, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduce<T, U>(\n  collection: ArrayLike<T> | null | undefined,\n  callback: MemoListIterator<T, U, ArrayLike<T>>,\n  accumulator: U\n): U;\n\n/**\n * Reduces an object to a single value using an iteratee function.\n *\n * @param {T | null | undefined} collection - The object to iterate over\n * @param {MemoObjectIterator<T[keyof T], U, T>} callback - The function invoked per iteration\n * @param {U} accumulator - The initial value\n * @returns {U} Returns the accumulated value\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * reduce(obj, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduce<T extends object, U>(\n  collection: T | null | undefined,\n  callback: MemoObjectIterator<T[keyof T], U, T>,\n  accumulator: U\n): U;\n\n/**\n * Reduces an array to a single value using an iteratee function.\n *\n * @param {T[] | null | undefined} collection - The array to iterate over\n * @param {MemoListIterator<T, T, T[]>} callback - The function invoked per iteration\n * @returns {T | undefined} Returns the accumulated value\n *\n * @example\n * const array = [1, 2, 3];\n * reduce(array, (acc, value) => acc + value); // => 6\n */\nexport function reduce<T>(collection: T[] | null | undefined, callback: MemoListIterator<T, T, T[]>): T | undefined;\n\n/**\n * Reduces an array-like object to a single value using an iteratee function.\n *\n * @param {ArrayLike<T> | null | undefined} collection - The array-like object to iterate over\n * @param {MemoListIterator<T, T, ArrayLike<T>>} callback - The function invoked per iteration\n * @returns {T | undefined} Returns the accumulated value\n *\n * @example\n * const arrayLike = {0: 1, 1: 2, 2: 3, length: 3};\n * reduce(arrayLike, (acc, value) => acc + value); // => 6\n */\nexport function reduce<T>(\n  collection: ArrayLike<T> | null | undefined,\n  callback: MemoListIterator<T, T, ArrayLike<T>>\n): T | undefined;\n\n/**\n * Reduces an object to a single value using an iteratee function.\n *\n * @param {T | null | undefined} collection - The object to iterate over\n * @param {MemoObjectIterator<T[keyof T], T[keyof T], T>} callback - The function invoked per iteration\n * @returns {T[keyof T] | undefined} Returns the accumulated value\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * reduce(obj, (acc, value) => acc + value); // => 6\n */\nexport function reduce<T extends object>(\n  collection: T | null | undefined,\n  callback: MemoObjectIterator<T[keyof T], T[keyof T], T>\n): T[keyof T] | undefined;\n\n/**\n * Reduces a collection to a single value using an iteratee function.\n *\n * @param {T[] | ArrayLike<T> | Record<string, T> | null | undefined} collection - The collection to iterate over.\n * @param {((accumulator: any, value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object} iteratee - The function invoked per iteration or the key to reduce over.\n * @param {any} initialValue - The initial value.\n * @returns {any} - Returns the accumulated value.\n *\n * @example\n * // Using a reducer function\n * const array = [1, 2, 3];\n * reduce(array, (acc, value) => acc + value, 0); // => 6\n *\n * @example\n * // Using a reducer function with initialValue\n * const array = [1, 2, 3];\n * reduce(array, (acc, value) => acc + value % 2 === 0, true); // => false\n *\n * @example\n * // Using an object as the collection\n * const obj = { a: 1, b: 2, c: 3 };\n * reduce(obj, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduce(\n  collection: ArrayLike<any> | Record<any, any> | null | undefined,\n  iteratee: (accumulator: any, value: any, index: any, collection: any) => any = identity,\n  accumulator?: any\n): any {\n  if (!collection) {\n    return accumulator;\n  }\n\n  let keys: any[];\n  let startIndex = 0;\n\n  if (isArrayLike(collection)) {\n    keys = range(0, collection.length);\n\n    if (accumulator == null && collection.length > 0) {\n      accumulator = (collection as ArrayLike<any>)[0];\n      startIndex += 1;\n    }\n  } else {\n    keys = Object.keys(collection);\n\n    if (accumulator == null) {\n      accumulator = (collection as any)[keys[0]];\n      startIndex += 1;\n    }\n  }\n\n  for (let i = startIndex; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    accumulator = iteratee(accumulator, value, key, collection);\n  }\n\n  return accumulator;\n}\n","import { reduce } from './reduce.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIterateeCustom } from '../_internal/ValueIterateeCustom.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates an object composed of keys generated from the results of running each element of collection thru iteratee.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {ValueIterateeCustom<T, PropertyKey>} [iteratee] - The iteratee to transform keys.\n * @returns {Record<string, T>} Returns the composed aggregate object.\n *\n * @example\n * const array = [\n *   { dir: 'left', code: 97 },\n *   { dir: 'right', code: 100 }\n * ];\n *\n * keyBy(array, o => String.fromCharCode(o.code));\n * // => { a: { dir: 'left', code: 97 }, d: { dir: 'right', code: 100 } }\n *\n * keyBy(array, 'dir');\n * // => { left: { dir: 'left', code: 97 }, right: { dir: 'right', code: 100 } }\n */\nexport function keyBy<T>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIterateeCustom<T, PropertyKey>\n): Record<string, T>;\n\n/**\n * Creates an object composed of keys generated from the results of running each element of collection thru iteratee.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ValueIterateeCustom<T[keyof T], PropertyKey>} [iteratee] - The iteratee to transform keys.\n * @returns {Record<string, T[keyof T]>} Returns the composed aggregate object.\n *\n * @example\n * const obj = { a: { dir: 'left', code: 97 }, b: { dir: 'right', code: 100 } };\n * keyBy(obj, o => String.fromCharCode(o.code));\n * // => { a: { dir: 'left', code: 97 }, d: { dir: 'right', code: 100 } }\n */\nexport function keyBy<T extends object>(\n  collection: T | null | undefined,\n  iteratee?: ValueIterateeCustom<T[keyof T], PropertyKey>\n): Record<string, T[keyof T]>;\n\n/**\n * Maps each element of an array or an object based on a provided key-generating function.\n *\n * This function takes an array or object and a function that generates a key from each element or value. It returns\n * an object where the keys are the generated keys and the values are the corresponding elements or values.\n * If there are multiple elements or values generating the same key, the last one among them is used\n * as the value.\n *\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {Function | PropertyKey | Array | Object} [iteratee] - The iteratee to transform keys.\n *   - If a function is provided, it's invoked for each element in the collection.\n *   - If a property name (string) is provided, that property of each element is used as the key.\n *   - If a property-value pair (array) is provided, elements with matching property values are used.\n *   - If a partial object is provided, elements with matching properties are used.\n *   - If omitted, the identity function is used.\n * @returns {Object} Returns the composed aggregate object.\n *\n * @example\n * // Using an array of objects\n * keyBy([{ id: 'a' }, { id: 'b' }], 'id');\n * // => { a: { id: 'a' }, b: { id: 'b' } }\n *\n * @example\n * // Using a function iteratee\n * keyBy(['a', 'b', 'c'], val => val.toUpperCase());\n * // => { A: 'a', B: 'b', C: 'c' }\n */\nexport function keyBy<T>(\n  collection: unknown,\n  iteratee?: ((value: T) => unknown) | PropertyKey | [keyof T, unknown] | Partial<T> | null\n): Record<string, T> {\n  if (!isArrayLike(collection) && !isObjectLike(collection)) {\n    return {};\n  }\n\n  const keyFn = createIteratee(iteratee ?? identity);\n\n  return reduce(\n    collection as ArrayLike<T>,\n    (result, value) => {\n      const key = keyFn(value);\n      result[key] = value;\n      return result;\n    },\n    {} as Record<string, T>\n  );\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Gets the index at which the last occurrence of value is found in array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to inspect.\n * @param {T} value - The value to search for.\n * @param {true | number} [fromIndex] - The index to search from or true to search from the end.\n * @returns {number} Returns the index of the matched value, else -1.\n *\n * @example\n * lastIndexOf([1, 2, 1, 2], 2);\n * // => 3\n *\n * lastIndexOf([1, 2, 1, 2], 2, 2);\n * // => 1\n *\n * lastIndexOf([1, 2, 1, 2], 2, true);\n * // => 3\n */\nexport function lastIndexOf<T>(\n  array: ArrayLike<T> | null | undefined,\n  searchElement: T,\n  fromIndex?: true | number\n): number;\n\nexport function lastIndexOf<T>(\n  array: ArrayLike<T> | null | undefined,\n  searchElement: T,\n  fromIndex?: true | number\n): number {\n  if (!isArrayLike(array) || array.length === 0) {\n    return -1;\n  }\n\n  const length = array.length;\n\n  let index = (fromIndex as number) ?? length - 1;\n  if (fromIndex != null) {\n    index = index < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n\n  // `Array.prototype.lastIndexOf` doesn't find `NaN` values, so we need to handle that case separately.\n  if (Number.isNaN(searchElement)) {\n    for (let i = index; i >= 0; i--) {\n      if (Number.isNaN(array[i])) {\n        return i;\n      }\n    }\n  }\n\n  return Array.from(array).lastIndexOf(searchElement, index);\n}\n","import { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.\n *\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {number} [n=0] - The index of the element to return.\n * @return {T | undefined} Returns the nth element of `array`.\n *\n * @example\n * nth([1, 2, 3], 1); // => 2\n * nth([1, 2, 3], -1); // => 3\n */\nexport function nth<T>(array: ArrayLike<T> | null | undefined, n = 0): T | undefined {\n  if (!isArrayLikeObject(array) || array.length === 0) {\n    return undefined;\n  }\n\n  n = toInteger(n);\n\n  if (n < 0) {\n    n += array.length;\n  }\n\n  return array[n];\n}\n","function getPriority(a: unknown): 0 | 1 | 2 | 3 | 4 {\n  if (typeof a === 'symbol') {\n    return 1;\n  }\n\n  if (a === null) {\n    return 2;\n  }\n\n  if (a === undefined) {\n    return 3;\n  }\n\n  if (a !== a) {\n    return 4;\n  }\n\n  return 0;\n}\n\nexport const compareValues = <V>(a: V, b: V, order: string) => {\n  if (a !== b) {\n    const aPriority = getPriority(a);\n    const bPriority = getPriority(b);\n\n    // If both values are of the same priority and are normal values, compare them.\n    if (aPriority === bPriority && aPriority === 0) {\n      if (a < b) {\n        return order === 'desc' ? 1 : -1;\n      }\n\n      if (a > b) {\n        return order === 'desc' ? -1 : 1;\n      }\n    }\n\n    return order === 'desc' ? bPriority - aPriority : aPriority - bPriority;\n  }\n\n  return 0;\n};\n","import { isSymbol } from '../predicate/isSymbol.ts';\n\n/**  Matches any deep property path. (e.g. `a.b[0].c`)*/\nconst regexIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n/**  Matches any word character (alphanumeric & underscore).*/\nconst regexIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path. (It's ok that the `value` is not in the keys of the `object`)\n * @param {unknown} value The value to check.\n * @param {unknown} object The object to query.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n *\n * @example\n * isKey('a', { a: 1 });\n * // => true\n *\n * isKey('a.b', { a: { b: 2 } });\n * // => false\n */\nexport function isKey(value?: unknown, object?: unknown): value is PropertyKey {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n\n  return (\n    (typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||\n    (object != null && Object.hasOwn(object, value as PropertyKey))\n  );\n}\n","import { compareValues } from '../_internal/compareValues.ts';\nimport { isKey } from '../_internal/isKey.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { ListIterator } from '../_internal/ListIterator.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { ObjectIteratee } from '../_internal/ObjectIteratee.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\nimport { toPath } from '../util/toPath.ts';\n\nexport type Criterion<T> = ((item: T) => unknown) | PropertyKey | PropertyKey[] | null | undefined;\n\n/**\n * Sorts an array of elements based on multiple iteratee functions and their corresponding order directions.\n *\n * @template T The type of elements in the array\n * @param {ArrayLike<T> | null | undefined} collection The array to sort\n * @param {Many<ListIterator<T, unknown>>} iteratees The iteratee functions to sort by\n * @param {Many<boolean | 'asc' | 'desc'>} orders The sort orders\n * @returns {T[]} Returns the new sorted array\n * @example\n * const users = [\n *   { name: 'fred', age: 48 },\n *   { name: 'barney', age: 34 }\n * ];\n *\n * // Sort by age in ascending order\n * orderBy(users, [(user) => user.age], ['asc']);\n * // => [{ name: 'barney', age: 34 }, { name: 'fred', age: 48 }]\n */\nexport function orderBy<T>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratees?: Many<ListIterator<T, unknown>>,\n  orders?: Many<boolean | 'asc' | 'desc'>\n): T[];\n\n/**\n * Sorts an array of elements based on multiple property names/paths and their corresponding order directions.\n *\n * @template T The type of elements in the array\n * @param {ArrayLike<T> | null | undefined} collection The array to sort\n * @param {Many<ListIteratee<T>>} iteratees The property names/paths to sort by\n * @param {Many<boolean | 'asc' | 'desc'>} orders The sort orders\n * @returns {T[]} Returns the new sorted array\n * @example\n * const users = [\n *   { name: 'fred', age: 48 },\n *   { name: 'barney', age: 34 }\n * ];\n *\n * // Sort by name in ascending order\n * orderBy(users, ['name'], ['asc']);\n * // => [{ name: 'barney', age: 34 }, { name: 'fred', age: 48 }]\n */\nexport function orderBy<T>(\n  collection: ArrayLike<T> | null | undefined,\n  iteratees?: Many<ListIteratee<T>>,\n  orders?: Many<boolean | 'asc' | 'desc'>\n): T[];\n\n/**\n * Sorts an object's values based on multiple iteratee functions and their corresponding order directions.\n *\n * @template T The object type\n * @param {T | null | undefined} collection The object to sort values from\n * @param {Many<ObjectIterator<T, unknown>>} iteratees The iteratee functions to sort by\n * @param {Many<boolean | 'asc' | 'desc'>} orders The sort orders\n * @returns {Array<T[keyof T]>} Returns the new sorted array\n * @example\n * const obj = {\n *   a: { name: 'fred', age: 48 },\n *   b: { name: 'barney', age: 34 }\n * };\n *\n * // Sort by age in ascending order\n * orderBy(obj, [(user) => user.age], ['asc']);\n * // => [{ name: 'barney', age: 34 }, { name: 'fred', age: 48 }]\n */\nexport function orderBy<T extends object>(\n  collection: T | null | undefined,\n  iteratees?: Many<ObjectIterator<T, unknown>>,\n  orders?: Many<boolean | 'asc' | 'desc'>\n): Array<T[keyof T]>;\n\n/**\n * Sorts an object's values based on multiple property names/paths and their corresponding order directions.\n *\n * @template T The object type\n * @param {T | null | undefined} collection The object to sort values from\n * @param {Many<ObjectIteratee<T>>} iteratees The property names/paths to sort by\n * @param {Many<boolean | 'asc' | 'desc'>} orders The sort orders\n * @returns {Array<T[keyof T]>} Returns the new sorted array\n * @example\n * const obj = {\n *   a: { name: 'fred', age: 48 },\n *   b: { name: 'barney', age: 34 }\n * };\n *\n * // Sort by name in ascending order\n * orderBy(obj, ['name'], ['asc']);\n * // => [{ name: 'barney', age: 34 }, { name: 'fred', age: 48 }]\n */\nexport function orderBy<T extends object>(\n  collection: T | null | undefined,\n  iteratees?: Many<ObjectIteratee<T>>,\n  orders?: Many<boolean | 'asc' | 'desc'>\n): Array<T[keyof T]>;\n\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of criteria to sort by, and an array of order directions.\n * It returns the sorted array, ordering by each key according to its corresponding direction ('asc' for ascending or 'desc' for descending).\n * If values for a key are equal, it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | object | null | undefined} collection - The array of objects to be sorted.\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\n * @param {unknown | unknown[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\n * @param {unknown} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {T[]} - The sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = orderBy(users, ['user', (item) => item.age], ['asc', 'desc']);\n * // result will be:\n * // [\n * //   { user: 'barney', age: 36 },\n * //   { user: 'barney', age: 34 },\n * //   { user: 'fred', age: 48 },\n * //   { user: 'fred', age: 40 },\n * // ]\n */\nexport function orderBy<T = any>(collection: any, criteria?: any, orders?: any, guard?: unknown): T[] {\n  if (collection == null) {\n    return [];\n  }\n\n  orders = guard ? undefined : orders;\n\n  if (!Array.isArray(collection)) {\n    collection = Object.values(collection);\n  }\n\n  if (!Array.isArray(criteria)) {\n    criteria = criteria == null ? [null] : [criteria];\n  }\n  if (criteria.length === 0) {\n    criteria = [null];\n  }\n\n  if (!Array.isArray(orders)) {\n    orders = orders == null ? [] : [orders];\n  }\n\n  // For Object('desc') case\n  orders = (orders as unknown[]).map(order => String(order));\n\n  const getValueByNestedPath = (object: object, path: PropertyKey[]) => {\n    let target: object = object;\n\n    for (let i = 0; i < path.length && target != null; ++i) {\n      target = target[path[i] as keyof typeof target];\n    }\n\n    return target;\n  };\n\n  const getValueByCriterion = (criterion: Criterion<T> | { key: PropertyKey; path: string[] }, object: T) => {\n    if (object == null || criterion == null) {\n      return object;\n    }\n\n    if (typeof criterion === 'object' && 'key' in criterion) {\n      if (Object.hasOwn(object, criterion.key)) {\n        return object[criterion.key as keyof typeof object];\n      }\n\n      return getValueByNestedPath(object, criterion.path);\n    }\n\n    if (typeof criterion === 'function') {\n      return criterion(object);\n    }\n\n    if (Array.isArray(criterion)) {\n      return getValueByNestedPath(object, criterion);\n    }\n\n    if (typeof object === 'object') {\n      return object[criterion as keyof typeof object];\n    }\n\n    return object;\n  };\n\n  // Prepare all cases for criteria\n  const preparedCriteria = criteria.map((criterion: any) => {\n    // lodash handles a array with one element as a single criterion\n    if (Array.isArray(criterion) && criterion.length === 1) {\n      criterion = criterion[0];\n    }\n\n    if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey(criterion)) {\n      return criterion;\n    }\n\n    // If criterion is not key, it has possibility to be a deep path. So we have to prepare both cases.\n    return { key: criterion, path: toPath(criterion) };\n  });\n\n  // Array.prototype.sort() always shifts the `undefined` values to the end of the array. So we have to prevent it by using a wrapper object.\n  const preparedCollection = (collection as T[]).map(item => ({\n    original: item,\n    criteria: preparedCriteria.map((criterion: any) => getValueByCriterion(criterion, item)),\n  }));\n\n  return preparedCollection\n    .slice()\n    .sort((a, b) => {\n      for (let i = 0; i < preparedCriteria.length; i++) {\n        const comparedResult = compareValues(a.criteria[i], b.criteria[i], (orders as string[])[i]);\n\n        if (comparedResult !== 0) {\n          return comparedResult;\n        }\n      }\n\n      return 0;\n    })\n    .map(item => item.original);\n}\n","import { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { ValueIteratorTypeGuard } from '../_internal/ValueIteratorTypeGuard.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Creates an array of elements split into two groups, the first of which contains elements\n * predicate returns truthy for, while the second of which contains elements predicate returns falsey for.\n * The predicate is invoked with one argument: (value).\n *\n * @template T, U\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {(value: T) => value is U} callback - The function invoked per iteration.\n * @returns {[U[], Array<Exclude<T, U>>]} Returns the array of grouped elements.\n *\n * @example\n * partition([1, 2, 3, 4], n => n % 2 === 0);\n * // => [[2, 4], [1, 3]]\n */\nexport function partition<T, U extends T>(\n  collection: ArrayLike<T> | null | undefined,\n  callback: ValueIteratorTypeGuard<T, U>\n): [U[], Array<Exclude<T, U>>];\n\n/**\n * Creates an array of elements split into two groups, the first of which contains elements\n * predicate returns truthy for, while the second of which contains elements predicate returns falsey for.\n * The predicate is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {((value: T) => unknown) | PropertyKey | [PropertyKey, any] | Partial<T>} callback - The function invoked per iteration.\n * @returns {[T[], T[]]} Returns the array of grouped elements.\n *\n * @example\n * partition([1, 2, 3, 4], n => n % 2 === 0);\n * // => [[2, 4], [1, 3]]\n */\nexport function partition<T>(collection: ArrayLike<T> | null | undefined, callback: ValueIteratee<T>): [T[], T[]];\n\n/**\n * Creates an array of elements split into two groups, the first of which contains elements\n * predicate returns truthy for, while the second of which contains elements predicate returns falsey for.\n * The predicate is invoked with one argument: (value).\n *\n * @template T\n * @param {T | null | undefined} collection - The collection to iterate over.\n * @param {((value: T[keyof T]) => unknown) | PropertyKey | [PropertyKey, any] | Partial<T[keyof T]>} callback - The function invoked per iteration.\n * @returns {[Array<T[keyof T]>, Array<T[keyof T]>]} Returns the array of grouped elements.\n *\n * @example\n * partition({ a: 1, b: 2, c: 3 }, n => n % 2 === 0);\n * // => [[2], [1, 3]]\n */\nexport function partition<T extends object>(\n  collection: T | null | undefined,\n  callback: ValueIteratee<T[keyof T]>\n): [Array<T[keyof T]>, Array<T[keyof T]>];\n\n/**\n * Creates an array of elements split into two groups, the first of which contains elements\n * `predicate` returns truthy for, the second of which contains elements\n * `predicate` returns falsy for. The predicate is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | T | null | undefined} source - The array or object to iterate over.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate=identity] - The function invoked per iteration.\n * @returns {[T[], T[]]} - Returns the array of grouped elements.\n *\n * @example\n * partition([{ a: 1 }, { a: 2 }, { b: 1 }], 'a');\n * // => [[{ a: 1 }, { a: 2 }], [{ b: 1 }]]\n *\n * partition([{ a: 1 }, { a: 2 }, { b: 1 }], { b: 1 });\n * // => [[{ b: 1 }], [{ a: 1 }, { a: 2 }]]\n *\n * partition({ item1: { a: 0, b: true }, item2: { a: 1, b: true }, item3: { a: 2, b: false }}, { b: false })\n * // => [[{ a: 2, b: false }], [{ a: 0, b: true }, { a: 1, b: true }]]\n *\n * partition([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => [[{ a: 2 }], [{ a: 1 }, { a: 3 }]]\n */\nexport function partition<T>(\n  source: ArrayLike<T> | T | null | undefined,\n  predicate: ((value: T) => unknown) | Partial<T> | [PropertyKey, any] | PropertyKey = identity\n): [T[], T[]] {\n  if (!source) {\n    return [[], []];\n  }\n\n  const collection = isArrayLike(source) ? source : Object.values(source);\n\n  predicate = iteratee(predicate);\n\n  const matched: T[] = [];\n  const unmatched: T[] = [];\n\n  for (let i = 0; i < collection.length; i++) {\n    const value = collection[i] as T;\n\n    if (predicate(value)) {\n      matched.push(value);\n    } else {\n      unmatched.push(value);\n    }\n  }\n\n  return [matched, unmatched];\n}\n","/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T, U\n * @param {T[]} arr - The array to modify.\n * @param {unknown[]} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pull(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pull<T>(arr: T[], valuesToRemove: readonly unknown[]): T[] {\n  const valuesSet = new Set(valuesToRemove);\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (valuesSet.has(arr[i])) {\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return arr;\n}\n","import { pull as pullToolkit } from '../../array/pull.ts';\n\n/**\n * Removes all provided values from array using SameValueZero for equality comparisons.\n *\n * **Note:** Unlike `_.without`, this method mutates `array`.\n *\n * @template T\n * @param {T[]} array - The array to modify.\n * @param {...T[]} values - The values to remove.\n * @returns {T[]} Returns `array`.\n *\n * @example\n * var array = [1, 2, 3, 1, 2, 3];\n *\n * pull(array, 2, 3);\n * console.log(array);\n * // => [1, 1]\n */\nexport function pull<T>(array: T[], ...values: T[]): T[];\n\n/**\n * Removes all provided values from array using SameValueZero for equality comparisons.\n *\n * **Note:** Unlike `_.without`, this method mutates `array`.\n *\n * @template L\n * @param {L} array - The array to modify.\n * @param {...L[0][]} values - The values to remove.\n * @returns {L} Returns `array`.\n *\n * @example\n * var array = [1, 2, 3, 1, 2, 3];\n *\n * pull(array, 2, 3);\n * console.log(array);\n * // => [1, 1]\n */\nexport function pull<L extends ArrayLike<any>>(array: L extends readonly any[] ? never : L, ...values: Array<L[0]>): L;\n\n/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T, U\n * @param {T[]} arr - The array to modify.\n * @param {...unknown[]} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pull(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pull<T>(arr: T[], ...valuesToRemove: readonly unknown[]): T[] {\n  return pullToolkit(arr, valuesToRemove);\n}\n","import { pull as pullToolkit } from '../../array/pull.ts';\n\n/**\n * This method is like `_.pull` except that it accepts an array of values to remove.\n *\n * **Note:** Unlike `_.difference`, this method mutates `array`.\n *\n * @template T\n * @param {T[]} array - The array to modify.\n * @param {ArrayLike<T>} [values] - The values to remove.\n * @returns {T[]} Returns `array`.\n *\n * @example\n * var array = [1, 2, 3, 1, 2, 3];\n *\n * pullAll(array, [2, 3]);\n * console.log(array);\n * // => [1, 1]\n */\nexport function pullAll<T>(array: T[], values?: ArrayLike<T>): T[];\n\n/**\n * This method is like `_.pull` except that it accepts an array of values to remove.\n *\n * **Note:** Unlike `_.difference`, this method mutates `array`.\n *\n * @template L\n * @param {L} array - The array to modify.\n * @param {ArrayLike<L[0]>} [values] - The values to remove.\n * @returns {L} Returns `array`.\n *\n * @example\n * var array = [1, 2, 3, 1, 2, 3];\n *\n * pullAll(array, [2, 3]);\n * console.log(array);\n * // => [1, 1]\n */\nexport function pullAll<L extends ArrayLike<any>>(\n  array: L extends readonly any[] ? never : L,\n  values?: ArrayLike<L[0]>\n): L;\n\n/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pullAll(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pullAll<T>(arr: T[], valuesToRemove: ArrayLike<T> = []): T[] {\n  return pullToolkit(arr, Array.from(valuesToRemove));\n}\n","import { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} array - The array to modify.\n * @param {ArrayLike<T>} [values] - The values to remove.\n * @param {((value: T) => unknown) | PropertyKey | [PropertyKey, any] | Partial<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n *\n * pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n * console.log(array);\n * // => [{ 'x': 2 }]\n */\nexport function pullAllBy<T>(array: T[], values?: ArrayLike<T>, iteratee?: ValueIteratee<T>): T[];\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template L\n * @param {L} array - The array to modify.\n * @param {ArrayLike<L[0]>} [values] - The values to remove.\n * @param {((value: L[0]) => unknown) | PropertyKey | [PropertyKey, any] | Partial<L[0]>} [iteratee] - The iteratee invoked per element.\n * @returns {L} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n *\n * pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n * console.log(array);\n * // => [{ 'x': 2 }]\n */\nexport function pullAllBy<L extends ArrayLike<any>>(\n  array: L extends readonly any[] ? never : L,\n  values?: ArrayLike<L[0]>,\n  iteratee?: ValueIteratee<L[0]>\n): L;\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T, U\n * @param {T[]} array - The array to modify.\n * @param {ArrayLike<U>} values - The values to remove.\n * @param {((value: T | U) => unknown) | PropertyKey | [PropertyKey, any] | Partial<T | U>} iteratee - The iteratee invoked per element.\n * @returns {T[]} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n *\n * pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n * console.log(array);\n * // => [{ 'x': 2 }]\n */\nexport function pullAllBy<T, U>(array: T[], values: ArrayLike<U>, iteratee: ValueIteratee<T | U>): T[];\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template L, U\n * @param {L} array - The array to modify.\n * @param {ArrayLike<U>} values - The values to remove.\n * @param {((value: L[0] | U) => unknown) | PropertyKey | [PropertyKey, any] | Partial<L[0] | U>} iteratee - The iteratee invoked per element.\n * @returns {L} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n *\n * pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n * console.log(array);\n * // => [{ 'x': 2 }]\n */\nexport function pullAllBy<L extends ArrayLike<any>, U>(\n  array: L extends readonly any[] ? never : L,\n  values: ArrayLike<U>,\n  iteratee: ValueIteratee<L[0] | U>\n): L;\n\n/**\n * Removes all specified values from an array using an iteratee function.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `differenceBy`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {ArrayLike<T>} valuesToRemove - The values to remove from the array.\n * @param {keyof T} getValue - The key of the property to match against each element.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * // Using a iteratee function\n * const items = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 1 }];\n * const result = pullAllBy(items, [{ value: 1 }, { value: 3 }], obj => obj.value);\n * console.log(result); // [{ value: 2 }]\n *\n * // Using a property name\n * const items = [{ value: 1 }, { value: 2 }, { value: 3 }, { value: 1 }];\n * const result = pullAllBy(items, [{ value: 1 }, { value: 3 }], 'value');\n * console.log(result); // [{ value: 2 }]\n */\nexport function pullAllBy(arr: any, valuesToRemove: any, _getValue: any): any {\n  const getValue = iteratee(_getValue);\n  const valuesSet = new Set(Array.from(valuesToRemove).map(x => getValue(x)));\n\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    const value = getValue(arr[i]);\n\n    if (valuesSet.has(value)) {\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return arr;\n}\n","import copyArray from '../_internal/copyArray.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * This method is like `_.pullAll` except that it accepts `comparator` which is\n * invoked to compare elements of array to values. The comparator is invoked with\n * two arguments: (arrVal, othVal).\n *\n * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n *\n * @template T\n * @param {T[]} array - The array to modify.\n * @param {ArrayLike<T>} [values] - The values to remove.\n * @param {(a: T, b: T) => boolean} [comparator] - The comparator invoked per element.\n * @returns {T[]} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n *\n * pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n * console.log(array);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n */\nexport function pullAllWith<T>(array: T[], values?: ArrayLike<T>, comparator?: (a: T, b: T) => boolean): T[];\n\n/**\n * This method is like `_.pullAll` except that it accepts `comparator` which is\n * invoked to compare elements of array to values. The comparator is invoked with\n * two arguments: (arrVal, othVal).\n *\n * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n *\n * @template L\n * @param {L} array - The array to modify.\n * @param {ArrayLike<L[0]>} [values] - The values to remove.\n * @param {(a: L[0], b: L[0]) => boolean} [comparator] - The comparator invoked per element.\n * @returns {L} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n *\n * pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n * console.log(array);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n */\nexport function pullAllWith<L extends ArrayLike<any>>(\n  array: L extends readonly any[] ? never : L,\n  values?: ArrayLike<L[0]>,\n  comparator?: (a: L[0], b: L[0]) => boolean\n): L;\n\n/**\n * This method is like `_.pullAll` except that it accepts `comparator` which is\n * invoked to compare elements of array to values. The comparator is invoked with\n * two arguments: (arrVal, othVal).\n *\n * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n *\n * @template T, U\n * @param {T[]} array - The array to modify.\n * @param {ArrayLike<U>} values - The values to remove.\n * @param {(a: T, b: U) => boolean} comparator - The comparator invoked per element.\n * @returns {T[]} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n *\n * pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n * console.log(array);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n */\nexport function pullAllWith<T, U>(array: T[], values: ArrayLike<U>, comparator: (a: T, b: U) => boolean): T[];\n\n/**\n * This method is like `_.pullAll` except that it accepts `comparator` which is\n * invoked to compare elements of array to values. The comparator is invoked with\n * two arguments: (arrVal, othVal).\n *\n * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n *\n * @template L, U\n * @param {L} array - The array to modify.\n * @param {ArrayLike<U>} values - The values to remove.\n * @param {(a: L[0], b: U) => boolean} comparator - The comparator invoked per element.\n * @returns {L} Returns `array`.\n *\n * @example\n * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n *\n * pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n * console.log(array);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n */\nexport function pullAllWith<L extends ArrayLike<any>, U>(\n  array: L extends readonly any[] ? never : L,\n  values: ArrayLike<U>,\n  comparator: (a: L[0], b: U) => boolean\n): L;\n\n/**\n * Removes and returns elements from an array using a provided comparison function to determine which elements to remove.\n *\n * @template T\n * @param {T[] | ArrayLike<T>} array - The array to modify.\n * @param {T[] | ArrayLike<T>} values - The values to remove from the array.\n * @param {(a: T, b: T) => boolean} comparator - The function to compare elements of `array` with elements of `values`. Should return `true` if the two elements are considered equal.\n * @returns {T[] | ArrayLike<T>} - The array with specified values removed.\n *\n * @example\n * import pullAllWith from './pullAllWith';\n * import isEqual from '../predicate';\n *\n * const array = [{ x: 1, y: 2 }, { x: 3, y: 4 }, { x: 5, y: 6 }];\n * const valuesToRemove = [{ x: 3, y: 4 }];\n *\n * const result = pullAllWith(array, valuesToRemove, isEqual);\n *\n * console.log(result); // [{ x: 1, y: 2 }, { x: 5, y: 6 }]\n * console.log(array);  // [{ x: 1, y: 2 }, { x: 5, y: 6 }]\n */\nexport function pullAllWith<T>(\n  array: T[] | ArrayLike<T>,\n  values?: T[] | ArrayLike<T>,\n  comparator?: (a: T, b: T) => boolean\n): T[] | ArrayLike<T> {\n  if (array?.length == null || values?.length == null) {\n    return array;\n  }\n\n  if (array === values) {\n    values = copyArray(values);\n  }\n\n  let resultLength = 0;\n\n  if (comparator == null) {\n    comparator = (a, b) => eq(a, b);\n  }\n\n  const valuesArray = Array.isArray(values) ? values : Array.from(values);\n  const hasUndefined = valuesArray.includes(undefined as any);\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      const shouldRemove = valuesArray.some(value => comparator(array[i], value));\n\n      if (!shouldRemove) {\n        (array as any)[resultLength++] = array[i];\n      }\n\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!hasUndefined) {\n      delete (array as any)[resultLength++];\n    }\n  }\n\n  (array as any).length = resultLength;\n\n  return array;\n}\n","/**\n * Copies the values of `source` to `array`.\n *\n * @template T\n * @param {ArrayLike<T>} source The array to copy values from.\n * @param {T[]} [array=[]] The array to copy values to.\n * @returns {T[]} Returns `array`.\n */\nfunction copyArray<T>(source: ArrayLike<T>, array?: T[]): T[] {\n  const length = source.length;\n\n  if (array == null) {\n    array = Array(length);\n  }\n\n  for (let i = 0; i < length; i++) {\n    array[i] = source[i];\n  }\n\n  return array;\n}\n\nexport default copyArray;\n","import { get } from './get.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isString } from '../predicate/isString.ts';\n\ntype PropertyName = string | number | symbol;\ntype Many<T> = T | readonly T[];\ntype PropertyPath = Many<PropertyName>;\n\n/**\n * Gets values at given paths from a dictionary or numeric dictionary.\n *\n * @template T - The type of the values in the dictionary.\n * @param {Record<string, T> | Record<number, T> | null | undefined} object - The dictionary to query.\n * @param {...PropertyPath[]} props - The property paths to get values for.\n * @returns {T[]} Returns an array of the picked values.\n *\n * @example\n * const object = { 'a': 1, 'b': 2, 'c': 3 };\n * at(object, 'a', 'c');\n * // => [1, 3]\n */\nexport function at<T>(object: Record<string, T> | Record<number, T> | null | undefined, ...props: PropertyPath[]): T[];\n\n/**\n * Gets values at given keys from an object.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} object - The object to query.\n * @param {...Array<Many<keyof T>>} props - The property keys to get values for.\n * @returns {Array<T[keyof T]>} Returns an array of the picked values.\n *\n * @example\n * const object = { 'a': 1, 'b': 2, 'c': 3 };\n * at(object, 'a', 'c');\n * // => [1, 3]\n */\nexport function at<T extends object>(object: T | null | undefined, ...props: Array<Many<keyof T>>): Array<T[keyof T]>;\n\n/**\n * Returns an array of values corresponding to `paths` of `object`.\n *\n * @template T - The type of the object.\n * @param {T} object - The object to iterate over.\n * @param {...(PropertyKey | PropertyKey[] | ArrayLike<PropertyKey>)} [paths] - The property paths to pick.\n * @returns {Array<unknown>} - Returns the picked values.\n *\n * @example\n * ```js\n * const object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n *\n * at(object, ['a[0].b.c', 'a[1]']);\n * // => [3, 4]\n * ```\n */\nexport function at<T>(object: T, ...paths: Array<PropertyKey | PropertyKey[] | ArrayLike<PropertyKey>>): unknown[] {\n  if (paths.length === 0) {\n    return [];\n  }\n\n  const allPaths: PropertyKey[] = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (!isArrayLike(path) || isString(path)) {\n      allPaths.push(path as PropertyKey);\n      continue;\n    }\n\n    for (let j = 0; j < path.length; j++) {\n      allPaths.push(path[j]);\n    }\n  }\n\n  const result: unknown[] = [];\n\n  for (let i = 0; i < allPaths.length; i++) {\n    result.push(get(object, allPaths[i]));\n  }\n\n  return result;\n}\n","import { get } from './get.ts';\nimport { isUnsafeProperty } from '../../_internal/isUnsafeProperty.ts';\nimport { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Removes the property at the given path of the object.\n *\n * @param {unknown} obj - The object to modify.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to unset.\n * @returns {boolean} - Returns true if the property is deleted, else false.\n *\n * @example\n * const obj = { a: { b: { c: 42 } } };\n * unset(obj, 'a.b.c'); // true\n * console.log(obj); // { a: { b: {} } }\n *\n * @example\n * const obj = { a: { b: { c: 42 } } };\n * unset(obj, ['a', 'b', 'c']); // true\n * console.log(obj); // { a: { b: {} } }\n */\nexport function unset(obj: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  if (obj == null) {\n    return true;\n  }\n\n  switch (typeof path) {\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      if (Array.isArray(path)) {\n        return unsetWithPath(obj, path);\n      }\n\n      if (typeof path === 'number') {\n        path = toKey(path);\n      } else if (typeof path === 'object') {\n        if (Object.is(path?.valueOf(), -0)) {\n          path = '-0';\n        } else {\n          path = String(path);\n        }\n      }\n\n      if (isUnsafeProperty(path as PropertyKey)) {\n        return false;\n      }\n\n      if (obj?.[path as PropertyKey] === undefined) {\n        return true;\n      }\n\n      try {\n        delete obj[path as PropertyKey];\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    case 'string': {\n      if (obj?.[path] === undefined && isDeepKey(path)) {\n        return unsetWithPath(obj, toPath(path));\n      }\n\n      if (isUnsafeProperty(path)) {\n        return false;\n      }\n\n      try {\n        delete obj[path];\n        return true;\n      } catch {\n        return false;\n      }\n    }\n  }\n}\n\nfunction unsetWithPath(obj: unknown, path: readonly PropertyKey[]): boolean {\n  const parent = get(obj, path.slice(0, -1), obj);\n  const lastKey = path[path.length - 1];\n\n  if (parent?.[lastKey] === undefined) {\n    return true;\n  }\n\n  if (isUnsafeProperty(lastKey)) {\n    return false;\n  }\n\n  try {\n    delete parent[lastKey];\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Checks if the given value is an array.\n *\n * This function tests whether the provided value is an array or not.\n * It returns `true` if the value is an array, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\n *\n * @param {any} value - The value to test if it is an array.\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\n *\n * @example\n * const value1 = [1, 2, 3];\n * const value2 = 'abc';\n * const value3 = () => {};\n *\n * console.log(isArray(value1)); // true\n * console.log(isArray(value2)); // false\n * console.log(isArray(value3)); // false\n */\nexport function isArray(value?: any): value is any[];\n/**\n * Checks if the given value is an array with generic type support.\n *\n * This function tests whether the provided value is an array or not.\n * It returns `true` if the value is an array, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\n *\n * @template T - The type of elements in the array.\n * @param {any} value - The value to test if it is an array.\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\n *\n * @example\n * const value1 = [1, 2, 3];\n * const value2 = 'abc';\n * const value3 = () => {};\n *\n * console.log(isArray<number>(value1)); // true\n * console.log(isArray<string>(value2)); // false\n * console.log(isArray<Function>(value3)); // false\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function isArray<T>(value?: any): value is any[];\n\n/**\n * Checks if the given value is an array.\n *\n * This function tests whether the provided value is an array or not.\n * It returns `true` if the value is an array, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\n *\n * @param {any} value - The value to test if it is an array.\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\n *\n * @example\n * const value1 = [1, 2, 3];\n * const value2 = 'abc';\n * const value3 = () => {};\n *\n * console.log(isArray(value1)); // true\n * console.log(isArray(value2)); // false\n * console.log(isArray(value3)); // false\n */\nexport function isArray(value?: any): value is any[] {\n  return Array.isArray(value);\n}\n","import { flattenDepth } from './flattenDepth.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { isKey } from '../_internal/isKey.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { at } from '../object/at.ts';\nimport { unset } from '../object/unset.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\n * Indexes may be specified as an array of indexes or as individual arguments.\n *\n * **Note:** Unlike `_.at`, this method mutates `array`.\n *\n * @template T\n * @param {T[]} array - The array to modify.\n * @param {...Array<number | number[]>} indexes - The indexes of elements to remove, specified as individual indexes or arrays of indexes.\n * @returns {T[]} Returns the new array of removed elements.\n *\n * @example\n * var array = [5, 10, 15, 20];\n * var evens = pullAt(array, 1, 3);\n *\n * console.log(array);\n * // => [5, 15]\n *\n * console.log(evens);\n * // => [10, 20]\n */\nexport function pullAt<T>(array: T[], ...indexes: Array<Many<number>>): T[];\n\n/**\n * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\n * Indexes may be specified as an array of indexes or as individual arguments.\n *\n * **Note:** Unlike `_.at`, this method mutates `array`.\n *\n * @template L\n * @param {L} array - The array to modify.\n * @param {...Array<number | number[]>} indexes - The indexes of elements to remove, specified as individual indexes or arrays of indexes.\n * @returns {L} Returns the new array of removed elements.\n *\n * @example\n * var array = [5, 10, 15, 20];\n * var evens = pullAt(array, 1, 3);\n *\n * console.log(array);\n * // => [5, 15]\n *\n * console.log(evens);\n * // => [10, 20]\n */\nexport function pullAt<L extends ArrayLike<any>>(\n  array: L extends readonly any[] ? never : L,\n  ...indexes: Array<Many<number>>\n): L;\n\n/**\n * Removes elements from an array at specified indices and returns the removed elements.\n *\n * @template T\n * @param {ArrayLike<T>} array - The array from which elements will be removed.\n * @param {Array<number | readonly number[] | string | readonly string[]>} _indices - An array of indices specifying the positions of elements to remove.\n * @returns {ArrayLike<T>} An array containing the elements that were removed from the original array.\n *\n * @example\n * const numbers = [10, 20, 30, 40, 50];\n * const removed = pullAt(numbers, [1, 3, 4]);\n * console.log(removed); // [20, 40, 50]\n * console.log(numbers); // [10, 30]\n */\nexport function pullAt<T>(\n  array: ArrayLike<T>,\n  ..._indices: Array<number | readonly number[] | string | readonly string[]>\n): ArrayLike<T> {\n  const indices: Array<number | string> = flattenDepth(_indices as any, 1);\n\n  if (!array) {\n    return Array(indices.length);\n  }\n\n  const result = at(array, indices);\n\n  const indicesToPull = indices\n    .map(index => (isIndex(index, array.length) ? Number(index) : index))\n    .sort((a: any, b: any) => b - a);\n\n  for (const index of new Set(indicesToPull)) {\n    if (isIndex(index, array.length)) {\n      Array.prototype.splice.call(array, index as number, 1);\n      continue;\n    }\n\n    if (isKey(index, array)) {\n      delete (array as any)[toKey(index)];\n      continue;\n    }\n\n    const path = isArray(index) ? index : toPath(index);\n    unset(array, path);\n  }\n\n  return result as T[];\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { MemoListIterator } from '../_internal/MemoListIterator.ts';\nimport { MemoObjectIterator } from '../_internal/MemoObjectIterator.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Reduces an array to a single value using an iteratee function, starting from the right.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * @template T, U\n * @param {T[] | null | undefined} collection - The array to iterate over.\n * @param {MemoListIterator<T, U, T[]>} callback - The function invoked per iteration.\n * @param {U} accumulator - The initial value.\n * @returns {U} Returns the accumulated value.\n *\n * @example\n * reduceRight([1, 2, 3], (acc, value) => acc + value, 0);\n * // => 6\n */\nexport function reduceRight<T, U>(\n  collection: T[] | null | undefined,\n  callback: MemoListIterator<T, U, T[]>,\n  accumulator: U\n): U;\n\n/**\n * Reduces an array-like collection to a single value using an iteratee function, starting from the right.\n *\n * @template T, U\n * @param {ArrayLike<T> | null | undefined} collection - The array-like collection to iterate over.\n * @param {MemoListIterator<T, U, ArrayLike<T>>} callback - The function invoked per iteration.\n * @param {U} accumulator - The initial value.\n * @returns {U} Returns the accumulated value.\n *\n * @example\n * reduceRight([1, 2, 3], (acc, value) => acc + value, 0);\n * // => 6\n */\nexport function reduceRight<T, U>(\n  collection: ArrayLike<T> | null | undefined,\n  callback: MemoListIterator<T, U, ArrayLike<T>>,\n  accumulator: U\n): U;\n\n/**\n * Reduces an object to a single value using an iteratee function, starting from the right.\n *\n * @template T, U\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {MemoObjectIterator<T[keyof T], U, T>} callback - The function invoked per iteration.\n * @param {U} accumulator - The initial value.\n * @returns {U} Returns the accumulated value.\n *\n * @example\n * reduceRight({ a: 1, b: 2, c: 3 }, (acc, value) => acc + value, 0);\n * // => 6\n */\nexport function reduceRight<T extends object, U>(\n  collection: T | null | undefined,\n  callback: MemoObjectIterator<T[keyof T], U, T>,\n  accumulator: U\n): U;\n\n/**\n * Reduces an array to a single value using an iteratee function, starting from the right.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * The `reduceRight()` function goes through each element in an array from right to left and applies a special function (called a \"reducer\") to them, one by one.\n * This function takes the result of the previous step and the current element to perform a calculation.\n * After going through all the elements, the function gives you one final result.\n *\n * When the `reduceRight()` function starts, there's no previous result to use.\n * If you provide an initial value, it starts with that.\n * If not, it uses the last element of the array and begins with the second to last element for the calculation.\n *\n * @template T\n * @param {T[] | null | undefined} collection - The array to iterate over.\n * @param {MemoListIterator<T, T, T[]>} callback - The function invoked per iteration.\n * @returns {T | undefined} Returns the accumulated value.\n *\n * @example\n * reduceRight([1, 2, 3], (acc, value) => acc + value);\n * // => 6\n */\nexport function reduceRight<T>(\n  collection: T[] | null | undefined,\n  callback: MemoListIterator<T, T, T[]>\n): T | undefined;\n\n/**\n * Reduces an array-like collection to a single value using an iteratee function, starting from the right.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection - The array-like collection to iterate over.\n * @param {MemoListIterator<T, T, ArrayLike<T>>} callback - The function invoked per iteration.\n * @returns {T | undefined} Returns the accumulated value.\n *\n * @example\n * reduceRight([1, 2, 3], (acc, value) => acc + value);\n * // => 6\n */\nexport function reduceRight<T>(\n  collection: ArrayLike<T> | null | undefined,\n  callback: MemoListIterator<T, T, ArrayLike<T>>\n): T | undefined;\n\n/**\n * Reduces an object to a single value using an iteratee function, starting from the right.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {MemoObjectIterator<T[keyof T], T[keyof T], T>} callback - The function invoked per iteration.\n * @returns {T[keyof T] | undefined} Returns the accumulated value.\n *\n * @example\n * reduceRight({ a: 1, b: 2, c: 3 }, (acc, value) => acc + value);\n * // => 6\n */\nexport function reduceRight<T extends object>(\n  collection: T | null | undefined,\n  callback: MemoObjectIterator<T[keyof T], T[keyof T], T>\n): T[keyof T] | undefined;\n\n/**\n * Reduces a collection to a single value using an iteratee function, starting from the right.\n *\n * @param {T[] | ArrayLike<T> | Record<string, T> | null | undefined} collection - The collection to iterate over.\n * @param {((accumulator: any, value: any, index: PropertyKey, collection: any) => any) | PropertyKey | object} iteratee - The function invoked per iteration or the key to reduce over.\n * @param {any} initialValue - The initial value.\n * @returns {any} - Returns the accumulated value.\n *\n * @example\n * // Using a reducer function\n * const array = [1, 2, 3];\n * reduceRight(array, (acc, value) => acc + value, 0); // => 6\n *\n * @example\n * // Using a reducer function with initialValue\n * const array = [1, 2, 3];\n * reduceRight(array, (acc, value) => acc + value % 2 === 0, true); // => false\n *\n * @example\n * // Using an object as the collection\n * const obj = { a: 1, b: 2, c: 3 };\n * reduceRight(obj, (acc, value) => acc + value, 0); // => 6\n */\nexport function reduceRight(\n  collection: ArrayLike<any> | Record<any, any> | null | undefined,\n  iteratee: (accumulator: any, value: any, index: any, collection: any) => any = identity,\n  accumulator?: any\n): any {\n  if (!collection) {\n    return accumulator;\n  }\n\n  let keys: any[];\n  let startIndex: number;\n\n  if (isArrayLike(collection)) {\n    keys = range(0, collection.length).reverse();\n\n    if (accumulator == null && collection.length > 0) {\n      accumulator = (collection as ArrayLike<any>)[collection.length - 1];\n      startIndex = 1;\n    } else {\n      startIndex = 0;\n    }\n  } else {\n    keys = Object.keys(collection).reverse();\n\n    if (accumulator == null) {\n      accumulator = (collection as any)[keys[0]];\n      startIndex = 1;\n    } else {\n      startIndex = 0;\n    }\n  }\n\n  for (let i = startIndex; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    accumulator = iteratee(accumulator, value, key, collection);\n  }\n\n  return accumulator;\n}\n","/**\n * Creates a function that negates the result of the predicate function.\n *\n * @template T - The type of the arguments array.\n * @param {(...args: T) => boolean} predicate - The predicate to negate.\n * @returns {(...args: T) => boolean} The new negated function.\n *\n * @example\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * filter([1, 2, 3, 4, 5, 6], negate(isEven));\n * // => [1, 3, 5]\n */\nexport function negate<T extends any[]>(predicate: (...args: T) => boolean): (...args: T) => boolean;\n\n/**\n * Creates a function that negates the result of the predicate function.\n *\n * @template F - The type of the function to negate.\n * @param {F} func - The function to negate.\n * @returns {F} The new negated function, which negates the boolean result of `func`.\n *\n * @example\n * const array = [1, 2, 3, 4, 5, 6];\n * const isEven = (n: number) => n % 2 === 0;\n * const result = array.filter(negate(isEven));\n * // result will be [1, 3, 5]\n */\nexport function negate<F extends (...args: any[]) => boolean>(func: F): F {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  return function (this: any, ...args: any[]) {\n    return !func.apply(this, args);\n  } as F;\n}\n","import { filter } from './filter.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { ObjectIterateeCustom } from '../_internal/ObjectIteratee.ts';\nimport type { StringIterator } from '../_internal/StringIterator.ts';\nimport { negate } from '../function/negate.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Iterates over the collection and rejects elements based on the given predicate.\n * If a function is provided, it is invoked for each element in the collection.\n *\n * @param {string | null | undefined} collection The string to iterate over\n * @param {StringIterator<boolean>} [predicate] The function invoked per iteration\n * @returns {string[]} Returns a new array of characters that do not satisfy the predicate\n * @example\n * reject('abc', char => char === 'b')\n * // => ['a', 'c']\n */\nexport function reject(collection: string | null | undefined, predicate?: StringIterator<boolean>): string[];\n\n/**\n * Iterates over the collection and rejects elements based on the given predicate.\n * If a function is provided, it is invoked for each element in the collection.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection The array-like to iterate over\n * @param {ListIterateeCustom<T, boolean>} [predicate] The function invoked per iteration\n * @returns {T[]} Returns a new array of elements that do not satisfy the predicate\n * @example\n * reject([1, 2, 3], num => num % 2 === 0)\n * // => [1, 3]\n *\n * reject([{ a: 1 }, { a: 2 }, { b: 1 }], 'a')\n * // => [{ b: 1 }]\n */\nexport function reject<T>(collection: ArrayLike<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>): T[];\n\n/**\n * Iterates over the collection and rejects elements based on the given predicate.\n * If a function is provided, it is invoked for each element in the collection.\n *\n * @template T\n * @param {T | null | undefined} collection The object to iterate over\n * @param {ObjectIterateeCustom<T, boolean>} [predicate] The function invoked per iteration\n * @returns {Array<T[keyof T]>} Returns a new array of elements that do not satisfy the predicate\n * @example\n * reject({ a: 1, b: 2, c: 3 }, value => value % 2 === 0)\n * // => [1, 3]\n *\n * reject({ item1: { a: 0, b: true }, item2: { a: 1, b: true }, item3: { a: 2, b: false }}, { b: false })\n * // => [{ a: 0, b: true }, { a: 1, b: true }]\n */\nexport function reject<T extends object>(\n  collection: T | null | undefined,\n  predicate?: ObjectIterateeCustom<T, boolean>\n): Array<T[keyof T]>;\n\n/**\n * Iterates over the collection and rejects elements based on the given predicate.\n * If a function is provided, it is invoked for each element in the collection.\n *\n * @template T\n * @param {ArrayLike<T> | Record<any, any> | null | undefined} source - The array or object to iterate over.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate=identity] - The function invoked per iteration.\n * @returns {T[]} - Returns a new array of elements that do not satisfy the predicate.\n *\n * @example\n * reject([{ a: 1 }, { a: 2 }, { b: 1 }], 'a');\n * // => [{ b: 1 }]\n *\n * reject([{ a: 1 }, { a: 2 }, { b: 1 }], { b: 1 });\n * // => [{ a: 1 }, { a: 2 }]\n *\n * reject({ item1: { a: 0, b: true }, item2: { a: 1, b: true }, item3: { a: 2, b: false }}, { b: false })\n * // => [{ a: 0, b: true }, { a: 1, b: true }]\n *\n * reject([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => [{ a: 1 }, { a: 3 }]\n */\nexport function reject<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  predicate: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey = identity\n): T[] {\n  return filter(source, negate(iteratee(predicate)));\n}\n","import { remove as removeToolkit } from '../../array/remove.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Removes all elements from array that predicate returns truthy for and returns an array of the removed elements.\n *\n * @template L\n * @param {L extends readonly any[] ? never : L} array - The array to modify.\n * @param {ListIteratee<L[0]>} [predicate] - The function invoked per iteration.\n * @returns {Array<L[0]>} Returns the new array of removed elements.\n *\n * @example\n * const array = [1, 2, 3, 4];\n * const evens = remove(array, n => n % 2 === 0);\n * console.log(array); // => [1, 3]\n * console.log(evens); // => [2, 4]\n */\nexport function remove<L extends ArrayLike<any>>(\n  array: L extends readonly any[] ? never : L,\n  predicate?: ListIteratee<L[0]>\n): Array<L[0]>;\n\n/**\n * Removes elements from an array based on various criteria.\n *\n * @param {ArrayLike<T>} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: ArrayLike<T>) => boolean | Partial<T> | [keyof T, unknown] | keyof T} shouldRemoveElement - The function invoked per iteration, a partial object, a property-value pair, or a key to match against each element.\n * @returns {T[]} - Returns the modified array with the specified elements removed.\n *\n * @example\n * // Using a predicate function\n * const numbers = [1, 2, 3, 4, 5];\n * remove(numbers, value => value % 2 === 0); // => [1, 3, 5]\n *\n * @example\n * // Using a partial object\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * remove(objects, { a: 1 }); // => [{ a: 2 }, { a: 3 }]\n *\n * @example\n * // Using a property-value pair\n * const objects = [{ a: 1 }, { a: 2 }, { a: 3 }];\n * remove(objects, ['a', 1]); // => [{ a: 2 }, { a: 3 }]\n *\n * @example\n * // Using a property key\n * const objects = [{ a: 0 }, { a: 1 }];\n * remove(objects, 'a'); // => [{ a: 0 }]\n */\nexport function remove<T>(\n  arr: ArrayLike<T>,\n  shouldRemoveElement:\n    | ((value: T, index: number, arr: ArrayLike<T>) => boolean)\n    | Partial<T>\n    | [keyof T, unknown]\n    | keyof T = identity as any\n): T[] {\n  return removeToolkit(arr as T[], iteratee(shouldRemoveElement));\n}\n","/**\n * Removes elements from an array based on a predicate function.\n *\n * This function changes `arr` in place.\n * If you want to remove elements without modifying the original array, use `filter`.\n *\n * @template T\n * @param {T[]} arr - The array to modify.\n * @param {(value: T, index: number, array: T[]) => boolean} shouldRemoveElement - The function invoked per iteration to determine if an element should be removed.\n * @returns {T[]} The modified array with the specified elements removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * remove(numbers, (value) => value % 2 === 0);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function remove<T>(arr: T[], shouldRemoveElement: (value: T, index: number, array: T[]) => boolean): T[] {\n  const originalArr = arr.slice();\n  const removed = [];\n\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (shouldRemoveElement(arr[i], i, originalArr)) {\n      removed.push(arr[i]);\n\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return removed;\n}\n","/**\n * Reverses `array` so that the first element becomes the last, the second element becomes the second to last, and so on.\n *\n * @template L\n * @param {L extends readonly any[] ? never : L} array - The array to reverse.\n * @returns {L} Returns `array`.\n *\n * @example\n * const array = [1, 2, 3];\n * reverse(array);\n * // => [3, 2, 1]\n */\nexport function reverse<L extends ArrayLike<any>>(array: L extends readonly any[] ? never : L): L;\n\n/**\n * Reverses the elements of an array in place.\n *\n * This function takes an array and reverses its elements in place, modifying the original array.\n * If the input is `null` or `undefined`, it returns the input as is.\n *\n * @template T - The type of elements in the array.\n * @param {T[] | null | undefined} array - The array to reverse. If `null` or `undefined`, the input is returned as is.\n * @returns {T[] | null | undefined} The reversed array, or `null`/`undefined` if the input was `null`/`undefined`.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const reversedArray = reverse(array);\n * // reversedArray is [5, 4, 3, 2, 1], and array is also modified to [5, 4, 3, 2, 1].\n *\n * const emptyArray = reverse([]);\n * // emptyArray is [].\n *\n * const nullArray = reverse(null);\n * // nullArray is null.\n */\nexport function reverse<T>(array: T[] | null | undefined): T[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.reverse();\n}\n","/**\n * Returns a random element from an array.\n *\n * This function takes an array and returns a single element selected randomly from the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to sample from.\n * @returns {T} A random element from the array.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const randomElement = sample(array);\n * // randomElement will be one of the elements from the array, selected randomly.\n */\nexport function sample<T>(arr: readonly T[]): T {\n  const randomIndex = Math.floor(Math.random() * arr.length);\n  return arr[randomIndex];\n}\n","import { sample as sampleToolkit } from '../../array/sample.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Gets a random element from collection.\n *\n * @template T\n * @param {readonly [T, ...T[]]} collection - The collection to sample.\n * @returns {T} Returns the random element.\n *\n * @example\n * sample([1, 2, 3, 4]);\n * // => 2\n */\nexport function sample<T>(collection: readonly [T, ...T[]]): T;\n\n/**\n * Gets a random element from collection.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T> | null | undefined} collection - The collection to sample.\n * @returns {T | undefined} Returns the random element.\n *\n * @example\n * sample({ 'a': 1, 'b': 2, 'c': 3 });\n * // => 2\n */\nexport function sample<T>(collection: Record<string, T> | Record<number, T> | null | undefined): T | undefined;\n\n/**\n * Gets a random element from collection.\n *\n * @template T\n * @param {T | null | undefined} collection - The collection to sample.\n * @returns {T[keyof T] | undefined} Returns the random element.\n *\n * @example\n * sample({ 'a': 1, 'b': 2, 'c': 3 });\n * // => 2\n */\nexport function sample<T extends object>(collection: T | null | undefined): T[keyof T] | undefined;\n\n/**\n * The implementation for the overloaded sample function.\n *\n * This function takes an array, string, or object and returns a single element selected randomly.\n * If the input is empty, or if it's null or undefined, the function returns `undefined`.\n *\n * @template T - The type of elements in the collection.\n * @param {ArrayLike<T> | Record<string, T>} collection - The collection to sample from.\n * @returns {T | string | undefined} A random element from the collection, or `undefined` if the collection is empty or invalid.\n */\nexport function sample<T>(collection: ArrayLike<T> | Record<string, T> | null | undefined): T | string | undefined {\n  if (collection == null) {\n    return undefined;\n  }\n\n  if (isArrayLike(collection)) {\n    return sampleToolkit(toArray(collection));\n  }\n\n  return sampleToolkit(Object.values(collection));\n}\n","/**\n * Generate a random number within the given range.\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result1 = random(5); // Returns a random number between 0 and 5.\n * const result2 = random(0); // If the `maximum` is less than or equal to 0, an error is thrown.\n */\nexport function random(maximum: number): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum: number): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum?: number): number {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\n  }\n\n  return Math.random() * (maximum - minimum) + minimum;\n}\n","import { random } from './random.ts';\n\n/**\n * Generates a random integer between 0 (inclusive) and the given maximum (exclusive).\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between 0 (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result = randomInt(5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n */\nexport function randomInt(maximum: number): number;\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(minimum: number, maximum: number): number;\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(minimum: number, maximum?: number): number {\n  return Math.floor(random(minimum, maximum!));\n}\n","import { clamp as clampToolkit } from '../../math/clamp.ts';\n\n/**\n * Clamps a number within the specified bounds.\n *\n * @param {number} number The number to clamp\n * @param {number} lower The lower bound\n * @param {number} upper The upper bound\n * @returns {number} Returns the clamped number\n * @example\n * clamp(3, 2, 4) // => 3\n * clamp(0, 5, 10) // => 5\n * clamp(15, 5, 10) // => 10\n */\nexport function clamp(number: number, lower: number, upper: number): number;\n\n/**\n * Clamps a number to an upper bound.\n *\n * @param {number} number The number to clamp\n * @param {number} upper The upper bound\n * @returns {number} Returns the clamped number\n * @example\n * clamp(5, 3) // => 3\n * clamp(2, 3) // => 2\n */\nexport function clamp(number: number, upper: number): number;\n\n/**\n * Clamps a number within the specified bounds.\n *\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (Number.isNaN(bound1)) {\n    bound1 = 0;\n  }\n\n  if (Number.isNaN(bound2)) {\n    bound2 = 0;\n  }\n\n  return clampToolkit(value, bound1, bound2!);\n}\n","/**\n * Clamps a number within the inclusive upper bound.\n *\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified upper bound.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n */\nexport function clamp(value: number, maximum: number): number;\n\n/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, minimum: number, maximum: number): number;\n\n/**\n * Clamps a number within the specified bounds.\n *\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (bound2 == null) {\n    return Math.min(value, bound1);\n  }\n\n  return Math.min(Math.max(value, bound1), bound2);\n}\n","import { isMap as isMapToolKit } from '../../predicate/isMap.ts';\n\n/**\n * Checks if a given value is `Map`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\n *\n * @param {unknown} value The value to check if it is a `Map`.\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\n *\n * @example\n * const value1 = new Map();\n * const value2 = new Set();\n * const value3 = new WeakMap();\n *\n * console.log(isMap(value1)); // true\n * console.log(isMap(value2)); // false\n * console.log(isMap(value3)); // false\n */\n\nexport function isMap(value?: any): value is Map<any, any> {\n  return isMapToolKit(value);\n}\n","/**\n * Checks if a given value is `Map`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\n *\n * @param {unknown} value The value to check if it is a `Map`.\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\n *\n * @example\n * const value1 = new Map();\n * const value2 = new Set();\n * const value3 = new WeakMap();\n *\n * console.log(isMap(value1)); // true\n * console.log(isMap(value2)); // false\n * console.log(isMap(value3)); // false\n */\n\nexport function isMap(value: unknown): value is Map<any, any> {\n  return value instanceof Map;\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isMap } from '../predicate/isMap.ts';\n\n/**\n * Converts a record or null/undefined to an array of its values.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T> | null | undefined} value - The record or null/undefined to convert.\n * @returns {T[]} Returns an array of the record's values or an empty array if null/undefined.\n *\n * @example\n * toArray({ 'a': 1, 'b': 2 }) // => returns [1, 2]\n * toArray(null) // => returns []\n */\nexport function toArray<T>(value: Record<string, T> | Record<number, T> | null | undefined): T[];\n\n/**\n * Converts a value to an array of its values.\n *\n * @template T\n * @param {T} value - The value to convert.\n * @returns {Array<T[keyof T]>} Returns an array of the value's values.\n *\n * @example\n * toArray({ x: 10, y: 20 }) // => returns [10, 20]\n * toArray('abc') // => returns ['a', 'b', 'c']\n */\nexport function toArray<T>(value: T): Array<T[keyof T]>;\n\n/**\n * Converts an undefined value to an empty array.\n *\n * @returns {any[]} Returns an empty array.\n *\n * @example\n * toArray() // => returns []\n */\nexport function toArray(): any[];\n\n/**\n * Converts a value to an array.\n *\n * @param {unknown} value - The value to convert.\n * @returns {any[]} Returns the converted array.\n *\n * @example\n * toArray({ 'a': 1, 'b': 2 }) // => returns [1,2]\n * toArray('abc') // => returns ['a', 'b', 'c']\n * toArray(1) // => returns []\n * toArray(null) // => returns []\n */\nexport function toArray(value?: unknown): any[] {\n  if (value == null) {\n    return [];\n  }\n\n  if (isArrayLike(value) || isMap(value)) {\n    return Array.from(value);\n  }\n\n  if (typeof value === 'object') {\n    return Object.values(value);\n  }\n\n  return [];\n}\n","import { sampleSize as sampleSizeToolkit } from '../../array/sampleSize.ts';\nimport { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { clamp } from '../math/clamp.ts';\nimport { toArray } from '../util/toArray.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Returns a sample element array of a specified size from a collection.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T> | null | undefined} collection - The collection to sample from.\n * @param {number} [n] - The size of sample.\n * @returns {T[]} A new array with sample size applied.\n *\n * @example\n * sampleSize([1, 2, 3], 2);\n * // => [2, 3] (example, actual result will vary)\n */\nexport function sampleSize<T>(collection: Record<string, T> | Record<number, T> | null | undefined, n?: number): T[];\n\n/**\n * Returns a sample element array of a specified size from an object.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to sample from.\n * @param {number} [n] - The size of sample.\n * @returns {Array<T[keyof T]>} A new array with sample size applied.\n *\n * @example\n * sampleSize({ a: 1, b: 2, c: 3 }, 2);\n * // => [2, 3] (example, actual result will vary)\n */\nexport function sampleSize<T extends object>(collection: T | null | undefined, n?: number): Array<T[keyof T]>;\n\n/**\n * Returns a sample element array of a specified `size`.\n *\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\n *\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algorithm}\n *\n * @template T - The type of elements in the array.\n * @param {Record<string, T> | Record<number, T> | T | null | undefined} collection - The array to sample from.\n * @param {number} size - The size of sample.\n * @returns {Array<T[keyof T]> | T[]} A new array with sample size applied.\n *\n * @example\n * const result = sampleSize([1, 2, 3], 2)\n * // result will be an array containing two of the elements from the collection.\n * // [1, 2] or [1, 3] or [2, 3]\n */\nexport function sampleSize<T>(\n  collection: Record<string, T> | Record<number, T> | T | null | undefined,\n  size?: number,\n  guard?: unknown\n): Array<T[keyof T]> | T[] {\n  const arrayCollection = toArray(collection);\n\n  if (guard ? isIterateeCall(collection, size, guard) : size === undefined) {\n    size = 1;\n  } else {\n    size = clamp(toInteger(size), 0, arrayCollection.length);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  return sampleSizeToolkit(arrayCollection, size);\n}\n","import { randomInt } from '../math/randomInt.ts';\n\n/**\n * Returns a sample element array of a specified `size`.\n *\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\n *\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algorithm}\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to sample from.\n * @param {number} size - The size of sample.\n * @returns {T[]} A new array with sample size applied.\n * @throws {Error} Throws an error if `size` is greater than the length of `array`.\n *\n * @example\n * const result = sampleSize([1, 2, 3], 2)\n * // result will be an array containing two of the elements from the array.\n * // [1, 2] or [1, 3] or [2, 3]\n */\nexport function sampleSize<T>(array: readonly T[], size: number): T[] {\n  if (size > array.length) {\n    throw new Error('Size must be less than or equal to the length of array.');\n  }\n\n  const result = new Array(size);\n  const selected = new Set();\n\n  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {\n    let index = randomInt(0, step + 1);\n\n    if (selected.has(index)) {\n      index = step;\n    }\n\n    selected.add(index);\n\n    result[resultIndex] = array[index];\n  }\n\n  return result;\n}\n","/**\n * Randomizes the order of elements in an array using the Fisher-Yates algorithm.\n *\n * This function takes an array and returns a new array with its elements shuffled in a random order.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to shuffle.\n * @returns {T[]} A new array with its elements shuffled in random order.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const shuffledArray = shuffle(array);\n * // shuffledArray will be a new array with elements of array in random order, e.g., [3, 1, 4, 5, 2]\n */\nexport function shuffle<T>(arr: readonly T[]): T[] {\n  const result = arr.slice();\n\n  /**\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n   */\n  for (let i = result.length - 1; i >= 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n\n  return result;\n}\n","/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T> | ArrayLike<T> | null | undefined} object - The object to query.\n * @returns {T[]} Returns an array of property values.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * values(obj); // => [1, 2, 3]\n */\nexport function values<T>(object: Record<string, T> | Record<number, T> | ArrayLike<T> | null | undefined): T[];\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @template T\n * @param {T | null | undefined} object - The object to query.\n * @returns {Array<T[keyof T]>} Returns an array of property values.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * values(obj); // => [1, 2, 3]\n */\nexport function values<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @param {any} object - The object to query.\n * @returns {any[]} Returns an array of property values.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * values(obj); // => [1, 2, 3]\n */\nexport function values(object: any): any[];\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * @param {any} object The object to query.\n * @returns {any[]} Returns an array of property values.\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * values(obj); // => [1, 2, 3]\n */\nexport function values(object: any): any[] {\n  return Object.values(object);\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {any} x - The value to test for null or undefined.\n * @returns {x is null | undefined} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x: any): x is null | undefined {\n  return x == null;\n}\n","import { shuffle as shuffleToolkit } from '../../array/shuffle.ts';\nimport { values } from '../object/values.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isNil } from '../predicate/isNil.ts';\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\n\n/**\n * Randomizes the order of elements in an `array` using the Fisher-Yates algorithm.\n *\n * This function takes an `array` and returns a new `array` with its elements shuffled in a random order.\n *\n * @template T - The type of elements in the `array`.\n * @param {T[]} array - The `array` to shuffle.\n * @returns {T[]} A new `array` with its elements shuffled in random order.\n */\nexport function shuffle<T>(array: ArrayLike<T> | null | undefined): T[];\n\n/**\n * Randomizes the order of elements in an `object` using the Fisher-Yates algorithm.\n *\n * This function takes an `object` and returns a new `object` with its values shuffled in a random order.\n *\n * @template T - The type of elements in the `object`.\n * @param {T} object - The `object` to shuffle.\n * @returns {T[]} A new `Array` with the values of the `object` shuffled in a random order.\n */\nexport function shuffle<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n/**\n * Randomizes the order of elements in an `collection` using the Fisher-Yates algorithm.\n *\n * This function takes an `collection` and returns a new `collection` with its elements shuffled in a random order.\n *\n * @template T - The type of elements in the `collection`.\n * @param {T[]} collection - The `collection` to shuffle.\n * @returns {T[]} A new `collection` with its elements shuffled in random order.\n */\nexport function shuffle<T>(collection: ArrayLike<T> | T | null | undefined): T[] | Array<T[keyof T]> {\n  if (isNil(collection)) {\n    return [];\n  }\n\n  if (isArray(collection)) {\n    return shuffleToolkit(collection);\n  }\n\n  if (isArrayLike(collection)) {\n    return shuffleToolkit(Array.from(collection));\n  }\n\n  if (isObjectLike(collection)) {\n    return shuffleToolkit(values(collection as Record<PropertyKey, T[keyof T]>));\n  }\n\n  return [];\n}\n","import { isNil } from '../../predicate/isNil.ts';\n\n/**\n * Returns the length of an array, string, or object.\n *\n * This function takes an array, string, or object and returns its length.\n * For arrays and strings, it returns the number of elements or characters, respectively.\n * For objects, it returns the number of enumerable properties.\n *\n * @template T - The type of the input value.\n * @param {T[] | object | string | Map<unknown, T> | Set<T> | null | undefined } target - The value whose size is to be determined. It can be an array, string, or object.\n * @returns {number} The size of the input value.\n *\n * @example\n * const arr = [1, 2, 3];\n * const arrSize = size(arr);\n * // arrSize will be 3\n *\n * const str = 'hello';\n * const strSize = size(str);\n * // strSize will be 5\n *\n * const obj = { a: 1, b: 2, c: 3 };\n * const objSize = size(obj);\n * // objSize will be 3\n *\n * const emptyArr = [];\n * const emptyArrSize = size(emptyArr);\n * // emptyArrSize will be 0\n *\n * const emptyStr = '';\n * const emptyStrSize = size(emptyStr);\n * // emptyStrSize will be 0\n *\n * const emptyObj = {};\n * const emptyObjSize = size(emptyObj);\n * // emptyObjSize will be 0\n */\nexport function size(collection: object | string | null | undefined): number;\n\nexport function size(target: any): number {\n  if (isNil(target)) {\n    return 0;\n  }\n\n  if (target instanceof Map || target instanceof Set) {\n    return target.size;\n  }\n\n  return Object.keys(target).length;\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Create a slice of `array` from `start` up to, but not including, `end`.\n *\n * It does not return a dense array for sparse arrays unlike the native `Array.prototype.slice`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T> | null | undefined} array - The array to slice.\n * @param {number} [start=0] - The start position.\n * @param {number} [end=array.length] - The end position.\n * @returns {T[]} - Returns the slice of `array`.\n *\n * @example\n * slice([1, 2, 3], 1, 2); // => [2]\n * slice(new Array(3)); // => [undefined, undefined, undefined]\n */\nexport function slice<T>(array: ArrayLike<T> | null | undefined, start?: number, end?: number): T[] {\n  if (!isArrayLike(array)) {\n    return [];\n  }\n\n  const length = array.length;\n\n  if (end === undefined) {\n    end = length;\n  } else if (typeof end !== 'number' && isIterateeCall(array, start, end)) {\n    // support for expression like `_.map(slice)`\n    start = 0;\n    end = length;\n  }\n\n  start = toInteger(start);\n  end = toInteger(end);\n\n  if (start < 0) {\n    start = Math.max(length + start, 0);\n  } else {\n    start = Math.min(start, length);\n  }\n\n  if (end < 0) {\n    end = Math.max(length + end, 0);\n  } else {\n    end = Math.min(end, length);\n  }\n\n  const resultLength = Math.max(end - start, 0);\n  const result = new Array(resultLength);\n\n  for (let i = 0; i < resultLength; ++i) {\n    result[i] = array[start + i];\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { ListIterateeCustom } from '../_internal/ListIterateeCustom.ts';\nimport { ObjectIterateeCustom } from '../_internal/ObjectIteratee.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Checks if predicate returns truthy for any element of collection.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {ListIterateeCustom<T, boolean>} [predicate] - The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some([null, 0, 'yes', false], Boolean);\n * // => true\n */\nexport function some<T>(\n  collection: ArrayLike<T> | null | undefined,\n  predicate?: ListIterateeCustom<T, boolean>\n): boolean;\n\n/**\n * Checks if predicate returns truthy for any element of collection.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {ObjectIterateeCustom<T, boolean>} [predicate] - The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some({ 'a': 0, 'b': 1, 'c': 0 }, function(n) { return n > 0; });\n * // => true\n */\nexport function some<T extends object>(\n  collection: T | null | undefined,\n  predicate?: ObjectIterateeCustom<T, boolean>\n): boolean;\n\n/**\n * Checks if there is an element in an array that matches the given predicate.\n *\n * Iteration is stopped once there is an element that matches `predicate`.\n *\n * @template T\n * @param {ArrayLike<T> | Record<string, any> | null | undefined} source The source to iterate over.\n * @param {((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate=identity] The function invoked per iteration.\n * If a property name or an object is provided it will be used to create a predicate function.\n * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n *\n * @example\n * some([1, 2, 3, 4], n => n % 2 === 0);\n * // => true\n *\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], { a: 2 });\n * // => true\n *\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], ['a', 2]);\n * // => true\n *\n * some([{ a: 1 }, { a: 2 }, { a: 3 }], 'a');\n * // => true\n *\n * some({ a: 1, b: 2, c: 3 }, n => n % 2 === 0);\n * // => true\n *\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, { name: 'Bob' });\n * // => true\n *\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, ['name', 'Alice']);\n * // => true\n *\n * some({ a: { id: 1, name: 'Alice' }, b: { id: 2, name: 'Bob' } }, 'name');\n * // => true\n */\nexport function some<T>(\n  source: ArrayLike<T> | Record<any, any> | null | undefined,\n  predicate?: ((item: T, index: number, arr: any) => unknown) | Partial<T> | [keyof T, unknown] | PropertyKey,\n  guard?: unknown\n): boolean {\n  if (!source) {\n    return false;\n  }\n  if (guard != null) {\n    predicate = undefined;\n  }\n\n  if (!predicate) {\n    predicate = identity;\n  }\n\n  const values = Array.isArray(source) ? source : Object.values(source);\n\n  switch (typeof predicate) {\n    case 'function': {\n      if (!Array.isArray(source)) {\n        const keys = Object.keys(source) as Array<keyof T>;\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const value = source[key];\n\n          if (predicate(value as T, key as number, source)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      for (let i = 0; i < source.length; i++) {\n        if (predicate(source[i] as T, i, source)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    case 'object': {\n      if (Array.isArray(predicate) && predicate.length === 2) {\n        const key = predicate[0];\n        const value = predicate[1];\n\n        const matchFunc = matchesProperty(key, value);\n        if (Array.isArray(source)) {\n          for (let i = 0; i < source.length; i++) {\n            if (matchFunc(source[i])) {\n              return true;\n            }\n          }\n          return false;\n        }\n        return values.some(matchFunc);\n      } else {\n        const matchFunc = matches(predicate);\n        if (Array.isArray(source)) {\n          for (let i = 0; i < source.length; i++) {\n            if (matchFunc(source[i])) {\n              return true;\n            }\n          }\n          return false;\n        }\n        return values.some(matchFunc);\n      }\n    }\n    case 'number':\n    case 'symbol':\n    case 'string': {\n      const propFunc = property(predicate);\n      if (Array.isArray(source)) {\n        for (let i = 0; i < source.length; i++) {\n          if (propFunc(source[i])) {\n            return true;\n          }\n        }\n        return false;\n      }\n      return values.some(propFunc);\n    }\n  }\n}\n","import { orderBy } from './orderBy.ts';\nimport { flatten } from '../../array/flatten.ts';\nimport { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { ObjectIteratee } from '../_internal/ObjectIteratee.ts';\n\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of criteria to sort by.\n * It returns the ascending sorted array, ordering by each key.\n * If values for a key are equal, it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | object | null | undefined} collection - The array of objects to be sorted.\n * @param {Array<Array<Criterion<T> | Criterion<T>>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\n * @returns {T[]} - The ascending sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = sortBy(users, ['user', (item) => item.age])\n * // result will be:\n * // [\n * //   { user: 'barney', age: 34 },\n * //   { user: 'barney', age: 36 },\n * //   { user: 'fred', age: 40 },\n * //   { user: 'fred', age: 48 },\n * // ]\n */\n/**\n * Creates an array of elements, sorted in ascending order by the results of running each element in a collection thru each iteratee.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} collection - The collection to iterate over.\n * @param {...Array<T | readonly T[] | ListIteratee<T>>} iteratees - The iteratees to sort by.\n * @returns {T[]} Returns the new sorted array.\n *\n * @example\n * const users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 42 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n */\nexport function sortBy<T>(collection: ArrayLike<T> | null | undefined, ...iteratees: Array<Many<ListIteratee<T>>>): T[];\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of running each element in a collection thru each iteratee.\n *\n * @template T\n * @param {T | null | undefined} collection - The object to iterate over.\n * @param {...Array<T[keyof T] | readonly Array<T[keyof T]> | ObjectIteratee<T>>} iteratees - The iteratees to sort by.\n * @returns {Array<T[keyof T]>} Returns the new sorted array.\n *\n * @example\n * const users = {\n *   'a': { 'user': 'fred',   'age': 48 },\n *   'b': { 'user': 'barney', 'age': 36 }\n * };\n *\n * sortBy(users, [function(o) { return o.user; }]);\n * // => [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 48 }]\n */\nexport function sortBy<T extends object>(\n  collection: T | null | undefined,\n  ...iteratees: Array<Many<ObjectIteratee<T>>>\n): Array<T[keyof T]>;\n\nexport function sortBy<T = any>(collection: ArrayLike<T> | object | null | undefined, ...criteria: any[]): T[] {\n  const length = criteria.length;\n  // Enables use as an iteratee for methods like `_.reduce` and `_.map`.\n  if (length > 1 && isIterateeCall(collection, criteria[0], criteria[1])) {\n    criteria = [];\n  } else if (length > 2 && isIterateeCall(criteria[0], criteria[1], criteria[2])) {\n    criteria = [criteria[0]];\n  }\n  return orderBy(collection, flatten(criteria), ['asc']);\n}\n","/**\n * Checks if the value is NaN.\n *\n * @param {any} value - The value to check.\n * @returns {boolean} `true` if the value is NaN, `false` otherwise.\n *\n * @example\n * isNaN(NaN); // true\n * isNaN(0); // false\n * isNaN('NaN'); // false\n * isNaN(undefined); // false\n */\nexport function isNaN(value?: any): boolean {\n  return Number.isNaN(value);\n}\n","import { isNull } from '../../predicate/isNull.ts';\nimport { isUndefined } from '../../predicate/isUndefined.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isNaN } from '../predicate/isNaN.ts';\nimport { isNil } from '../predicate/isNil.ts';\nimport { isSymbol } from '../predicate/isSymbol.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\ntype PropertyName = string | number | symbol;\ntype Iteratee<T, R> = ((value: T) => R) | PropertyName | [PropertyName, any] | Partial<T>;\n\nconst MAX_ARRAY_LENGTH = 4294967295;\nconst MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/**\n * This method is like `sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The sorted array to inspect.\n * @param {T} value - The value to evaluate.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted into `array`.\n *\n * @example\n * const dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\n * sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\n * // => 1\n *\n * @example\n * sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n * // => 0\n */\nexport function sortedIndexBy<T>(array: ArrayLike<T> | null | undefined, value: T, iteratee?: ValueIteratee<T>): number;\n\n/**\n * This method is like `sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @param {(value: T) => R | PropertyName | [PropertyName, any] | Partial<T>} iteratee The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * const objects = [{ 'n': 4 }, { 'n': 5 }]\n * sortedIndexBy(objects, { 'n': 4 }, ({ n }) => n)\n * // => 0\n */\nexport function sortedIndexBy<T, R>(\n  array: ArrayLike<T> | null | undefined,\n  value: T,\n  iteratee: Iteratee<T, R> = iterateeToolkit,\n  retHighest?: boolean\n): number {\n  let low = 0;\n  let high = array == null ? 0 : array.length;\n  if (high === 0 || isNil(array)) {\n    return 0;\n  }\n\n  const iterateeFunction = iterateeToolkit(iteratee);\n  const transformedValue = iterateeFunction(value);\n\n  const valIsNaN = isNaN(transformedValue);\n  const valIsNull = isNull(transformedValue);\n  const valIsSymbol = isSymbol(transformedValue);\n  const valIsUndefined = isUndefined(transformedValue);\n\n  while (low < high) {\n    let setLow: boolean;\n    const mid = Math.floor((low + high) / 2);\n    const computed = iterateeFunction(array[mid]);\n\n    const othIsDefined = !isUndefined(computed);\n    const othIsNull = isNull(computed);\n    const othIsReflexive = !isNaN(computed);\n    const othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? computed! <= transformedValue : computed! < transformedValue;\n    }\n\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return Math.min(high, MAX_ARRAY_INDEX);\n}\n","/**\n * Checks if a given value is a number.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {any} value The value to check if it is a number.\n * @returns {value is number} Returns `true` if `value` is a number, else `false`.\n *\n * @example\n * const value1 = 123;\n * const value2 = 'abc';\n * const value3 = true;\n *\n * console.log(isNumber(value1)); // true\n * console.log(isNumber(value2)); // false\n * console.log(isNumber(value3)); // false\n */\nexport function isNumber(value?: any): value is number {\n  return typeof value === 'number' || value instanceof Number;\n}\n","import { sortedIndexBy } from './sortedIndexBy.ts';\nimport { isNil } from '../../predicate/isNil.ts';\nimport { isNull } from '../../predicate/isNull.ts';\nimport { isSymbol } from '../../predicate/isSymbol.ts';\nimport { isNumber } from '../predicate/isNumber.ts';\n\nconst MAX_ARRAY_LENGTH = 4294967295;\nconst HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @category Array\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * sortedIndex([30, 50], 40)\n * // => 1\n */\nexport function sortedIndex<T>(array: ArrayLike<T> | null | undefined, value: T): number;\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @category Array\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * sortedIndex([30, 50], 40)\n * // => 1\n */\nexport function sortedIndex<T>(array: ArrayLike<T> | null | undefined, value: T): number;\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @category Array\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * sortedIndex([30, 50], 40)\n * // => 1\n */\nexport function sortedIndex<T>(array: ArrayLike<T> | null | undefined, value: T): number {\n  if (isNil(array)) {\n    return 0;\n  }\n  let low = 0,\n    high = isNil(array) ? low : array.length;\n\n  if (isNumber(value) && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n    while (low < high) {\n      const mid = (low + high) >>> 1;\n      const compute = array[mid];\n      if (!isNull(compute) && !isSymbol(compute) && (compute as any) < value) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return high;\n  }\n  return sortedIndexBy(array, value, value => value);\n}\n","import { sortedIndex } from './sortedIndex.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Finds the index of the first occurrence of a value in a sorted array, similar to how `Array#indexOf` works, but specifically for sorted arrays.\n *\n * Make sure to provide a sorted array to this function, as it uses a binary search to quickly find the index.\n *\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to search for.\n * @returns {number} Returns the index of the matched value, else -1.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * sortedIndexOf(numbers, 11); // Return value: 0\n * sortedIndexOf(numbers, 30); // Return value: -1\n *\n * // If the value is duplicated, it returns the first index of the value.\n * const duplicateNumbers = [1, 2, 2, 3, 3, 3, 4];\n * sortedIndexOf(duplicateNumbers, 3); // Return value: 3\n *\n * // If the array is unsorted, it can return the wrong index.\n * const unSortedArray = [55, 33, 22, 11, 44];\n * sortedIndexOf(unSortedArray, 11); // Return value: -1\n *\n * // -0 and 0 are treated the same\n * const mixedZeroArray = [-0, 0];\n * sortedIndexOf(mixedZeroArray, 0); // Return value: 0\n * sortedIndexOf(mixedZeroArray, -0); // Return value: 0\n *\n * // It works with array-like objects\n * const arrayLike = { length: 3, 0: 10, 1: 20, 2: 30 };\n * sortedIndexOf(arrayLike, 20); // Return value: 1\n */\nexport function sortedIndexOf<T>(array: ArrayLike<T> | null | undefined, value: T): number {\n  if (!array?.length) {\n    return -1;\n  }\n\n  const index = sortedIndex(array, value);\n  if (index < array.length && eq(array[index], value)) {\n    return index;\n  }\n  return -1;\n}\n","import { sortedIndexBy } from './sortedIndexBy.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\n\ntype PropertyName = string | number | symbol;\n\n// Lodash  Iteratee  \ntype Iteratee<T, R> = ((value: T) => R) | PropertyName | [PropertyName, any] | Partial<T>;\n\n/**\n * This method is like `sortedLastIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The sorted array to inspect.\n * @param {T} value - The value to evaluate.\n * @param {ValueIteratee<T>} iteratee - The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted into `array`.\n *\n * @example\n * sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n * // => 1\n */\nexport function sortedLastIndexBy<T>(\n  array: ArrayLike<T> | null | undefined,\n  value: T,\n  iteratee: ValueIteratee<T>\n): number;\n\n/**\n * This method is like `sortedLastIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @param {(value: T) => R | PropertyName | [PropertyName, any] | Partial<T>} iteratee The iteratee invoked per element.\n * @returns {number} Returns the highest index at which `value` should be inserted\n *  into `array`.\n * @example\n * const objects = [{ 'n': 4 }, { 'n': 5 }]\n * sortedLastIndexBy(objects, { 'n': 4 }, ({ n }) => n)\n * // => 1\n */\nexport function sortedLastIndexBy<T, R>(\n  array: ArrayLike<T> | null | undefined,\n  value: T,\n  iteratee?: Iteratee<T, R>\n): number {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  return sortedIndexBy(array, value, iteratee, true);\n}\n","import { sortedLastIndexBy } from './sortedLastIndexBy.ts';\nimport { isNil } from '../../predicate/isNil.ts';\nimport { isNull } from '../../predicate/isNull.ts';\nimport { isSymbol } from '../../predicate/isSymbol.ts';\nimport { isNumber } from '../predicate/isNumber.ts';\n\nconst MAX_ARRAY_LENGTH = 4294967295;\nconst HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n/**\n * Uses a binary search to determine the highest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @category Array\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * sortedIndex([4, 5, 5, 5, 6], 5)\n * // => 4\n */\nexport function sortedLastIndex<T>(array: ArrayLike<T> | null | undefined, value: T): number {\n  if (isNil(array)) {\n    return 0;\n  }\n\n  let high = array.length;\n\n  if (!isNumber(value) || Number.isNaN(value) || high > HALF_MAX_ARRAY_LENGTH) {\n    return sortedLastIndexBy(array, value, value => value);\n  }\n\n  let low = 0;\n\n  while (low < high) {\n    const mid = (low + high) >>> 1;\n    const compute = array[mid];\n    if (!isNull(compute) && !isSymbol(compute) && (compute as any) <= value) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return high;\n}\n","import { sortedLastIndex } from './sortedLastIndex.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Finds the index of the last occurrence of a value in a sorted array.\n * This function is similar to `Array#lastIndexOf` but is specifically designed for sorted arrays.\n *\n * Make sure to provide a sorted array to this function, as it uses a binary search to quickly find the index.\n *\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to search for.\n * @returns {number} Returns the index of the last matched value, else -1.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * sortedLastIndexOf(numbers, 3); // Return value: 2\n * sortedLastIndexOf(numbers, 6); // Return value: -1\n *\n * // If the value is duplicated, it returns the last index of the value.\n * const duplicateNumbers = [1, 2, 2, 3, 3, 3, 4];\n * sortedLastIndexOf(duplicateNumbers, 3); // Return value: 5\n *\n * // If the array is unsorted, it can return the wrong index.\n * const unSortedArray = [55, 33, 22, 11, 44];\n * sortedLastIndexOf(unSortedArray, 11); // Return value: -1\n *\n * // -0 and 0 are treated the same\n * const mixedZeroArray = [-0, 0];\n * sortedLastIndexOf(mixedZeroArray, 0); // Return value: 1\n * sortedLastIndexOf(mixedZeroArray, -0); // Return value: 1\n *\n * // It works with array-like objects\n * const arrayLike = { length: 3, 0: 10, 1: 20, 2: 20 };\n * sortedLastIndexOf(arrayLike, 20); // Return value: 2\n */\nexport function sortedLastIndexOf<T>(array: ArrayLike<T> | null | undefined, value: T): number {\n  if (!array?.length) {\n    return -1;\n  }\n\n  const index = sortedLastIndex(array, value) - 1;\n  if (index >= 0 && eq(array[index], value)) {\n    return index;\n  }\n  return -1;\n}\n","import { tail as tailToolkit } from '../../array/tail.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Gets all but the first element of array.\n *\n * @template T\n * @param {readonly [unknown, ...T]} array - The array to query.\n * @returns {T} Returns the slice of array.\n *\n * @example\n * tail([1, 2, 3]);\n * // => [2, 3]\n */\nexport function tail<T extends unknown[]>(array: readonly [unknown, ...T]): T;\n\n/**\n * Gets all but the first element of array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @returns {T[]} Returns the slice of array.\n *\n * @example\n * tail([1, 2, 3]);\n * // => [2, 3]\n */\nexport function tail<T>(array: ArrayLike<T> | null | undefined): T[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: ArrayLike<T> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n  return tailToolkit(toArray(arr));\n}\n","/**\n * Returns an empty array when the input is a single-element array.\n *\n * @template T - The type of the single element in the array.\n * @param {[T]} arr - The single-element array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [1];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail<T>(arr: readonly [T]): [];\n\n/**\n * Returns an empty array when the input is an empty array.\n *\n * @template T - The type of elements in the array.\n * @param {[]} arr - The empty array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail(arr: readonly []): [];\n\n/**\n * Returns a new array with all elements except for the first when the input is a tuple array.\n *\n * @template T - The type of the first element in the tuple array.\n * @template U - The type of the remaining elements in the tuple array.\n * @param {[T, ...U[]]} arr - The tuple array to process.\n * @returns {U[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr = [1, 2, 3];\n * const result = tail(arr);\n * // result will be [2, 3]\n */\nexport function tail<T, U>(arr: readonly [T, ...U[]]): U[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: readonly T[]): T[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: readonly T[]): T[] {\n  return arr.slice(1);\n}\n","import { take as takeToolkit } from '../../array/take.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a slice of array with n elements taken from the beginning.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {number} [n=1] - The number of elements to take.\n * @returns {T[]} Returns the slice of array.\n *\n * @example\n * take([1, 2, 3]);\n * // => [1]\n *\n * @example\n * take([1, 2, 3], 2);\n * // => [1, 2]\n *\n * @example\n * take([1, 2, 3], 5);\n * // => [1, 2, 3]\n *\n * @example\n * take([1, 2, 3], 0);\n * // => []\n */\nexport function take<T>(array: ArrayLike<T> | null | undefined, n?: number): T[];\n\n/**\n * Returns a new array containing the first `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {ArrayLike<T> | null | undefined} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3, 4, 5], 3);\n *\n * @example\n * // Returns ['a', 'b']\n * take(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3], 5);\n */\nexport function take<T>(arr: ArrayLike<T> | null | undefined, count = 1, guard?: unknown): T[] {\n  count = guard ? 1 : toInteger(count);\n  if (count < 1 || !isArrayLike(arr)) {\n    return [];\n  }\n\n  return takeToolkit(toArray(arr), count);\n}\n","import { toInteger } from '../compat/util/toInteger.ts';\n\n/**\n * Returns a new array containing the first `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {T[]} arr - The array to take elements from.\n * @param {number} count - The number of elements to take.\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3, 4, 5], 3);\n *\n * @example\n * // Returns ['a', 'b']\n * take(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3], 5);\n */\nexport function take<T>(arr: readonly T[], count?: number, guard?: unknown): T[] {\n  count = guard || count === undefined ? 1 : toInteger(count);\n  return arr.slice(0, count);\n}\n","import { takeRight as takeRightToolkit } from '../../array/takeRight.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a slice of array with n elements taken from the end.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {number} [n=1] - The number of elements to take.\n * @returns {T[]} Returns the slice of array.\n *\n * @example\n * takeRight([1, 2, 3]);\n * // => [3]\n *\n * @example\n * takeRight([1, 2, 3], 2);\n * // => [2, 3]\n *\n * @example\n * takeRight([1, 2, 3], 5);\n * // => [1, 2, 3]\n *\n * @example\n * takeRight([1, 2, 3], 0);\n * // => []\n */\nexport function takeRight<T>(array: ArrayLike<T> | null | undefined, n?: number): T[];\n\n/**\n * Returns a new array containing the last `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @param {unknown} [guard] - Enables use as an iteratee for methods like `_.map`.\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\n *\n * @example\n * // Returns [4, 5]\n * takeRight([1, 2, 3, 4, 5], 2);\n *\n * @example\n * // Returns ['b', 'c']\n * takeRight(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * takeRight([1, 2, 3], 5);\n */\nexport function takeRight<T>(arr: ArrayLike<T> | null | undefined, count = 1, guard?: unknown): T[] {\n  count = guard ? 1 : toInteger(count);\n  if (count <= 0 || !isArrayLike(arr)) {\n    return [];\n  }\n\n  return takeRightToolkit(toArray(arr), count);\n}\n","import { toInteger } from '../compat/util/toInteger.ts';\n\n/**\n * Returns a new array containing the last `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to take elements from.\n * @param {number} [count=1] - The number of elements to take.\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\n *\n * @example\n * // Returns [4, 5]\n * takeRight([1, 2, 3, 4, 5], 2);\n *\n * @example\n * // Returns ['b', 'c']\n * takeRight(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * takeRight([1, 2, 3], 5);\n */\nexport function takeRight<T>(arr: readonly T[], count = 1, guard?: unknown): T[] {\n  count = guard || count === undefined ? 1 : toInteger(count);\n  if (count <= 0 || arr == null || arr.length === 0) {\n    return [];\n  }\n  return arr.slice(-count);\n}\n","import { identity } from '../../function/identity.ts';\nimport { negate } from '../../function/negate.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a slice of array with elements taken from the end. Elements are taken until predicate\n * returns falsey. The predicate is invoked with three arguments: (value, index, array).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {ListIteratee<T>} [predicate] - The function invoked per iteration.\n * @returns {T[]} Returns the slice of array.\n *\n * @example\n * const users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * takeRightWhile(users, function(o) { return !o.active; });\n * // => objects for ['fred', 'pebbles']\n *\n * @example\n * takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n * // => objects for ['pebbles']\n *\n * @example\n * takeRightWhile(users, ['active', false]);\n * // => objects for ['fred', 'pebbles']\n *\n * @example\n * takeRightWhile(users, 'active');\n * // => []\n */\nexport function takeRightWhile<T>(array: ArrayLike<T> | null | undefined, predicate?: ListIteratee<T>): T[];\n\n/**\n * Creates a slice of the array with elements taken from the end while the specified predicate is satisfied.\n * If no predicate is provided, the identity function is used by default.\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {(item: T, index: number, array: T[]) => unknown | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate] - The condition used to determine elements to include. Can be:\n * - A function invoked per iteration.\n * - A partial object to match properties.\n * - A key-value pair as a tuple.\n * - A property key to check for truthy values.\n * Defaults to the identity function if not provided.\n * @returns {T[]} - A slice of the array with elements taken from the end or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = takeRightWhile(items, (item) => item > 3);\n * console.log(result); // [4, 5]\n *\n * // Using a partial object\n * const items2 = [{ id: 10 }, { id: 20 }, { id: 30 }];\n * const result2 = takeRightWhile(items2, { id: 30 });\n * console.log(result2); // [{ id: 30 }]\n *\n * // Using a key-value pair\n * const items3 = [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Alice' }];\n * const result3 = takeRightWhile(items3, ['name', 'Alice']);\n * console.log(result3); // [{ name: 'Alice' }]\n *\n * // Using a property key\n * const items4 = [{ active: false }, { active: true }, { active: true }];\n * const result4 = takeRightWhile(items4, 'active');\n * console.log(result4); // [{ active: true }, { active: true }]\n *\n * // No predicate provided\n * const items5 = [false, true];\n * const result5 = takeRightWhile(items5);\n * console.log(result5); // [true]\n *\n * // null or undefined array\n * const result6 = takeRightWhile(null);\n * console.log(result6); // []\n */\nexport function takeRightWhile<T>(\n  _array: ArrayLike<T> | null | undefined,\n  predicate?:\n    | ((value: T, index: number, array: ArrayLike<T>) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey\n): T[] {\n  if (!isArrayLikeObject(_array)) {\n    return [];\n  }\n\n  const array = toArray(_array);\n  const index = array.findLastIndex(negate(createIteratee(predicate ?? identity)));\n\n  return array.slice(index + 1);\n}\n","/**\n * Creates a function that negates the result of the predicate function.\n *\n * @template F - The type of the function to negate.\n * @param {F} func - The function to negate.\n * @returns {F} The new negated function, which negates the boolean result of `func`.\n *\n * @example\n * const array = [1, 2, 3, 4, 5, 6];\n * const isEven = (n: number) => n % 2 === 0;\n * const result = array.filter(negate(isEven));\n * // result will be [1, 3, 5]\n */\nexport function negate<F extends (...args: any[]) => boolean>(func: F): F {\n  return ((...args: any[]) => !func(...args)) as F;\n}\n","/**\n * Returns the input value unchanged.\n *\n * @template T - The type of the input value.\n * @param {T} x - The value to be returned.\n * @returns {T} The input value.\n *\n * @example\n * // Returns 5\n * identity(5);\n *\n * @example\n * // Returns 'hello'\n * identity('hello');\n *\n * @example\n * // Returns { key: 'value' }\n * identity({ key: 'value' });\n */\nexport function identity<T>(value: T): T;\n\n/**\n * Returns the input value unchanged.\n *\n * @template T - The type of the input value.\n * @param {T} x - The value to be returned.\n * @returns {T} The input value.\n *\n * @example\n * // Returns 5\n * identity(5);\n *\n * @example\n * // Returns 'hello'\n * identity('hello');\n *\n * @example\n * // Returns { key: 'value' }\n * identity({ key: 'value' });\n */\nexport function identity(): undefined;\n\nexport function identity(x?: any): any {\n  return x;\n}\n","import { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { identity } from '../function/identity.ts';\nimport { negate } from '../function/negate.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate\n * returns falsey. The predicate is invoked with three arguments: (value, index, array).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to query.\n * @param {ListIteratee<T>} [predicate] - The function invoked per iteration.\n * @returns {T[]} Returns the slice of array.\n *\n * @example\n * const users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * takeWhile(users, function(o) { return !o.active; });\n * // => objects for ['barney', 'fred']\n *\n * @example\n * takeWhile(users, { 'user': 'barney', 'active': false });\n * // => objects for ['barney']\n *\n * @example\n * takeWhile(users, ['active', false]);\n * // => objects for ['barney', 'fred']\n *\n * @example\n * takeWhile(users, 'active');\n * // => []\n */\nexport function takeWhile<T>(array: ArrayLike<T> | null | undefined, predicate?: ListIteratee<T>): T[];\n\n/**\n * Creates a slice of the array with elements taken from the beginning while the specified predicate is satisfied.\n * If no predicate is provided, the identity function is used by default.\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to process.\n * @param {(item: T, index: number, array: T[]) => unknown | Partial<T> | [keyof T, unknown] | PropertyKey} [predicate] - The condition used to determine elements to include. Can be:\n * - A function invoked per iteration.\n * - A partial object to match properties.\n * - A key-value pair as a tuple.\n * - A property key to check for truthy values.\n * Defaults to the identity function if not provided.\n * @returns {T[]} - A slice of the array with elements taken from the beginning or an empty array if `array` is `null` or `undefined`.\n *\n * @example\n * // Using a predicate function\n * const items = [1, 2, 3, 4, 5];\n * const result = takeWhile(items, (item) => item < 3);\n * console.log(result); // [1, 2]\n *\n * // Using a partial object\n * const items2 = [{ id: 30 }, { id: 20 }, { id: 10 }];\n * const result2 = takeWhile(items2, { id: 30 });\n * console.log(result2); // [{ id: 30 }]\n *\n * // Using a key-value pair\n * const items3 = [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Alice' }];\n * const result3 = takeWhile(items3, ['name', 'Alice']);\n * console.log(result3); // [{ name: 'Alice' }]\n *\n * // Using a property key\n * const items4 = [{ active: true }, { active: true }, { active: false }];\n * const result4 = takeWhile(items4, 'active');\n * console.log(result4); // [{ active: true }, { active: true }]\n *\n * // No predicate provided\n * const items5 = [true, false];\n * const result5 = takeWhile(items5);\n * console.log(result5); // [true]\n *\n * // null or undefined array\n * const result6 = takeWhile(null);\n * console.log(result6); // []\n **/\nexport function takeWhile<T>(\n  array: ArrayLike<T> | null | undefined,\n  predicate?:\n    | ((value: T, index: number, array: ArrayLike<T>) => unknown)\n    | Partial<T>\n    | [keyof T, unknown]\n    | PropertyKey\n): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  const _array = toArray(array);\n  const index = _array.findIndex(negate(iteratee(predicate ?? identity)));\n\n  return index === -1 ? _array : _array.slice(0, index);\n}\n","import { flattenDepth } from './flattenDepth.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * This function takes multiple arrays and returns a new array containing only the unique values\n * from all input arrays, preserving the order of their first occurrence.\n *\n * @template T - The type of elements in the arrays.\n * @param {Array<ArrayLike<T> | null | undefined>} arrays - The arrays to inspect.\n * @returns {T[]} Returns the new array of combined unique values.\n *\n * @example\n * // Returns [2, 1]\n * union([2], [1, 2]);\n *\n * @example\n * // Returns [2, 1, 3]\n * union([2], [1, 2], [2, 3]);\n *\n * @example\n * // Returns [1, 3, 2, [5], [4]] (does not deeply flatten nested arrays)\n * union([1, 3, 2], [1, [5]], [2, [4]]);\n *\n * @example\n * // Returns [0, 2, 1] (ignores non-array values like 3 and { '0': 1 })\n * union([0], 3, { '0': 1 }, null, [2, 1]);\n * @example\n * // Returns [0, 'a', 2, 1] (treats array-like object { 0: 'a', length: 1 } as a valid array)\n * union([0], { 0: 'a', length: 1 }, [2, 1]);\n */\nexport function union<T>(...arrays: Array<ArrayLike<T> | null | undefined>): T[];\n\n/**\n * This function takes multiple arrays and returns a new array containing only the unique values\n * from all input arrays, preserving the order of their first occurrence.\n *\n * @template T - The type of elements in the arrays.\n * @param {Array<ArrayLike<T> | null | undefined>} arrays - The arrays to inspect.\n * @returns {T[]} Returns the new array of combined unique values.\n *\n * @example\n * // Returns [2, 1]\n * union([2], [1, 2]);\n *\n * @example\n * // Returns [2, 1, 3]\n * union([2], [1, 2], [2, 3]);\n *\n * @example\n * // Returns [1, 3, 2, [5], [4]] (does not deeply flatten nested arrays)\n * union([1, 3, 2], [1, [5]], [2, [4]]);\n *\n * @example\n * // Returns [0, 2, 1] (ignores non-array values like 3 and { '0': 1 })\n * union([0], 3, { '0': 1 }, null, [2, 1]);\n * @example\n * // Returns [0, 'a', 2, 1] (treats array-like object { 0: 'a', length: 1 } as a valid array)\n * union([0], { 0: 'a', length: 1 }, [2, 1]);\n */\nexport function union<T>(...arrays: Array<ArrayLike<T> | null | undefined>): T[] {\n  const validArrays = arrays.filter(isArrayLikeObject);\n\n  const flattened = flattenDepth(validArrays as any, 1);\n\n  return uniq(flattened) as T[];\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the mapper function.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr - The array to process.\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\n *\n * @example\n * ```ts\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\n * // [1.2, 2.1, 3.2, 5.7, 7.19]\n * ```\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' },\n * ];\n * uniqBy(array, item => item.category).length\n * // 2\n * ```\n */\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","import { last } from '../../array/last.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { uniqBy } from '../../array/uniqBy.ts';\nimport { flattenArrayLike } from '../_internal/flattenArrayLike.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\ntype Iteratee<T> = PropertyKey | Partial<T> | ((value: T) => unknown);\n\n/**\n * This method is like `union` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The arrays to inspect.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionBy([2.1], [1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * @example\n * unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nexport function unionBy<T>(arrays: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\n\n/**\n * This method is like `union` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays1 - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionBy([2.1], [1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n */\nexport function unionBy<T>(\n  arrays1: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIteratee<T>\n): T[];\n\n/**\n * This method is like `union` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays1 - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays3 - The third array to inspect.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionBy([2.1], [1.2, 2.3], [3.4], Math.floor);\n * // => [2.1, 1.2, 3.4]\n */\nexport function unionBy<T>(\n  arrays1: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  arrays3: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIteratee<T>\n): T[];\n\n/**\n * This method is like `union` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays1 - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays3 - The third array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays4 - The fourth array to inspect.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionBy([2.1], [1.2, 2.3], [3.4], [4.5], Math.floor);\n * // => [2.1, 1.2, 3.4, 4.5]\n */\nexport function unionBy<T>(\n  arrays1: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  arrays3: ArrayLike<T> | null | undefined,\n  arrays4: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIteratee<T>\n): T[];\n\n/**\n * This method is like `union` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays1 - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays3 - The third array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays4 - The fourth array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays5 - The fifth array to inspect.\n * @param {...Array<ValueIteratee<T> | ArrayLike<T> | null | undefined>} iteratee - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionBy([2.1], [1.2, 2.3], [3.4], [4.5], [5.6], Math.floor);\n * // => [2.1, 1.2, 3.4, 4.5, 5.6]\n */\nexport function unionBy<T>(\n  arrays1: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  arrays3: ArrayLike<T> | null | undefined,\n  arrays4: ArrayLike<T> | null | undefined,\n  arrays5: ArrayLike<T> | null | undefined,\n  ...iteratee: Array<ValueIteratee<T> | ArrayLike<T> | null | undefined>\n): T[];\n\n/**\n * This function takes multiple arrays and returns a new array containing only the unique values\n * from all input arrays, preserving the order of their first occurrence.\n * An iteratee function can be provided for comparison and it output values from the first possible array\n *\n * @template T - The type of elements in the arrays.\n * @param {...(ArrayLike<T> | null | undefined | Iteratee<T>)} values - The arrays to inspect, or the iteratee function.\n * @returns {T[]} Returns the new array of combined unique values.\n *\n * @example\n * // Returns [2.1, 1.2]\n * unionBy([2.1], [1.2, 2.3], Math.floor);\n *\n * @example\n * // Returns [{ x: 1 }, { x: 2 }]\n * unionBy([{ x: 1 }], [{ x: 2 }, { x: 1 }], 'x');\n *\n * @example\n * // Returns [{ x: 1, y: 1 }]\n * unionBy([{ x: 1, y: 1 }], [{ x: 1, y: 2 }], 'x');\n */\n\nexport function unionBy<T>(...values: Array<ArrayLike<T> | null | undefined | Iteratee<T>>): T[] {\n  const lastValue = last(values);\n  const flattened = flattenArrayLike(values as Array<ArrayLike<T>>);\n\n  if (isArrayLikeObject(lastValue) || lastValue == null) {\n    return uniq(flattened);\n  }\n\n  return uniqBy(flattened, iteratee(lastValue));\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the comparator function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\n *\n * @example\n * ```ts\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\n * // [1.2, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const isUniq = result.every(v => !areItemsEqual(v, item));\n\n    if (isUniq) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","import { last } from '../../array/last.ts';\nimport { uniq } from '../../array/uniq.ts';\nimport { uniqWith } from '../../array/uniqWith.ts';\nimport { flattenArrayLike } from '../_internal/flattenArrayLike.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * This method is like `union` except that it accepts `comparator` which\n * is invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The arrays to inspect.\n * @param {(a: T, b: T) => boolean} [comparator] - The comparator invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * const others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n * unionWith(objects, others, isEqual);\n * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n */\nexport function unionWith<T>(arrays: ArrayLike<T> | null | undefined, comparator?: (a: T, b: T) => boolean): T[];\n\n/**\n * This method is like `union` except that it accepts `comparator` which\n * is invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {(a: T, b: T) => boolean} [comparator] - The comparator invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionWith([1, 2], [2, 3], (a, b) => a === b);\n * // => [1, 2, 3]\n */\nexport function unionWith<T>(\n  arrays: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  comparator?: (a: T, b: T) => boolean\n): T[];\n\n/**\n * This method is like `union` except that it accepts `comparator` which\n * is invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays3 - The third array to inspect.\n * @param {...Array<(a: T, b: T) => boolean | ArrayLike<T> | null | undefined>} comparator - The comparator invoked per element.\n * @returns {T[]} Returns the new array of combined values.\n *\n * @example\n * unionWith([1], [2], [3], (a, b) => a === b);\n * // => [1, 2, 3]\n */\nexport function unionWith<T>(\n  arrays: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  arrays3: ArrayLike<T> | null | undefined,\n  ...comparator: Array<((a: T, b: T) => boolean) | ArrayLike<T> | null | undefined>\n): T[];\n\n/**\n * This function takes multiple arrays and returns a new array containing only the unique values\n * from all input arrays, preserving the order of their first occurrence.\n * A comparator function can be provided for comparison and it output values from the first possible array\n *\n * @template T - The type of elements in the arrays.\n * @param {...(ArrayLike<T> | null | undefined | Comparator<T, U>)} values - The arrays to inspect, or the comparator function.\n * @returns {T[]} Returns the new array of combined unique values.\n *\n * @example\n * const objects = [\n *   { x: 1, y: 2 },\n *   { x: 2, y: 1 },\n * ];\n * const others = [\n *   { x: 1, y: 1 },\n *   { x: 1, y: 2 },\n * ];\n * // Returns [objects[0], objects[1], others[0]]\n * unionWith(objects, others, isEqual);\n *\n * @example\n * const objects = [{ x: 1, y: 1 }];\n * const others = [{ x: 1, y: 2 }];\n * // Returns [{ x: 1, y: 1 }]\n * unionWith(objects, others, (a, b) => a.x === b.x);\n */\n\nexport function unionWith<T>(...values: Array<ArrayLike<T> | null | undefined | ((a: T, b: T) => boolean)>): T[] {\n  const lastValue = last(values);\n  const flattened = flattenArrayLike(values as Array<ArrayLike<T>>);\n\n  if (isArrayLikeObject(lastValue) || lastValue == null) {\n    return uniq(flattened);\n  }\n\n  return uniqWith(flattened, lastValue);\n}\n","import { uniqBy as uniqByToolkit } from '../../array/uniqBy.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a duplicate-free version of an array, using an optional transform function.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} array - The array to inspect.\n * @param {ValueIteratee<T>} iteratee - The transform function or property name to get values from.\n * @returns {T[]} Returns the new duplicate-free array.\n *\n * @example\n * uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n */\nexport function uniqBy<T>(array: ArrayLike<T> | null | undefined, iteratee: ValueIteratee<T>): T[];\nexport function uniqBy<T>(\n  array: ArrayLike<T> | null | undefined,\n  iteratee: ((value: T) => unknown) | PropertyKey | [keyof T, unknown] | Partial<T> = identity\n): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n\n  return uniqByToolkit(Array.from(array), createIteratee(iteratee));\n}\n","import { uniqWith as uniqWithToolkit } from '../../array/uniqWith.ts';\nimport { uniq as uniqToolkit } from '../array/uniq.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\ntype Comparator<T> = (a: T, b: T) => boolean;\n\n/**\n * This method is like `uniq`, except that it accepts a `comparator` which is used to determine the equality of elements.\n *\n * It creates a duplicate-free version of an array, in which only the first occurrence of each element is kept.\n * If a `comparator` is provided, it will be invoked with two arguments: `(arrVal, othVal)` to compare elements.\n * If no comparator is provided, shallow equality is used.\n *\n * The order of result values is determined by the order they appear in the input array.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr  - The array to process.\n * @param {Comparator<T>} [comparator] - Optional function to compare elements for equality.\n * @returns {T[]} A new array with only unique values based on the comparator.\n *\n * @example\n * const array = [1, 2, 2, 3];\n * const result = uniqWith(array);\n * // result will be [1, 2, 3]\n *\n * const array = [1, 2, 3];\n * const result = uniqWith(array, (a, b) => a % 2 === b % 2)\n * // result will be [1, 2]\n */\nexport function uniqWith<T>(arr: ArrayLike<T> | null | undefined, comparator?: Comparator<T>): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  return typeof comparator === 'function' ? uniqWithToolkit(Array.from(arr), comparator) : uniqToolkit(Array.from(arr));\n}\n","/**\n * Gathers elements in the same position in an internal array\n * from a grouped array of elements and returns them as a new array.\n *\n * @template T - The type of elements in the nested array.\n * @param {Array<[...T]>} zipped - The nested array to unzip.\n * @returns {Unzip<T>} A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T extends unknown[]>(zipped: ReadonlyArray<[...T]>): Unzip<T> {\n  // For performance reasons, use this implementation instead of\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\n  let maxLen = 0;\n\n  for (let i = 0; i < zipped.length; i++) {\n    if (zipped[i].length > maxLen) {\n      maxLen = zipped[i].length;\n    }\n  }\n\n  const result = new Array(maxLen) as Unzip<T>;\n\n  for (let i = 0; i < maxLen; i++) {\n    result[i] = new Array(zipped.length);\n    for (let j = 0; j < zipped.length; j++) {\n      result[i][j] = zipped[j][i];\n    }\n  }\n\n  return result;\n}\n\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\n","import { unzip as unzipToolkit } from '../../array/unzip.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Gathers elements in the same position in an internal array\n * from a grouped array of elements and returns them as a new array.\n *\n * @template T - The type of elements in the nested array.\n * @param {T[][] | ArrayLike<ArrayLike<T>> | null | undefined} array - The nested array to unzip.\n * @returns {T[][]} A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T>(array: T[][] | ArrayLike<ArrayLike<T>> | null | undefined): T[][] {\n  if (!isArrayLikeObject(array) || !array.length) {\n    return [];\n  }\n  array = isArray(array) ? array : Array.from(array);\n  array = (array as T[][]).filter(item => isArrayLikeObject(item));\n  return unzipToolkit(array as T[][]);\n}\n","import { unzip as unzipToolkit } from '../../array/unzip.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * This method is like `unzip` except that it accepts an iteratee to specify\n * how regrouped values should be combined. The iteratee is invoked with the\n * elements of each group: (...group).\n *\n * @template T, R\n * @param {ArrayLike<ArrayLike<T>> | null | undefined} array - The array of grouped elements to process.\n * @param {(...values: T[]) => R} iteratee - The function to combine regrouped values.\n * @returns {R[]} Returns the new array of regrouped elements.\n *\n * @example\n * unzipWith([[1, 10, 100], [2, 20, 200]], (a, b) => a + b);\n * // => [3, 30, 300]\n */\nexport function unzipWith<T, R>(\n  array: ArrayLike<ArrayLike<T>> | null | undefined,\n  iteratee: (...values: T[]) => R\n): R[];\n\n/**\n * This method is like `unzip` except that it accepts an iteratee to specify\n * how regrouped values should be combined.\n *\n * @template T\n * @param {ArrayLike<ArrayLike<T>> | null | undefined} array - The array of grouped elements to process.\n * @returns {T[][]} Returns the new array of regrouped elements.\n *\n * @example\n * unzipWith([[1, 10, 100], [2, 20, 200]]);\n * // => [[1, 2], [10, 20], [100, 200]]\n */\nexport function unzipWith<T>(array: ArrayLike<ArrayLike<T>> | null | undefined): T[][];\n\n/**\n * Unzips an array of arrays, applying an `iteratee` function to regrouped elements.\n *\n * If the array is `null` or `undefined`, returns an empty array.\n *\n * @template T\n * @param {T[][] | ArrayLike<ArrayLike<T>> | null | undefined} array - The nested array to unzip. This is an array of arrays,\n * where each inner array contains elements to be unzipped.\n * @param {(...args: any[]) => unknown} iteratee - A function to transform the unzipped elements.\n * @returns {any[]} A new array of unzipped and transformed elements.\n *\n * @example\n * const nestedArray = [[1, 2], [3, 4], [5, 6]];\n * const result = unzipWith(nestedArray, (a, b) => a + b);\n * console.log(result); // [9, 12]\n */\nexport function unzipWith<T>(\n  array: T[][] | ArrayLike<ArrayLike<T>> | null | undefined,\n  iteratee?: ((...args: any[]) => unknown) | null\n): any[] {\n  if (!isArrayLikeObject(array) || !array.length) {\n    return [];\n  }\n\n  const unziped = isArray(array) ? unzipToolkit(array) : unzipToolkit(Array.from(array, value => Array.from(value)));\n\n  if (!iteratee) {\n    return unziped;\n  }\n\n  const result: any[] = new Array(unziped.length);\n\n  for (let i = 0; i < unziped.length; i++) {\n    const value = unziped[i];\n\n    result[i] = iteratee(...value);\n  }\n\n  return result;\n}\n","import { without as withoutToolkit } from '../../array/without.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Creates an array that excludes all specified values.\n *\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\n *\n * @template T The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} array - The array to filter.\n * @param {...T[]} values - The values to exclude.\n * @returns {T[]} A new array without the specified values.\n *\n * @example\n * // Removes the specified values from the array\n * without([1, 2, 3, 4, 5], 2, 4);\n * // Returns: [1, 3, 5]\n *\n * @example\n * // Removes specified string values from the array\n * without(['a', 'b', 'c', 'a'], 'a');\n * // Returns: ['b', 'c']\n */\nexport function without<T>(array: ArrayLike<T> | null | undefined, ...values: T[]): T[] {\n  if (!isArrayLikeObject(array)) {\n    return [];\n  }\n  return withoutToolkit(Array.from(array), ...values);\n}\n","import { difference } from './difference.ts';\n\n/**\n * Creates an array that excludes all specified values.\n *\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\n *\n * @template T The type of elements in the array.\n * @param {T[]} array - The array to filter.\n * @param {...T[]} values - The values to exclude.\n * @returns {T[]} A new array without the specified values.\n *\n * @example\n * // Removes the specified values from the array\n * without([1, 2, 3, 4, 5], 2, 4);\n * // Returns: [1, 3, 5]\n *\n * @example\n * // Removes specified string values from the array\n * without(['a', 'b', 'c', 'a'], 'a');\n * // Returns: ['b', 'c']\n */\nexport function without<T>(array: readonly T[], ...values: T[]): T[] {\n  return difference(array, values);\n}\n","import { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { toArray } from '../util/toArray.ts';\n\n/**\n * Computes the symmetric difference of the provided arrays, returning an array of elements\n * that exist in only one of the arrays.\n *\n * @template T - The type of elements in the arrays.\n * @param {...(ArrayLike<T> | null | undefined)} arrays - The arrays to compare.\n * @returns {T[]} An array containing the elements that are present in only one of the provided `arrays`.\n *\n * @example\n * // Returns [1, 2, 5, 6]\n * xor([1, 2, 3, 4], [3, 4, 5, 6]);\n *\n * @example\n * // Returns ['a', 'c']\n * xor(['a', 'b'], ['b', 'c']);\n *\n * @example\n * // Returns [1, 3, 5]\n * xor([1, 2], [2, 3], [4, 5]);\n */\nexport function xor<T>(...arrays: Array<ArrayLike<T> | null | undefined>): T[] {\n  const itemCounts: Map<T, number> = new Map();\n\n  for (let i = 0; i < arrays.length; i++) {\n    const array = arrays[i];\n\n    if (!isArrayLikeObject(array)) {\n      continue;\n    }\n\n    const itemSet = new Set(toArray(array));\n\n    for (const item of itemSet) {\n      if (!itemCounts.has(item)) {\n        itemCounts.set(item, 1);\n      } else {\n        itemCounts.set(item, itemCounts.get(item)! + 1);\n      }\n    }\n  }\n\n  const result: T[] = [];\n\n  for (const [item, count] of itemCounts) {\n    if (count === 1) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","/**\n * Options for the windowed function.\n *\n * @interface WindowedOptions\n * @property {boolean} [partialWindows=false] - Whether to include partial windows at the end of the array.\n */\nexport interface WindowedOptions {\n  /**\n   * Whether to include partial windows at the end of the array.\n   *\n   * By default, `windowed` only includes full windows in the result,\n   * ignoring any leftover elements that can't form a full window.\n   *\n   * If `partialWindows` is true, the function will also include these smaller, partial windows at the end of the result.\n   */\n  partialWindows?: boolean;\n}\n\n/**\n * Creates an array of sub-arrays (windows) from the input array, each of the specified size.\n * The windows can overlap depending on the step size provided.\n *\n * By default, only full windows are included in the result, and any leftover elements that can't form a full window are ignored.\n *\n * If the `partialWindows` option is set to true in the options object, the function will also include partial windows at the end of the result.\n * Partial windows are smaller sub-arrays created when there aren't enough elements left in the input array to form a full window.\n *\n * @template T\n * @param {readonly T[]} arr - The input array to create windows from.\n * @param {number} size - The size of each window. Must be a positive integer.\n * @param {number} [step=1] - The step size between the start of each window. Must be a positive integer.\n * @param {WindowedOptions} [options={}] - Options object to configure the behavior of the function.\n * @param {boolean} [options.partialWindows=false] - Whether to include partial windows at the end of the array.\n * @returns {T[][]} An array of windows (sub-arrays) created from the input array.\n * @throws {Error} If the size or step is not a positive integer.\n *\n * @example\n * windowed([1, 2, 3, 4], 2);\n * // => [[1, 2], [2, 3], [3, 4]]\n *\n * @example\n * windowed([1, 2, 3, 4, 5, 6], 3, 2);\n * // => [[1, 2, 3], [3, 4, 5]]\n *\n * @example\n * windowed([1, 2, 3, 4, 5, 6], 3, 2, { partialWindows: true });\n * // => [[1, 2, 3], [3, 4, 5], [5, 6]]\n */\nexport function windowed<T>(\n  arr: readonly T[],\n  size: number,\n  step = 1,\n  { partialWindows = false }: WindowedOptions = {}\n): T[][] {\n  if (size <= 0 || !Number.isInteger(size)) {\n    throw new Error('Size must be a positive integer.');\n  }\n\n  if (step <= 0 || !Number.isInteger(step)) {\n    throw new Error('Step must be a positive integer.');\n  }\n\n  const result: T[][] = [];\n  const end = partialWindows ? arr.length : arr.length - size + 1;\n\n  for (let i = 0; i < end; i += step) {\n    result.push(arr.slice(i, i + size));\n  }\n\n  return result;\n}\n","import { differenceBy } from './differenceBy.ts';\nimport { intersectionBy } from './intersectionBy.ts';\nimport { last } from './last.ts';\nimport { unionBy } from './unionBy.ts';\nimport { windowed } from '../../array/windowed.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * This method is like `xor` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The arrays to inspect.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of values.\n *\n * @example\n * xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n * // => [1.2, 4.3]\n *\n * @example\n * xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 2 }]\n */\nexport function xorBy<T>(arrays: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\n\n/**\n * This method is like `xor` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ValueIteratee<T>} [iteratee] - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of values.\n *\n * @example\n * xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n * // => [1.2, 4.3]\n */\nexport function xorBy<T>(\n  arrays: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  iteratee?: ValueIteratee<T>\n): T[];\n\n/**\n * This method is like `xor` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays3 - The third array to inspect.\n * @param {...Array<ValueIteratee<T> | ArrayLike<T> | null | undefined>} iteratee - The iteratee invoked per element.\n * @returns {T[]} Returns the new array of values.\n *\n * @example\n * xorBy([1.2, 2.3], [3.4, 4.5], [5.6, 6.7], Math.floor);\n * // => [1.2, 3.4, 5.6]\n */\nexport function xorBy<T>(\n  arrays: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  arrays3: ArrayLike<T> | null | undefined,\n  ...iteratee: Array<ValueIteratee<T> | ArrayLike<T> | null | undefined>\n): T[];\n\n/**\n * Computes the symmetric difference between two arrays using a custom mapping function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection, determined by the result of the mapping function.\n *\n * @template T - Type of elements in the input arrays.\n * @template U - Type of the values returned by the mapping function.\n *\n * @param {...(ArrayLike<T> | null | undefined | PropertyKey | Partial<T> | ((value: T) => unknown))} values - The arrays to inspect, or the function to map array elements to comparison values.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = obj => obj.id;\n * xorBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorBy<T>(...values: Array<ArrayLike<T> | null | undefined | ValueIteratee<T>>): T[] {\n  const lastValue = last(values);\n\n  let mapper = identity;\n\n  if (!isArrayLikeObject(lastValue) && lastValue != null) {\n    mapper = iteratee(lastValue);\n    values = values.slice(0, -1);\n  }\n\n  const arrays = values.filter(isArrayLikeObject) as [any];\n\n  const union = unionBy(...arrays, mapper);\n  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionBy(arr1, arr2, mapper)) as [any];\n\n  return differenceBy(union, unionBy(...intersections, mapper), mapper) as T[];\n}\n","import { differenceWith } from './differenceWith.ts';\nimport { intersectionWith } from './intersectionWith.ts';\nimport { last } from './last.ts';\nimport { unionWith } from './unionWith.ts';\nimport { windowed } from '../../array/windowed.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * This method is like `xor` except that it accepts `comparator` which is\n * invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The arrays to inspect.\n * @param {(a: T, b: T) => boolean} [comparator] - The comparator invoked per element.\n * @returns {T[]} Returns the new array of values.\n *\n * @example\n * const objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n * const others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n * xorWith(objects, others, isEqual);\n * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n */\nexport function xorWith<T>(arrays: ArrayLike<T> | null | undefined, comparator?: (a: T, b: T) => boolean): T[];\n\n/**\n * This method is like `xor` except that it accepts `comparator` which is\n * invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {(a: T, b: T) => boolean} [comparator] - The comparator invoked per element.\n * @returns {T[]} Returns the new array of values.\n *\n * @example\n * xorWith([1, 2], [2, 3], (a, b) => a === b);\n * // => [1, 3]\n */\nexport function xorWith<T>(\n  arrays: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  comparator?: (a: T, b: T) => boolean\n): T[];\n\n/**\n * This method is like `xor` except that it accepts `comparator` which is\n * invoked to compare elements of `arrays`. The comparator is invoked\n * with two arguments: (arrVal, othVal).\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} arrays - The first array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays2 - The second array to inspect.\n * @param {ArrayLike<T> | null | undefined} arrays3 - The third array to inspect.\n * @param {...Array<(a: T, b: T) => boolean | ArrayLike<T> | null | undefined>} comparator - The comparator invoked per element.\n * @returns {T[]} Returns the new array of values.\n *\n * @example\n * xorWith([1], [2], [3], (a, b) => a === b);\n * // => [1, 2, 3]\n */\nexport function xorWith<T>(\n  arrays: ArrayLike<T> | null | undefined,\n  arrays2: ArrayLike<T> | null | undefined,\n  arrays3: ArrayLike<T> | null | undefined,\n  ...comparator: Array<((a: T, b: T) => boolean) | ArrayLike<T> | null | undefined>\n): T[];\n\n/**\n * Creates an array of unique values that is the symmetric difference of the given arrays using a custom comparator function.\n *\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection, determined by the comparator function.\n *\n * @template T - Type of elements in the input arrays.\n *\n * @param {...(ArrayLike<T> | null | undefined | ((a: T, b: T) => boolean))} values - The arrays to inspect, or the comparator function.\n * @returns {T[]} An array containing the elements that are present in exactly one of the arrays\n *  as determined by the comparator.\n *\n * @example\n * // Custom comparator function for objects with an 'id' property\n * const idComparator = (a, b) => a.id === b.id;\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idComparator);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorWith<T>(...values: Array<ArrayLike<T> | null | undefined | ((a: T, b: T) => boolean)>): T[] {\n  const lastValue = last(values);\n\n  let comparator = (a: T, b: T) => a === b;\n\n  if (typeof lastValue === 'function') {\n    comparator = lastValue as (a: T, b: T) => boolean;\n    values = values.slice(0, -1);\n  }\n\n  const arrays = values.filter(isArrayLikeObject) as T[][];\n\n  // eslint-disable-next-line\n  // @ts-ignore\n  const union = unionWith(...arrays, comparator);\n  const intersections = windowed(arrays, 2).map(([arr1, arr2]) => intersectionWith(arr1, arr2, comparator));\n\n  // eslint-disable-next-line\n  // @ts-ignore\n  return differenceWith(union, unionWith(...intersections, comparator), comparator);\n}\n","/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {T[]} arr1 - The first array to zip.\n * @returns {Array<[T]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = zip(arr1);\n * // result will be [[1], [2], [3]]\n */\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @returns {Array<[T, U]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n */\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @returns {Array<[T, U, V]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @param {W[]} arr4 - The fourth array to zip.\n * @returns {Array<[T, U, V, W]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const result = zip(arr1, arr2, arr3, arr4);\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\n */\nexport function zip<T, U, V, W>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[]\n): Array<[T, U, V, W]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {...Array<readonly T[]>} arrs - The arrays to zip together.\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][];\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {...Array<readonly T[]>} arrs - The arrays to zip together.\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\n  // For performance reasons, use this implementation instead of\n  // const rowCount = Math.max(...arrs.map(x => x.length));\n  let rowCount = 0;\n\n  for (let i = 0; i < arrs.length; i++) {\n    if (arrs[i].length > rowCount) {\n      rowCount = arrs[i].length;\n    }\n  }\n  const columnCount = arrs.length;\n  const result = Array(rowCount);\n\n  for (let i = 0; i < rowCount; ++i) {\n    const row = Array(columnCount);\n    for (let j = 0; j < columnCount; ++j) {\n      row[j] = arrs[j][i];\n    }\n    result[i] = row;\n  }\n  return result;\n}\n","import { zip as zipToolkit } from '../../array/zip.ts';\nimport { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @returns {Array<[T | undefined, U | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n */\n/**\n * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n * the second of which contains the second elements of the given arrays, and so on.\n *\n * @template T, U\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @returns {Array<[T | undefined, U | undefined]>} Returns the new array of grouped elements.\n *\n * @example\n * zip([1, 2], ['a', 'b']);\n * // => [[1, 'a'], [2, 'b']]\n */\nexport function zip<T, U>(arr1: ArrayLike<T>, arr2: ArrayLike<U>): Array<[T | undefined, U | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\n/**\n * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n * the second of which contains the second elements of the given arrays, and so on.\n *\n * @template T, U, V\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined]>} Returns the new array of grouped elements.\n *\n * @example\n * zip([1, 2], ['a', 'b'], [true, false]);\n * // => [[1, 'a', true], [2, 'b', false]]\n */\nexport function zip<T, U, V>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>\n): Array<[T | undefined, U | undefined, V | undefined]>;\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined, W | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const result = zip(arr1, arr2, arr3, arr4);\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\n */\n/**\n * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n * the second of which contains the second elements of the given arrays, and so on.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined, W | undefined]>} Returns the new array of grouped elements.\n *\n * @example\n * zip([1], ['a'], [true], [null]);\n * // => [[1, 'a', true, null]]\n */\nexport function zip<T, U, V, W>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  arr4: ArrayLike<W>\n): Array<[T | undefined, U | undefined, V | undefined, W | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @param {ArrayLike<X>} arr5 - The fifth array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined, W | undefined, X | undefined]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const arr5 = [undefined, undefined, undefined];\n * const result = zip(arr1, arr2, arr3, arr4, arr5);\n * // result will be [[1, 'a', true, null, undefined], [2, 'b', false, null, undefined], [3, 'c', undefined, null, undefined]]\n */\n/**\n * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n * the second of which contains the second elements of the given arrays, and so on.\n *\n * @template T, U, V, W, X\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @param {ArrayLike<X>} arr5 - The fifth array to zip.\n * @returns {Array<[T | undefined, U | undefined, V | undefined, W | undefined, X | undefined]>} Returns the new array of grouped elements.\n *\n * @example\n * zip([1], ['a'], [true], [null], [undefined]);\n * // => [[1, 'a', true, null, undefined]]\n */\nexport function zip<T, U, V, W, X>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  arr4: ArrayLike<W>,\n  arr5: ArrayLike<X>\n): Array<[T | undefined, U | undefined, V | undefined, W | undefined, X | undefined]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {Array<ArrayLike<any> | null | undefined>} arrays - The arrays to zip.\n * @returns {Array<Array<T | undefined>>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const arr5 = [undefined, undefined, undefined];\n * const result = zip(arr1, arr2, arr3, arr4, arr5);\n * // result will be [[1, 'a', true, null, undefined], [2, 'b', false, null, undefined], [3, 'c', undefined, null, undefined]]\n */\n/**\n * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\n * the second of which contains the second elements of the given arrays, and so on.\n *\n * @template T\n * @param {...Array<ArrayLike<T> | null | undefined>} arrays - The arrays to process.\n * @returns {Array<Array<T | undefined>>} Returns the new array of grouped elements.\n *\n * @example\n * zip([1, 2], ['a', 'b'], [true, false]);\n * // => [[1, 'a', true], [2, 'b', false]]\n */\nexport function zip<T>(...arrays: Array<ArrayLike<T> | null | undefined>): Array<Array<T | undefined>>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {Array<ArrayLike<any> | null | undefined>} arrays - The arrays to zip.\n * @returns {Array<Array<T | undefined>>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const arr5 = [undefined, undefined, undefined];\n * const result = zip(arr1, arr2, arr3, arr4, arr5);\n * // result will be [[1, 'a', true, null, undefined], [2, 'b', false, null, undefined], [3, 'c', undefined, null, undefined]]\n */\nexport function zip<T>(...arrays: Array<ArrayLike<any> | null | undefined>): Array<Array<T | undefined>> {\n  if (!arrays.length) {\n    return [];\n  }\n  // @ts-expect-error - TS doesn't support array types with a spread operator\n  return zipToolkit(...arrays.filter(group => isArrayLikeObject(group)));\n}\n","import { eq } from '../util/eq.ts';\n\nexport const assignValue = (object: any, key: PropertyKey, value: any): void => {\n  const objValue = object[key];\n  if (!(Object.hasOwn(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n};\n","import { assignValue } from '../_internal/assignValue.ts';\n\n/**\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\n *\n * @template T - The type of values in the values array\n * @param {ArrayLike<PropertyKey>} props - An array of property names\n * @param {ArrayLike<T>} values - An array of values corresponding to the property names\n * @returns {Record<string, T>} A new object composed of the given property names and values\n *\n * @example\n * const props = ['a', 'b', 'c'];\n * const values = [1, 2, 3];\n * zipObject(props, values);\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function zipObject<T>(props: ArrayLike<PropertyKey>, values: ArrayLike<T>): Record<string, T>;\n\n/**\n * Creates an object from an array of property names, with undefined values.\n *\n * @param {ArrayLike<PropertyKey>} [props] - An array of property names\n * @returns {Record<string, undefined>} A new object with the given property names and undefined values\n *\n * @example\n * const props = ['a', 'b', 'c'];\n * zipObject(props);\n * // => { a: undefined, b: undefined, c: undefined }\n */\nexport function zipObject(props?: ArrayLike<PropertyKey>): Record<string, undefined>;\n\n/**\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\n *\n * This function takes two arrays: one containing property names and another containing corresponding values.\n * It returns a new object where the property names from the first array are keys, and the corresponding elements\n * from the second array are values. If the `keys` array is longer than the `values` array, the remaining keys will\n * have `undefined` as their values.\n *\n * @template P - The type of elements in the array.\n * @template V - The type of elements in the array.\n * @param {ArrayLike<K>} keys - An array of property names.\n * @param {ArrayLike<V>} values - An array of values corresponding to the property names.\n * @returns {Record<K, V>} - A new object composed of the given property names and values.\n *\n * @example\n * const keys = ['a', 'b', 'c'];\n * const values = [1, 2, 3];\n * const result = zipObject(keys, values);\n * // result will be { a: 1, b: 2, c: 3 }\n *\n * const keys2 = ['a', 'b', 'c'];\n * const values2 = [1, 2];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2, c: undefined }\n *\n * const keys2 = ['a', 'b'];\n * const values2 = [1, 2, 3];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2 }\n */\nexport function zipObject<K extends PropertyKey, V>(keys: ArrayLike<K> = [], values: ArrayLike<V> = []): Record<K, V> {\n  const result = {} as Record<K, V>;\n\n  for (let i = 0; i < keys.length; i++) {\n    assignValue(result, keys[i], values[i]);\n  }\n\n  return result;\n}\n","import { isUnsafeProperty } from '../../_internal/isUnsafeProperty.ts';\nimport { assignValue } from '../_internal/assignValue.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { isKey } from '../_internal/isKey.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Updates the value at the specified path of the given object using an updater function and a customizer.\n * If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} object - The object to modify.\n * @param {PropertyPath} path - The path of the property to update.\n * @param {(oldValue: any) => any} updater - The function to produce the updated value.\n * @param {(value: any, key: string, object: T) => any} customizer - The function to customize the update process.\n * @returns {T} - The modified object.\n *\n * @example\n * const object = { 'a': [{ 'b': { 'c': 3 } }] };\n * updateWith(object, 'a[0].b.c', (n) => n * n);\n * // => { 'a': [{ 'b': { 'c': 9 } }] }\n */\nexport function updateWith<T extends object>(\n  object: T,\n  path: PropertyPath,\n  updater: (oldValue: any) => any,\n  customizer?: (value: any, key: string, object: T) => any\n): T;\n\n/**\n * Updates the value at the specified path of the given object using an updater function and a customizer.\n * If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @template R - The type of the return value.\n * @param {T} object - The object to modify.\n * @param {PropertyPath} path - The path of the property to update.\n * @param {(oldValue: any) => any} updater - The function to produce the updated value.\n * @param {(value: any, key: string, object: T) => any} customizer - The function to customize the update process.\n * @returns {R} - The modified object.\n *\n * @example\n * const object = { 'a': [{ 'b': { 'c': 3 } }] };\n * updateWith(object, 'a[0].b.c', (n) => n * n);\n * // => { 'a': [{ 'b': { 'c': 9 } }] }\n */\nexport function updateWith<T extends object, R>(\n  object: T,\n  path: PropertyPath,\n  updater: (oldValue: any) => any,\n  customizer?: (value: any, key: string, object: T) => any\n): R;\n\n/**\n * Updates the value at the specified path of the given object using an updater function and a customizer.\n * If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @template R - The type of the return value.\n * @param {T} obj - The object to modify.\n * @param {PropertyPath} path - The path of the property to update.\n * @param {(value: any) => any} updater - The function to produce the updated value.\n * @param {(value: any, key: string, object: T) => any} customizer - The function to customize the update process.\n * @returns {T | R} - The modified object.\n *\n * @example\n * const object = { 'a': [{ 'b': { 'c': 3 } }] };\n * updateWith(object, 'a[0].b.c', (n) => n * n);\n * // => { 'a': [{ 'b': { 'c': 9 } }] }\n */\nexport function updateWith<T extends object, R>(\n  obj: T,\n  path: PropertyPath,\n  updater: (value: any) => any,\n  customizer?: (value: any, key: string, object: T) => any\n): T | R {\n  if (obj == null && !isObject(obj)) {\n    return obj;\n  }\n\n  const resolvedPath = isKey(path, obj)\n    ? [path]\n    : Array.isArray(path)\n      ? path\n      : typeof path === 'string'\n        ? toPath(path)\n        : [path];\n\n  let current: any = obj;\n\n  for (let i = 0; i < resolvedPath.length && current != null; i++) {\n    const key = toKey(resolvedPath[i]);\n\n    if (isUnsafeProperty(key)) {\n      continue;\n    }\n\n    let newValue: unknown;\n\n    if (i === resolvedPath.length - 1) {\n      newValue = updater(current[key]);\n    } else {\n      const objValue = current[key];\n      const customizerResult = customizer?.(objValue, key as string, obj);\n      newValue =\n        customizerResult !== undefined\n          ? customizerResult\n          : isObject(objValue)\n            ? objValue\n            : isIndex(resolvedPath[i + 1])\n              ? []\n              : {};\n    }\n\n    assignValue(current, key, newValue);\n    current = current[key];\n  }\n\n  return obj;\n}\n","import { updateWith } from './updateWith.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\n\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} object - The object to modify.\n * @param {PropertyPath} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T extends object>(object: T, path: PropertyPath, value: any): T;\n\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template R - The return type.\n * @param {object} object - The object to modify.\n * @param {PropertyPath} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {R} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<R>(object: object, path: PropertyPath, value: any): R;\n\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to modify.\n * @param {PropertyPath} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T extends object>(obj: T, path: PropertyPath, value: any): T {\n  return updateWith(\n    obj,\n    path,\n    () => value,\n    () => undefined\n  );\n}\n","import { zip } from '../../array/zip.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { set } from '../object/set.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Creates a deeply nested object given arrays of paths and values.\n *\n * This function takes two arrays: one containing arrays of property paths, and the other containing corresponding values.\n * It returns a new object where paths from the first array are used as key paths to set values, with corresponding elements from the second array as values.\n * Paths can be dot-separated strings or arrays of property names.\n *\n * If the `keys` array is longer than the `values` array, the remaining keys will have `undefined` as their values.\n *\n * @template P - The type of property paths.\n * @template V - The type of values corresponding to the property paths.\n * @param {ArrayLike<P | P[]>} keys - An array of property paths, each path can be a dot-separated string or an array of property names.\n * @param {ArrayLike<V>} values - An array of values corresponding to the property paths.\n * @returns {Record<P, V>} A new object composed of the given property paths and values.\n *\n * @example\n * const paths = ['a.b.c', 'd.e.f'];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\n *\n * @example\n * const paths = [['a', 'b', 'c'], ['d', 'e', 'f']];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { a: { b: { c: 1 } }, d: { e: { f: 2 } } }\n *\n * @example\n * const paths = ['a.b[0].c', 'a.b[1].d'];\n * const values = [1, 2];\n * const result = zipObjectDeep(paths, values);\n * // result will be { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n */\nexport function zipObjectDeep(keys?: ArrayLike<PropertyPath>, values?: ArrayLike<any>): object {\n  const result = {};\n  if (!isArrayLike(keys)) {\n    return result;\n  }\n  if (!isArrayLike(values)) {\n    values = [];\n  }\n  const zipped = zip(Array.from(keys), Array.from(values));\n\n  for (let i = 0; i < zipped.length; i++) {\n    const [key, value] = zipped[i];\n\n    if (key != null) {\n      set(result, key, value);\n    }\n  }\n\n  return result;\n}\n","import { unzip } from './unzip.ts';\nimport { isFunction } from '../../predicate/isFunction.ts';\n\n/**\n * Combines one array into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template R - The type of elements in the resulting array.\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {(item: T) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\n\nexport function zipWith<T, R>(arr1: ArrayLike<T>, combine: (item: T) => R): R[];\n\n/**\n * Combines two arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template R - The type of elements in the resulting array.\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {(item1: T, item2: U) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, R>(arr1: ArrayLike<T>, arr2: ArrayLike<U>, combine: (item1: T, item2: U) => R): R[];\n\n/**\n * Combines three arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template V - The type of elements in the third array.\n * @template R - The type of elements in the resulting array.\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {(item1: T, item2: U, item3: V) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, V, R>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  combine: (item1: T, item2: U, item3: V) => R\n): R[];\n\n/**\n * Combines four arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template V - The type of elements in the third array.\n * @template W - The type of elements in the fourth array.\n * @template R - The type of elements in the resulting array.\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @param {(item1: T, item2: U, item3: V, item4: W) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, V, W, R>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  arr4: ArrayLike<W>,\n  combine: (item1: T, item2: U, item3: V, item4: W) => R\n): R[];\n\n/**\n * Combines five arrays into a single array using a custom combiner function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @template V - The type of elements in the third array.\n * @template W - The type of elements in the fourth array.\n * @template X - The type of elements in the fifth array.\n * @template R - The type of elements in the resulting array.\n * @param {ArrayLike<T>} arr1 - The first array to zip.\n * @param {ArrayLike<U>} arr2 - The second array to zip.\n * @param {ArrayLike<V>} arr3 - The third array to zip.\n * @param {ArrayLike<W>} arr4 - The fourth array to zip.\n * @param {ArrayLike<X>} arr5 - The fifth array to zip.\n * @param {(item1: T, item2: U, item3: V, item4: W, item5: X) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n */\nexport function zipWith<T, U, V, W, X, R>(\n  arr1: ArrayLike<T>,\n  arr2: ArrayLike<U>,\n  arr3: ArrayLike<V>,\n  arr4: ArrayLike<W>,\n  arr5: ArrayLike<X>,\n  combine: (item1: T, item2: U, item3: V, item4: W, item5: X) => R\n): R[];\n\n/**\n * Combines multiple arrays into a single array using a custom combiner function.\n *\n * This function takes one array and a variable number of additional arrays,\n * applying the provided combiner function to the corresponding elements of each array.\n * If the input arrays are of different lengths, the resulting array will have the length\n * of the longest input array, with undefined values for missing elements.\n *\n * @template T - The type of elements in the input arrays.\n * @template R - The type of elements in the resulting array.\n * @param {Array<((...group: T[]) => R) | ArrayLike<T> | null | undefined>} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zipWith(arr1, arr2, (num, char) => `${num}${char}`);\n * // result will be ['1a', '2b', '3c']\n */\nexport function zipWith<T, R>(...combine: Array<((...group: T[]) => R) | ArrayLike<T> | null | undefined>): R[];\n\n/**\n * Combines multiple arrays into a single array using a custom combiner function.\n *\n * This function takes one array and a variable number of additional arrays,\n * applying the provided combiner function to the corresponding elements of each array.\n * If the input arrays are of different lengths, the resulting array will have the length\n * of the longest input array, with undefined values for missing elements.\n *\n * @template T - The type of elements in the input arrays.\n * @template R - The type of elements in the resulting array.\n * @param {Array<((...group: T[]) => R) | ArrayLike<T> | null | undefined>} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zipWith(arr1, arr2, (num, char) => `${num}${char}`);\n * // result will be ['1a', '2b', '3c']\n */\nexport function zipWith<T, R>(...combine: Array<((...group: T[]) => R) | ArrayLike<T> | null | undefined>): R[] {\n  let iteratee = combine.pop();\n\n  if (!isFunction(iteratee)) {\n    combine.push(iteratee);\n    iteratee = undefined;\n  }\n\n  if (!combine?.length) {\n    return [];\n  }\n\n  const result = unzip(combine as ArrayLike<ArrayLike<T>>);\n\n  if (iteratee == null) {\n    return result as R[];\n  }\n\n  return result.map(group => iteratee(...group)) as R[];\n}\n","import { toInteger } from '../util/toInteger.ts';\n\n/**\n * The opposite of `_.before`; this method creates a function that invokes\n * `func` once it's called `n` or more times.\n *\n * @template TFunc - The type of the function to be invoked.\n * @param {number} n - The number of calls before `func` is invoked.\n * @param {TFunc} func - The function to restrict.\n * @returns {TFunc} Returns the new restricted function.\n * @throws {TypeError} - If `func` is not a function.\n *\n * @example\n * const saves = ['profile', 'settings'];\n * const done = after(saves.length, () => {\n *   console.log('done saving!');\n * });\n *\n * saves.forEach(type => {\n *   asyncSave({ 'type': type, 'complete': done });\n * });\n * // => Logs 'done saving!' after the two async saves have completed.\n */\nexport function after<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  n = toInteger(n);\n  return function (this: any, ...args: Parameters<TFunc>) {\n    if (--n < 1) {\n      return func.apply(this, args);\n    }\n  } as TFunc;\n}\n","import { ary as aryToolkit } from '../../function/ary.ts';\n\n/**\n * Creates a function that invokes func, with up to `n` arguments, ignoring any additional arguments.\n * If `n` is not provided, it defaults to the function's length.\n *\n * @param {Function} func - The function to cap arguments for.\n * @param {number} [n] - The arity cap. Defaults to func.length.\n * @returns {Function} Returns the new capped function.\n *\n * @example\n * function fn(a: number, b: number, c: number) {\n *   return Array.from(arguments);\n * }\n *\n * // Cap at 2 arguments\n * const capped = ary(fn, 2);\n * capped(1, 2, 3); // [1, 2]\n *\n * // Default to function length\n * const defaultCap = ary(fn);\n * defaultCap(1, 2, 3); // [1, 2, 3]\n */\nexport function ary(func: (...args: any[]) => any, n?: number): (...args: any[]) => any;\n\n/**\n * Creates a function that invokes func, with up to `n` arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param {number} n - The arity cap.\n * @param {unknown} guard - The value to guard the arity cap.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a: number, b: number, c: number) {\n *   return Array.from(arguments);\n * }\n *\n * ary(fn, 0)(1, 2, 3); // []\n * ary(fn, 1)(1, 2, 3); // [1]\n * ary(fn, 2)(1, 2, 3); // [1, 2]\n * ary(fn, 3)(1, 2, 3); // [1, 2, 3]\n */\nexport function ary<F extends (...args: any[]) => any>(\n  func: F,\n  n: number = func.length,\n  guard?: unknown\n): (...args: any[]) => ReturnType<F> {\n  if (guard) {\n    n = func.length;\n  }\n\n  if (Number.isNaN(n) || n < 0) {\n    n = 0;\n  }\n\n  return aryToolkit(func, n);\n}\n","/**\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param {number} n - The arity cap.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a: number, b: number, c: number) {\n *   return Array.from(arguments);\n * }\n *\n * ary(fn, 0)(1, 2, 3) // []\n * ary(fn, 1)(1, 2, 3) // [1]\n * ary(fn, 2)(1, 2, 3) // [1, 2]\n * ary(fn, 3)(1, 2, 3) // [1, 2, 3]\n */\nexport function ary<F extends (...args: any[]) => any>(func: F, n: number): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: Parameters<F>) {\n    return func.apply(this, args.slice(0, n));\n  };\n}\n","/**\n * Attempts to execute a function with the provided arguments.\n * If the function throws an error, it catches the error and returns it.\n * If the caught error is not an instance of Error, it wraps it in a new Error.\n *\n * @param {F} func - The function to be executed.\n * @param {...Parameters<F>} args - The arguments to pass to the function.\n * @returns {ReturnType<F> | Error} The return value of the function if successful, or an Error if an exception is thrown.\n *\n * @template F - The type of the function being attempted.\n *\n * @example\n * // Example 1: Successful execution\n * const result = attempt((x, y) => x + y, 2, 3);\n * console.log(result); // Output: 5\n *\n * @example\n * // Example 2: Function throws an error\n * const errorResult = attempt(() => {\n *   throw new Error(\"Something went wrong\");\n * });\n * console.log(errorResult); // Output: Error: Something went wrong\n *\n * @example\n * // Example 3: Non-Error thrown\n * const nonErrorResult = attempt(() => {\n *   throw \"This is a string error\";\n * });\n * console.log(nonErrorResult); // Output: Error: This is a string error\n */\nexport function attempt<R>(func: (...args: any[]) => R, ...args: any[]): R | Error {\n  try {\n    return func(...args);\n  } catch (e: any) {\n    return e instanceof Error ? e : new Error(e);\n  }\n}\n","import { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a function that invokes `func`, with the `this` binding and arguments\n * of the created function, while it's called less than `n` times. Subsequent\n * calls to the created function return the result of the last `func` invocation.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of times the returned function is allowed to call `func` before stopping.\n * - If `n` is 0, `func` will never be called.\n * - If `n` is a positive integer, `func` will be called up to `n-1` times.\n * @param {F} func - The function to be called with the limit applied.\n * @returns {(...args: Parameters<F>) => ReturnType<F> } - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` until the `n-1`-th call.\n * - Returns last result of `func`, if `n` is reached.\n * @throws {TypeError} - If `func` is not a function.\n * @example\n * let count = 0;\n * const before3 = before(3, () => ++count);\n *\n * before3(); // => 1\n * before3(); // => 2\n * before3(); // => 2\n */\nexport function before<F extends (...args: any[]) => any>(n: number, func: F): F {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  let result: ReturnType<F>;\n  n = toInteger(n);\n\n  return function (this: unknown, ...args: Parameters<F>) {\n    if (--n > 0) {\n      result = func.apply(this, args);\n    }\n\n    if (n <= 1 && func) {\n      // for garbage collection\n      func = undefined as any;\n    }\n\n    return result;\n  } as F;\n}\n","/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives.\n *\n * The `bind.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: Unlike native `Function#bind`, this method doesn't set the `length` property of bound functions.\n *\n * @template F - The type of the function to bind.\n * @param {F} func - The function to bind.\n * @param {unknown} thisObj - The `this` binding of `func`.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {F} - Returns the new bound function.\n *\n * @example\n * function greet(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * }\n * const object = { user: 'fred' };\n * let bound = bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * bound = bind(greet, object, bind.placeholder, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nexport function bind(func: (...args: any[]) => any, thisObj: any, ...partialArgs: any[]): (...args: any[]) => any {\n  const bound = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bind.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof bound) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...args);\n    }\n\n    return func.apply(thisObj, args);\n  };\n\n  return bound;\n}\n\nconst bindPlaceholder: unique symbol = Symbol('bind.placeholder');\nbind.placeholder = bindPlaceholder;\n","/**\n * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.\n *\n * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.\n *\n * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * @template T - The type of the object to bind.\n * @template K - The type of the key to bind.\n * @param {T} object - The object to invoke the method on.\n * @param {K} key - The key of the method.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.\n *\n * @example\n * const object = {\n *   user: 'fred',\n *   greet: function (greeting, punctuation) {\n *     return greeting + ' ' + this.user + punctuation;\n *   },\n * };\n *\n * let bound = bindKey(object, 'greet', 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * object.greet = function (greeting, punctuation) {\n *   return greeting + 'ya ' + this.user + punctuation;\n * };\n *\n * bound('!');\n * // => 'hiya fred!'\n *\n * // Bound with placeholders.\n * bound = bindKey(object, 'greet', bindKey.placeholder, '!');\n * bound('hi');\n * // => 'hiya fred!'\n */\nexport function bindKey(object: object, key: string, ...partialArgs: any[]): (...args: any[]) => any;\n\n/**\n * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.\n *\n * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.\n *\n * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * @template T - The type of the object to bind.\n * @template K - The type of the key to bind.\n * @param {T} object - The object to invoke the method on.\n * @param {K} key - The key of the method.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.\n *\n * @example\n * const object = {\n *   user: 'fred',\n *   greet: function (greeting, punctuation) {\n *     return greeting + ' ' + this.user + punctuation;\n *   },\n * };\n *\n * let bound = bindKey(object, 'greet', 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * object.greet = function (greeting, punctuation) {\n *   return greeting + 'ya ' + this.user + punctuation;\n * };\n *\n * bound('!');\n * // => 'hiya fred!'\n *\n * // Bound with placeholders.\n * bound = bindKey(object, 'greet', bindKey.placeholder, '!');\n * bound('hi');\n * // => 'hiya fred!'\n */\nexport function bindKey<T extends Record<PropertyKey, any>, K extends keyof T>(\n  object: T,\n  key: K,\n  ...partialArgs: any[]\n): T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never {\n  const bound = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bindKey.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof bound) {\n      return new object[key](...args);\n    }\n\n    // eslint-disable-next-line prefer-spread\n    return object[key].apply(object, args);\n  };\n\n  return bound as any;\n}\n\nconst bindKeyPlaceholder: unique symbol = Symbol('bindKey.placeholder');\nbindKey.placeholder = bindKeyPlaceholder;\n","// eslint-disable-next-line @typescript-eslint/naming-convention\ntype __ = typeof curryPlaceholder;\n\ninterface CurriedFunction1<T1, R> {\n  (): CurriedFunction1<T1, R>;\n  (t1: T1): R;\n}\n\ninterface CurriedFunction2<T1, T2, R> {\n  (): CurriedFunction2<T1, T2, R>;\n  (t1: T1): CurriedFunction1<T2, R>;\n  (t1: __, t2: T2): CurriedFunction1<T1, R>;\n  (t1: T1, t2: T2): R;\n}\ninterface CurriedFunction3<T1, T2, T3, R> {\n  (): CurriedFunction3<T1, T2, T3, R>;\n  (t1: T1): CurriedFunction2<T2, T3, R>;\n  (t1: __, t2: T2): CurriedFunction2<T1, T3, R>;\n  (t1: T1, t2: T2): CurriedFunction1<T3, R>;\n  (t1: __, t2: __, t3: T3): CurriedFunction2<T1, T2, R>;\n  (t1: T1, t2: __, t3: T3): CurriedFunction1<T2, R>;\n  (t1: __, t2: T2, t3: T3): CurriedFunction1<T1, R>;\n  (t1: T1, t2: T2, t3: T3): R;\n}\ninterface CurriedFunction4<T1, T2, T3, T4, R> {\n  (): CurriedFunction4<T1, T2, T3, T4, R>;\n  (t1: T1): CurriedFunction3<T2, T3, T4, R>;\n  (t1: __, t2: T2): CurriedFunction3<T1, T3, T4, R>;\n  (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;\n  (t1: __, t2: __, t3: T3): CurriedFunction3<T1, T2, T4, R>;\n  (t1: __, t2: __, t3: T3): CurriedFunction2<T2, T4, R>;\n  (t1: __, t2: T2, t3: T3): CurriedFunction2<T1, T4, R>;\n  (t1: T1, t2: T2, t3: T3): CurriedFunction1<T4, R>;\n  (t1: __, t2: __, t3: __, t4: T4): CurriedFunction3<T1, T2, T3, R>;\n  (t1: T1, t2: __, t3: __, t4: T4): CurriedFunction2<T2, T3, R>;\n  (t1: __, t2: T2, t3: __, t4: T4): CurriedFunction2<T1, T3, R>;\n  (t1: __, t2: __, t3: T3, t4: T4): CurriedFunction2<T1, T2, R>;\n  (t1: T1, t2: T2, t3: __, t4: T4): CurriedFunction1<T3, R>;\n  (t1: T1, t2: __, t3: T3, t4: T4): CurriedFunction1<T2, R>;\n  (t1: __, t2: T2, t3: T3, t4: T4): CurriedFunction1<T1, R>;\n  (t1: T1, t2: T2, t3: T3, t4: T4): R;\n}\ninterface CurriedFunction5<T1, T2, T3, T4, T5, R> {\n  (): CurriedFunction5<T1, T2, T3, T4, T5, R>;\n  (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;\n  (t1: __, t2: T2): CurriedFunction4<T1, T3, T4, T5, R>;\n  (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;\n  (t1: __, t2: __, t3: T3): CurriedFunction4<T1, T2, T4, T5, R>;\n  (t1: T1, t2: __, t3: T3): CurriedFunction3<T2, T4, T5, R>;\n  (t1: __, t2: T2, t3: T3): CurriedFunction3<T1, T4, T5, R>;\n  (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;\n  (t1: __, t2: __, t3: __, t4: T4): CurriedFunction4<T1, T2, T3, T5, R>;\n  (t1: T1, t2: __, t3: __, t4: T4): CurriedFunction3<T2, T3, T5, R>;\n  (t1: __, t2: T2, t3: __, t4: T4): CurriedFunction3<T1, T3, T5, R>;\n  (t1: __, t2: __, t3: T3, t4: T4): CurriedFunction3<T1, T2, T5, R>;\n  (t1: T1, t2: T2, t3: __, t4: T4): CurriedFunction2<T3, T5, R>;\n  (t1: T1, t2: __, t3: T3, t4: T4): CurriedFunction2<T2, T5, R>;\n  (t1: __, t2: T2, t3: T3, t4: T4): CurriedFunction2<T1, T5, R>;\n  (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction1<T5, R>;\n  (t1: __, t2: __, t3: __, t4: __, t5: T5): CurriedFunction4<T1, T2, T3, T4, R>;\n  (t1: T1, t2: __, t3: __, t4: __, t5: T5): CurriedFunction3<T2, T3, T4, R>;\n  (t1: __, t2: T2, t3: __, t4: __, t5: T5): CurriedFunction3<T1, T3, T4, R>;\n  (t1: __, t2: __, t3: T3, t4: __, t5: T5): CurriedFunction3<T1, T2, T4, R>;\n  (t1: __, t2: __, t3: __, t4: T4, t5: T5): CurriedFunction3<T1, T2, T3, R>;\n  (t1: T1, t2: T2, t3: __, t4: __, t5: T5): CurriedFunction2<T3, T4, R>;\n  (t1: T1, t2: __, t3: T3, t4: __, t5: T5): CurriedFunction2<T2, T4, R>;\n  (t1: T1, t2: __, t3: __, t4: T4, t5: T5): CurriedFunction2<T2, T3, R>;\n  (t1: __, t2: T2, t3: T3, t4: __, t5: T5): CurriedFunction2<T1, T4, R>;\n  (t1: __, t2: T2, t3: __, t4: T4, t5: T5): CurriedFunction2<T1, T3, R>;\n  (t1: __, t2: __, t3: T3, t4: T4, t5: T5): CurriedFunction2<T1, T2, R>;\n  (t1: T1, t2: T2, t3: T3, t4: __, t5: T5): CurriedFunction1<T4, R>;\n  (t1: T1, t2: T2, t3: __, t4: T4, t5: T5): CurriedFunction1<T3, R>;\n  (t1: T1, t2: __, t3: T3, t4: T4, t5: T5): CurriedFunction1<T2, R>;\n  (t1: __, t2: T2, t3: T3, t4: T4, t5: T5): CurriedFunction1<T1, R>;\n  (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\n}\n\n/**\n * Creates a curried function that accepts a single argument.\n * @param {(t1: T1) => R} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @returns {CurriedFunction1<T1, R>} - Returns the new curried function.\n * @example\n * const greet = (name: string) => `Hello ${name}`;\n * const curriedGreet = curry(greet);\n * curriedGreet('John'); // => 'Hello John'\n */\nexport function curry<T1, R>(func: (t1: T1) => R, arity?: number): CurriedFunction1<T1, R>;\n\n/**\n * Creates a curried function that accepts two arguments.\n * @param {(t1: T1, t2: T2) => R} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @returns {CurriedFunction2<T1, T2, R>} - Returns the new curried function.\n * @example\n * const add = (a: number, b: number) => a + b;\n * const curriedAdd = curry(add);\n * curriedAdd(1)(2); // => 3\n * curriedAdd(1, 2); // => 3\n */\nexport function curry<T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number): CurriedFunction2<T1, T2, R>;\n\n/**\n * Creates a curried function that accepts three arguments.\n * @param {(t1: T1, t2: T2, t3: T3) => R} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @returns {CurriedFunction3<T1, T2, T3, R>} - Returns the new curried function.\n * @example\n * const volume = (l: number, w: number, h: number) => l * w * h;\n * const curriedVolume = curry(volume);\n * curriedVolume(2)(3)(4); // => 24\n * curriedVolume(2, 3)(4); // => 24\n * curriedVolume(2, 3, 4); // => 24\n */\nexport function curry<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arity?: number\n): CurriedFunction3<T1, T2, T3, R>;\n\n/**\n * Creates a curried function that accepts four arguments.\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @returns {CurriedFunction4<T1, T2, T3, T4, R>} - Returns the new curried function.\n * @example\n * const fn = (a: number, b: number, c: number, d: number) => a + b + c + d;\n * const curriedFn = curry(fn);\n * curriedFn(1)(2)(3)(4); // => 10\n * curriedFn(1, 2)(3, 4); // => 10\n * curriedFn(1, 2, 3, 4); // => 10\n */\nexport function curry<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arity?: number\n): CurriedFunction4<T1, T2, T3, T4, R>;\n\n/**\n * Creates a curried function that accepts five arguments.\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @returns {CurriedFunction5<T1, T2, T3, T4, T5, R>} - Returns the new curried function.\n * @example\n * const fn = (a: number, b: number, c: number, d: number, e: number) => a + b + c + d + e;\n * const curriedFn = curry(fn);\n * curriedFn(1)(2)(3)(4)(5); // => 15\n * curriedFn(1, 2)(3, 4)(5); // => 15\n * curriedFn(1, 2, 3, 4, 5); // => 15\n */\nexport function curry<T1, T2, T3, T4, T5, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R,\n  arity?: number\n): CurriedFunction5<T1, T2, T3, T4, T5, R>;\n\n/**\n * Creates a curried function that accepts any number of arguments.\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @returns {(...args: any[]) => any} - Returns the new curried function.\n * @example\n * const sum = (...args: number[]) => args.reduce((a, b) => a + b, 0);\n * const curriedSum = curry(sum);\n * curriedSum(1, 2, 3); // => 6\n * curriedSum(1)(2, 3); // => 6\n * curriedSum(1)(2)(3); // => 6\n */\nexport function curry(func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\n\n/**\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\n * The arity of `func` may be specified if `func.length` is not sufficient.\n *\n * The `curry.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of curried functions.\n *\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\n * @returns {((...args: any[]) => any) & { placeholder: typeof curry.placeholder }} - Returns the new curried function.\n *\n * @example\n * const abc = function(a, b, c) {\n *   return Array.from(arguments);\n * };\n *\n * let curried = curry(abc);\n *\n * curried(1)(2)(3);\n * // => [1, 2, 3]\n *\n * curried(1, 2)(3);\n * // => [1, 2, 3]\n *\n * curried(1, 2, 3);\n * // => [1, 2, 3]\n *\n * // Curried with placeholders.\n * curried(1)(curry.placeholder, 3)(2);\n * // => [1, 2, 3]\n *\n * // Curried with arity.\n * curried = curry(abc, 2);\n *\n * curried(1)(2);\n * // => [1, 2]\n */\nexport function curry(\n  func: (...args: any[]) => any,\n  arity: number = func.length,\n  guard?: unknown\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\n  arity = guard ? func.length : arity;\n  arity = Number.parseInt(arity as any, 10);\n  if (Number.isNaN(arity) || arity < 1) {\n    arity = 0;\n  }\n\n  const wrapper = function (this: any, ...partialArgs: any[]) {\n    const holders = partialArgs.filter(item => item === curry.placeholder);\n    const length = partialArgs.length - holders.length;\n    if (length < arity) {\n      return makeCurry(func, arity - length, partialArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...partialArgs);\n    }\n    return func.apply(this, partialArgs);\n  };\n\n  wrapper.placeholder = curryPlaceholder;\n\n  return wrapper;\n}\n\nfunction makeCurry(\n  func: (...args: any[]) => any,\n  arity: number,\n  partialArgs: any[]\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\n  function wrapper(this: any, ...providedArgs: any[]) {\n    const holders = providedArgs.filter(item => item === curry.placeholder);\n    const length = providedArgs.length - holders.length;\n    providedArgs = composeArgs(providedArgs, partialArgs);\n    if (length < arity) {\n      return makeCurry(func, arity - length, providedArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...providedArgs);\n    }\n    return func.apply(this, providedArgs);\n  }\n  wrapper.placeholder = curryPlaceholder;\n  return wrapper;\n}\n\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\n  const args = [];\n  let startIndex = 0;\n  for (let i = 0; i < partialArgs.length; i++) {\n    const arg = partialArgs[i];\n\n    if (arg === curry.placeholder && startIndex < providedArgs.length) {\n      args.push(providedArgs[startIndex++]);\n    } else {\n      args.push(arg);\n    }\n  }\n  for (let i = startIndex; i < providedArgs.length; i++) {\n    args.push(providedArgs[i]);\n  }\n  return args;\n}\n\nconst curryPlaceholder: unique symbol = Symbol('curry.placeholder');\ncurry.placeholder = curryPlaceholder;\n","// eslint-disable-next-line @typescript-eslint/naming-convention\ntype __ = typeof curryRightPlaceholder;\n\ninterface RightCurriedFunction1<T1, R> {\n  (): RightCurriedFunction1<T1, R>;\n  (t1: T1): R;\n}\ninterface RightCurriedFunction2<T1, T2, R> {\n  (): RightCurriedFunction2<T1, T2, R>;\n  (t2: T2): RightCurriedFunction1<T1, R>;\n  (t1: T1, t2: __): RightCurriedFunction1<T2, R>;\n  (t1: T1, t2: T2): R;\n}\ninterface RightCurriedFunction3<T1, T2, T3, R> {\n  (): RightCurriedFunction3<T1, T2, T3, R>;\n  (t3: T3): RightCurriedFunction2<T1, T2, R>;\n  (t2: T2, t3: __): RightCurriedFunction2<T1, T3, R>;\n  (t2: T2, t3: T3): RightCurriedFunction1<T1, R>;\n  (t1: T1, t2: __, t3: __): RightCurriedFunction2<T2, T3, R>;\n  (t1: T1, t2: T2, t3: __): RightCurriedFunction1<T3, R>;\n  (t1: T1, t2: __, t3: T3): RightCurriedFunction1<T2, R>;\n  (t1: T1, t2: T2, t3: T3): R;\n}\ninterface RightCurriedFunction4<T1, T2, T3, T4, R> {\n  (): RightCurriedFunction4<T1, T2, T3, T4, R>;\n  (t4: T4): RightCurriedFunction3<T1, T2, T3, R>;\n  (t3: T3, t4: __): RightCurriedFunction3<T1, T2, T4, R>;\n  (t3: T3, t4: T4): RightCurriedFunction2<T1, T2, R>;\n  (t2: T2, t3: __, t4: __): RightCurriedFunction3<T1, T3, T4, R>;\n  (t2: T2, t3: T3, t4: __): RightCurriedFunction2<T1, T4, R>;\n  (t2: T2, t3: __, t4: T4): RightCurriedFunction2<T1, T3, R>;\n  (t2: T2, t3: T3, t4: T4): RightCurriedFunction1<T1, R>;\n  (t1: T1, t2: __, t3: __, t4: __): RightCurriedFunction3<T2, T3, T4, R>;\n  (t1: T1, t2: T2, t3: __, t4: __): RightCurriedFunction2<T3, T4, R>;\n  (t1: T1, t2: __, t3: T3, t4: __): RightCurriedFunction2<T2, T4, R>;\n  (t1: T1, t2: __, t3: __, t4: T4): RightCurriedFunction2<T2, T3, R>;\n  (t1: T1, t2: T2, t3: T3, t4: __): RightCurriedFunction1<T4, R>;\n  (t1: T1, t2: T2, t3: __, t4: T4): RightCurriedFunction1<T3, R>;\n  (t1: T1, t2: __, t3: T3, t4: T4): RightCurriedFunction1<T2, R>;\n  (t1: T1, t2: T2, t3: T3, t4: T4): R;\n}\ninterface RightCurriedFunction5<T1, T2, T3, T4, T5, R> {\n  (): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\n  (t5: T5): RightCurriedFunction4<T1, T2, T3, T4, R>;\n  (t4: T4, t5: __): RightCurriedFunction4<T1, T2, T3, T5, R>;\n  (t4: T4, t5: T5): RightCurriedFunction3<T1, T2, T3, R>;\n  (t3: T3, t4: __, t5: __): RightCurriedFunction4<T1, T2, T4, T5, R>;\n  (t3: T3, t4: T4, t5: __): RightCurriedFunction3<T1, T2, T5, R>;\n  (t3: T3, t4: __, t5: T5): RightCurriedFunction3<T1, T2, T4, R>;\n  (t3: T3, t4: T4, t5: T5): RightCurriedFunction2<T1, T2, R>;\n  (t2: T2, t3: __, t4: __, t5: __): RightCurriedFunction4<T1, T3, T4, T5, R>;\n  (t2: T2, t3: T3, t4: __, t5: __): RightCurriedFunction3<T1, T4, T5, R>;\n  (t2: T2, t3: __, t4: T4, t5: __): RightCurriedFunction3<T1, T3, T5, R>;\n  (t2: T2, t3: __, t4: __, t5: T5): RightCurriedFunction3<T1, T3, T4, R>;\n  (t2: T2, t3: T3, t4: T4, t5: __): RightCurriedFunction2<T1, T5, R>;\n  (t2: T2, t3: T3, t4: __, t5: T5): RightCurriedFunction2<T1, T4, R>;\n  (t2: T2, t3: __, t4: T4, t5: T5): RightCurriedFunction2<T1, T3, R>;\n  (t2: T2, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T1, R>;\n  (t1: T1, t2: __, t3: __, t4: __, t5: __): RightCurriedFunction4<T2, T3, T4, T5, R>;\n  (t1: T1, t2: T2, t3: __, t4: __, t5: __): RightCurriedFunction3<T3, T4, T5, R>;\n  (t1: T1, t2: __, t3: T3, t4: __, t5: __): RightCurriedFunction3<T2, T4, T5, R>;\n  (t1: T1, t2: __, t3: __, t4: T4, t5: __): RightCurriedFunction3<T2, T3, T5, R>;\n  (t1: T1, t2: __, t3: __, t4: __, t5: T5): RightCurriedFunction3<T2, T3, T4, R>;\n  (t1: T1, t2: T2, t3: T3, t4: __, t5: __): RightCurriedFunction2<T4, T5, R>;\n  (t1: T1, t2: T2, t3: __, t4: T4, t5: __): RightCurriedFunction2<T3, T5, R>;\n  (t1: T1, t2: T2, t3: __, t4: __, t5: T5): RightCurriedFunction2<T3, T4, R>;\n  (t1: T1, t2: __, t3: T3, t4: T4, t5: __): RightCurriedFunction2<T2, T5, R>;\n  (t1: T1, t2: __, t3: T3, t4: __, t5: T5): RightCurriedFunction2<T2, T4, R>;\n  (t1: T1, t2: __, t3: __, t4: T4, t5: T5): RightCurriedFunction2<T2, T3, R>;\n  (t1: T1, t2: T2, t3: T3, t4: T4, t5: __): RightCurriedFunction1<T5, R>;\n  (t1: T1, t2: T2, t3: T3, t4: __, t5: T5): RightCurriedFunction1<T4, R>;\n  (t1: T1, t2: T2, t3: __, t4: T4, t5: T5): RightCurriedFunction1<T3, R>;\n  (t1: T1, t2: __, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T2, R>;\n  (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\n}\n\nexport function curryRight<T1, R>(func: (t1: T1) => R, arity?: number): RightCurriedFunction1<T1, R>;\nexport function curryRight<T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number): RightCurriedFunction2<T1, T2, R>;\nexport function curryRight<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arity?: number\n): RightCurriedFunction3<T1, T2, T3, R>;\nexport function curryRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arity?: number\n): RightCurriedFunction4<T1, T2, T3, T4, R>;\nexport function curryRight<T1, T2, T3, T4, T5, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R,\n  arity?: number\n): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\nexport function curryRight(func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\n\n/**\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\n * The arity of `func` may be specified if `func.length` is not sufficient.\n *\n * Unlike `curry`, this function curries the function from right to left.\n *\n * The `curryRight.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of curried functions.\n *\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\n * @returns {((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder }} - Returns the new curried function.\n *\n * @example\n * const abc = function(a, b, c) {\n *   return Array.from(arguments);\n * };\n *\n * let curried = curryRight(abc);\n *\n * curried(3)(2)(1);\n * // => [1, 2, 3]\n *\n * curried(2, 3)(1);\n * // => [1, 2, 3]\n *\n * curried(1, 2, 3);\n * // => [1, 2, 3]\n *\n * // Curried with placeholders.\n * curried(3)(curryRight.placeholder, 2)(1);\n * // => [1, 2, 3]\n *\n * // Curried with arity.\n * curried = curryRight(abc, 2);\n *\n * curried(2)(1);\n * // => [1, 2]\n */\nexport function curryRight(\n  func: (...args: any[]) => any,\n  arity: number = func.length,\n  guard?: unknown\n): ((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder } {\n  arity = guard ? func.length : arity;\n  arity = Number.parseInt(arity as any, 10);\n  if (Number.isNaN(arity) || arity < 1) {\n    arity = 0;\n  }\n\n  const wrapper = function (this: any, ...partialArgs: any[]) {\n    const holders = partialArgs.filter(item => item === curryRight.placeholder);\n    const length = partialArgs.length - holders.length;\n    if (length < arity) {\n      return makeCurryRight(func, arity - length, partialArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...partialArgs);\n    }\n    return func.apply(this, partialArgs);\n  };\n\n  wrapper.placeholder = curryRightPlaceholder;\n\n  return wrapper;\n}\n\nfunction makeCurryRight(\n  func: (...args: any[]) => any,\n  arity: number,\n  partialArgs: any[]\n): ((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder } {\n  function wrapper(this: any, ...providedArgs: any[]) {\n    const holders = providedArgs.filter(item => item === curryRight.placeholder);\n    const length = providedArgs.length - holders.length;\n    providedArgs = composeArgs(providedArgs, partialArgs);\n    if (length < arity) {\n      return makeCurryRight(func, arity - length, providedArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...providedArgs);\n    }\n    return func.apply(this, providedArgs);\n  }\n  wrapper.placeholder = curryRightPlaceholder;\n  return wrapper;\n}\n\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\n  const placeholderLength = partialArgs.filter(arg => arg === curryRight.placeholder).length;\n  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n  const args: any[] = [];\n\n  let providedIndex = 0;\n  for (let i = 0; i < rangeLength; i++) {\n    args.push(providedArgs[providedIndex++]);\n  }\n  for (let i = 0; i < partialArgs.length; i++) {\n    const arg = partialArgs[i];\n\n    if (arg === curryRight.placeholder) {\n      if (providedIndex < providedArgs.length) {\n        args.push(providedArgs[providedIndex++]);\n      } else {\n        args.push(arg);\n      }\n    } else {\n      args.push(arg);\n    }\n  }\n  return args;\n}\n\nconst curryRightPlaceholder: unique symbol = Symbol('curryRight.placeholder');\ncurryRight.placeholder = curryRightPlaceholder;\n","interface DebounceOptions {\n  /**\n   * An optional AbortSignal to cancel the debounced function.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * An optional array specifying whether the function should be invoked on the leading edge, trailing edge, or both.\n   * If `edges` includes \"leading\", the function will be invoked at the start of the delay period.\n   * If `edges` includes \"trailing\", the function will be invoked at the end of the delay period.\n   * If both \"leading\" and \"trailing\" are included, the function will be invoked at both the start and end of the delay period.\n   * @default [\"trailing\"]\n   */\n  edges?: Array<'leading' | 'trailing'>;\n}\n\nexport interface DebouncedFunction<F extends (...args: any[]) => void> {\n  (...args: Parameters<F>): void;\n\n  /**\n   * Schedules the execution of the debounced function after the specified debounce delay.\n   * This method resets any existing timer, ensuring that the function is only invoked\n   * after the delay has elapsed since the last call to the debounced function.\n   * It is typically called internally whenever the debounced function is invoked.\n   *\n   * @returns {void}\n   */\n  schedule: () => void;\n\n  /**\n   * Cancels any pending execution of the debounced function.\n   * This method clears the active timer and resets any stored context or arguments.\n   */\n  cancel: () => void;\n\n  /**\n   * Immediately invokes the debounced function if there is a pending execution.\n   * This method also cancels the current timer, ensuring that the function executes right away.\n   */\n  flush: () => void;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => void>(\n  func: F,\n  debounceMs: number,\n  { signal, edges }: DebounceOptions = {}\n): DebouncedFunction<F> {\n  let pendingThis: any = undefined;\n  let pendingArgs: Parameters<F> | null = null;\n\n  const leading = edges != null && edges.includes('leading');\n  const trailing = edges == null || edges.includes('trailing');\n\n  const invoke = () => {\n    if (pendingArgs !== null) {\n      func.apply(pendingThis, pendingArgs);\n      pendingThis = undefined;\n      pendingArgs = null;\n    }\n  };\n\n  const onTimerEnd = () => {\n    if (trailing) {\n      invoke();\n    }\n\n    cancel();\n  };\n\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const schedule = () => {\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n\n      onTimerEnd();\n    }, debounceMs);\n  };\n\n  const cancelTimer = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  const cancel = () => {\n    cancelTimer();\n    pendingThis = undefined;\n    pendingArgs = null;\n  };\n\n  const flush = () => {\n    cancelTimer();\n    invoke();\n  };\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    if (signal?.aborted) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    pendingThis = this;\n    pendingArgs = args;\n\n    const isFirstCall = timeoutId == null;\n\n    schedule();\n\n    if (leading && isFirstCall) {\n      invoke();\n    }\n  };\n\n  debounced.schedule = schedule;\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n\n  signal?.addEventListener('abort', cancel, { once: true });\n\n  return debounced;\n}\n","import { debounce as debounceToolkit } from '../../function/debounce.ts';\n\ninterface DebounceSettings {\n  /**\n   * If `true`, the function will be invoked on the leading edge of the timeout.\n   * @default false\n   */\n  leading?: boolean | undefined;\n  /**\n   * The maximum time `func` is allowed to be delayed before it's invoked.\n   * @default Infinity\n   */\n  maxWait?: number | undefined;\n  /**\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\n   * @default true\n   */\n  trailing?: boolean | undefined;\n}\n\ninterface DebounceSettingsLeading extends DebounceSettings {\n  leading: true;\n}\n\nexport interface DebouncedFunc<T extends (...args: any[]) => any> {\n  /**\n   * Call the original function, but applying the debounce rules.\n   *\n   * If the debounced function can be run immediately, this calls it and returns its return\n   * value.\n   *\n   * Otherwise, it returns the return value of the last invocation, or undefined if the debounced\n   * function was not invoked yet.\n   */\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n\n  /**\n   * Throw away any pending invocation of the debounced function.\n   */\n  cancel(): void;\n\n  /**\n   * If there is a pending invocation of the debounced function, invoke it immediately and return\n   * its return value.\n   *\n   * Otherwise, return the value from the last invocation, or undefined if the debounced function\n   * was never invoked.\n   */\n  flush(): ReturnType<T> | undefined;\n}\n\nexport interface DebouncedFuncLeading<T extends (...args: any[]) => any> extends DebouncedFunc<T> {\n  (...args: Parameters<T>): ReturnType<T>;\n  flush(): ReturnType<T>;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * You can set the debounced function to run at the start (`leading`) or end (`trailing`) of the delay period.\n * If `leading` is true, the function runs immediately on the first call.\n * If `trailing` is true, the function runs after `debounceMs` milliseconds have passed since the last call.\n * If both `leading` and `trailing` are true, the function runs at both the start and end, but it must be called at least twice within `debounceMs` milliseconds for this to happen\n * (since one debounced function call cannot trigger the function twice).\n *\n * You can also set a `maxWait` time, which is the maximum time the function is allowed to be delayed before it is called.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @param {number} options.maxWait - The maximum time `func` is allowed to be delayed before it's invoked.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<T extends (...args: any) => any>(\n  func: T,\n  wait: number | undefined,\n  options: DebounceSettingsLeading\n): DebouncedFuncLeading<T>;\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * You can set the debounced function to run at the start (`leading`) or end (`trailing`) of the delay period.\n * If `leading` is true, the function runs immediately on the first call.\n * If `trailing` is true, the function runs after `debounceMs` milliseconds have passed since the last call.\n * If both `leading` and `trailing` are true, the function runs at both the start and end, but it must be called at least twice within `debounceMs` milliseconds for this to happen\n * (since one debounced function call cannot trigger the function twice).\n *\n * You can also set a `maxWait` time, which is the maximum time the function is allowed to be delayed before it is called.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @param {number} options.maxWait - The maximum time `func` is allowed to be delayed before it's invoked.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<T extends (...args: any) => any>(\n  func: T,\n  wait?: number,\n  options?: DebounceSettings\n): DebouncedFunc<T>;\n\nexport function debounce<F extends (...args: any[]) => any>(\n  func: F,\n  debounceMs = 0,\n  options: DebounceSettings = {}\n): DebouncedFunc<F> {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  const { leading = false, trailing = true, maxWait } = options;\n\n  const edges = Array(2);\n\n  if (leading) {\n    edges[0] = 'leading';\n  }\n\n  if (trailing) {\n    edges[1] = 'trailing';\n  }\n\n  let result: ReturnType<F> | undefined = undefined;\n  let pendingAt: number | null = null;\n\n  const _debounced = debounceToolkit(\n    function (this: any, ...args: Parameters<F>) {\n      result = func.apply(this, args);\n      pendingAt = null;\n    },\n    debounceMs,\n    { edges }\n  );\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    if (maxWait != null) {\n      if (pendingAt === null) {\n        pendingAt = Date.now();\n      }\n\n      if (Date.now() - pendingAt >= maxWait) {\n        result = func.apply(this, args);\n        pendingAt = Date.now();\n\n        _debounced.cancel();\n        _debounced.schedule();\n\n        return result;\n      }\n    }\n\n    _debounced.apply(this, args);\n    return result;\n  };\n\n  const flush = () => {\n    _debounced.flush();\n    return result;\n  };\n\n  debounced.cancel = _debounced.cancel;\n  debounced.flush = flush;\n\n  return debounced;\n}\n","/**\n * Defers invoking the `func` until the current call stack has cleared. Any additional arguments are provided to func when it's invoked.\n *\n * @param {(...args: any[]) => any} func The function to defer.\n * @param {...any[]} args The arguments to invoke `func` with.\n * @returns {number} Returns the timer id.\n *\n * @example\n * defer(console.log, 'deferred');\n * // => Logs 'deferred' after the current call stack has cleared.\n */\nexport function defer(func: (...args: any[]) => any, ...args: any[]): number;\n\n/**\n * Defers invoking the `func` until the current call stack has cleared. Any additional arguments are provided to func when it's invoked.\n *\n * @param {F} func The function to defer.\n * @param {Parameters<F>} args The arguments to invoke `func` with.\n * @returns {number} Returns the timer id.\n *\n * @example\n * defer((text) => {\n *   console.log(text);\n * }, 'deferred');\n * // => Logs 'deferred' after the current call stack has cleared.\n */\nexport function defer<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): number {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  return setTimeout(func, 1, ...args);\n}\n","import { toNumber } from '../util/toNumber.ts';\n\n/**\n * Invokes the specified function after a delay of the given number of milliseconds.\n * Any additional arguments are passed to the function when it is invoked.\n *\n * @param {(...args: any[]) => any} func - The function to delay.\n * @param {number} wait - The number of milliseconds to delay the invocation.\n * @param {...any[]} args - The arguments to pass to the function when it is invoked.\n * @returns {number} Returns the timer id.\n * @throws {TypeError} If the first argument is not a function.\n *\n * @example\n * // Example 1: Delayed function execution\n * const timerId = delay(\n *   (greeting, recipient) => {\n *     console.log(`${greeting}, ${recipient}!`);\n *   },\n *   1000,\n *   'Hello',\n *   'Alice'\n * );\n * // => 'Hello, Alice!' will be logged after one second.\n *\n * // Example 2: Clearing the timeout before execution\n * clearTimeout(timerId);\n * // The function will not be executed because the timeout was cleared.\n */\nexport function delay(func: (...args: any[]) => any, wait: number, ...args: any[]): number {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  return setTimeout(func, toNumber(wait) || 0, ...args);\n}\n","/**\n * Reverses the order of arguments for a given function.\n *\n * @template T - The type of the function being flipped.\n * @param {T} func - The function whose arguments will be reversed.\n * @returns {T} A new function that takes the reversed arguments and returns the result of calling `func`.\n *\n * @example\n * var flipped = flip(function() {\n *   return Array.prototype.slice.call(arguments);\n * });\n *\n * flipped('a', 'b', 'c', 'd');\n * // => ['d', 'c', 'b', 'a']\n */\nexport function flip<T extends (...args: any) => any>(func: T): T;\n\n/**\n * Reverses the order of arguments for a given function.\n *\n * @template F - The type of the function being flipped.\n * @param {F} func - The function whose arguments will be reversed.\n * @returns {(...args: Reversed<Parameters<F>>) => ReturnType<F>} A new function that takes the\n * reversed arguments and returns the result of calling `func`.\n *\n * @example\n * function fn(a: string, b: string, c: string, d: string) {\n *   return [a, b, c, d];\n * }\n *\n * const flipped = flip(fn);\n * flipped('a', 'b', 'c', 'd'); // => ['d', 'c', 'b', 'a']\n */\n\nexport function flip<F extends (...args: any[]) => any>(func: F): (...args: Reversed<Parameters<F>>) => ReturnType<F> {\n  return function (this: any, ...args: Reversed<Parameters<F>>) {\n    return func.apply(this, args.reverse());\n  };\n}\n\ntype Reversed<T extends any[]> = T extends [infer First, ...infer Rest] ? [...Reversed<Rest>, First] : [];\n","/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *  return 42;\n * }\n *\n * const combined = flow(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flow<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *   return a * 2;\n * }\n *\n * const combined = flow(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flow<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flow(add, square, double, toStr);\n * console.log(combined(1, 2)); // '18'\n */\nexport function flow<A extends any[], R1, R2, R3, R4>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flow(add, square, double, toStr, split);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any {\n  return function (this: any, ...args: any[]) {\n    let result = funcs.length ? funcs[0].apply(this, args) : args[0];\n\n    for (let i = 1; i < funcs.length; i++) {\n      result = funcs[i].call(this, result);\n    }\n\n    return result;\n  };\n}\n","import { flatten } from '../../array/flatten.ts';\nimport { flow as flowToolkit } from '../../function/flow.ts';\nimport { Many } from '../_internal/Many.ts';\n\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * @template A - The type of the arguments.\n * @template R - The type of the return values.\n * @param {(...args: A) => R} f1 - The first function to invoke.\n * @param {(a: R) => R} f2 - The second function to invoke.\n * @param {(a: R) => R} f3 - The third function to invoke.\n * @param {(a: R) => R} f4 - The fourth function to invoke.\n * @param {(a: R) => R} f5 - The fifth function to invoke.\n * @param {(a: R) => R} f6 - The sixth function to invoke.\n * @param {(a: R) => R} f7 - The seventh function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function square(n) {\n *   return n * n;\n * }\n *\n * var addSquare = flow([add, square]);\n * addSquare(1, 2);\n * // => 9\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5,\n  f6: (a: R5) => R6,\n  f7: (a: R6) => R7\n): (...args: A) => R7;\n/**\n * Creates a new function that executes up to 7 functions in sequence, with additional functions flattened.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toString = (n: number) => n.toString();\n *\n * const combined = flow(add, square, double, toString);\n * console.log(combined(1, 2)); // \"18\"\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5,\n  f6: (a: R5) => R6,\n  f7: (a: R6) => R7,\n  ...func: Array<Many<(a: any) => any>>\n): (...args: A) => any;\n\n/**\n * Creates a new function that executes 6 functions in sequence.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5, R6>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5,\n  f6: (a: R5) => R6\n): (...args: A) => R6;\n\n/**\n * Creates a new function that executes 5 functions in sequence.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5\n): (...args: A) => R5;\n\n/**\n * Creates a new function that executes 4 functions in sequence.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3, R4>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4\n): (...args: A) => R4;\n\n/**\n * Creates a new function that executes 3 functions in sequence.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3\n): (...args: A) => R3;\n\n/**\n * Creates a new function that executes 2 functions in sequence.\n * The return value of the first function is passed as an argument to the second function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const addThenSquare = flow(add, square);\n * console.log(addThenSquare(1, 2)); // 9\n */\nexport function flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\n\n/**\n * Creates a new function that executes the given functions in sequence.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow([add, square], double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow(...funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any {\n  const flattenFuncs = flatten(funcs, 1);\n  if (flattenFuncs.some(func => typeof func !== 'function')) {\n    throw new TypeError('Expected a function');\n  }\n  return flowToolkit(...flattenFuncs);\n}\n","import { flatten } from '../../array/flatten.ts';\nimport { flowRight as flowRightToolkit } from '../../function/flowRight.ts';\nimport { Many } from '../_internal/Many.ts';\n\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * @template A - The type of the arguments.\n * @template R - The type of the return values.\n * @param {(a: R) => R} f7 - The seventh function to invoke.\n * @param {(a: R) => R} f6 - The sixth function to invoke.\n * @param {(a: R) => R} f5 - The fifth function to invoke.\n * @param {(a: R) => R} f4 - The fourth function to invoke.\n * @param {(a: R) => R} f3 - The third function to invoke.\n * @param {(a: R) => R} f2 - The second function to invoke.\n * @param {(...args: A) => R} f1 - The first function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function square(n) {\n *   return n * n;\n * }\n *\n * var addSquare = flowRight(square, add);\n * addSquare(1, 2);\n * // => 9\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n  f7: (a: R6) => R7,\n  f6: (a: R5) => R6,\n  f5: (a: R4) => R5,\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R7;\n/**\n * Creates a new function that executes 6 functions in sequence from right to left.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toString = (n: number) => String(n);\n * const append = (s: string) => s + '!';\n * const length = (s: string) => s.length;\n *\n * const combined = flowRight(length, append, toString, double, square, add);\n * console.log(combined(1, 2)); // 7\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4, R5, R6>(\n  f6: (a: R5) => R6,\n  f5: (a: R4) => R5,\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R6;\n\n/**\n * Creates a new function that executes 5 functions in sequence from right to left.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toString = (n: number) => String(n);\n * const append = (s: string) => s + '!';\n *\n * const combined = flowRight(append, toString, double, square, add);\n * console.log(combined(1, 2)); // '18!'\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4, R5>(\n  f5: (a: R4) => R5,\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R5;\n\n/**\n * Creates a new function that executes 4 functions in sequence from right to left.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toString = (n: number) => String(n);\n *\n * const combined = flowRight(toString, double, square, add);\n * console.log(combined(1, 2)); // '18'\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4>(\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R4;\n\n/**\n * Creates a new function that executes 3 functions in sequence from right to left.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, square, add);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight<A extends any[], R1, R2, R3>(\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R3;\n\n/**\n * Creates a new function that executes 2 functions in sequence from right to left.\n * The return value of the first function is passed as an argument to the second function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight<A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2;\n\n/**\n * Creates a new function that executes the given functions in sequence from right to left.\n * The return value of each function is passed as an argument to the next function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toString = (n: number) => String(n);\n *\n * // Pass functions as separate arguments\n * const combined1 = flowRight(toString, double, square, add);\n * console.log(combined1(1, 2)); // '18'\n *\n * // Pass functions as arrays\n * const combined2 = flowRight([toString, double], [square, add]);\n * console.log(combined2(1, 2)); // '18'\n */\nexport function flowRight(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {Array<((...args: any[]) => any) | Array<(...args: any[]) => any>>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, [square, add]);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight(...funcs: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any {\n  const flattenFuncs = flatten(funcs, 1);\n  if (flattenFuncs.some(func => typeof func !== 'function')) {\n    throw new TypeError('Expected a function');\n  }\n  return flowRightToolkit(...flattenFuncs);\n}\n","import { flow } from './flow.ts';\n\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *   return 42;\n * }\n * const combined = flowRight(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flowRight<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *  return a * 2;\n * }\n * const combined = flowRight(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flowRight<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight<A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flowRight(double, square, add);\n * console.log(combined(1, 2)); // 18\n */\nexport function flowRight<A extends any[], R1, R2, R3>(\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flowRight(toStr, double, square, add);\n * console.log(combined(1, 2));  // '18'\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4>(\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flowRight(split, toStr, double, square, add);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flowRight<A extends any[], R1, R2, R3, R4, R5>(\n  f5: (a: R4) => R5,\n  f4: (a: R3) => R4,\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (...args: A) => R1\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: any[]) => any} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence from right to left. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * This method is like `flow` except that it creates a function that invokes the given functions from right to left.\n *\n * @param {(...args: any[]) => any} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flowRight(square, add);\n * console.log(combined(1, 2)); // 9\n */\nexport function flowRight(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any {\n  return flow(...funcs.reverse());\n}\n","interface MapCache {\n  /**\n   * Removes the value associated with the specified key from the cache.\n   *\n   * @param key - The key of the value to remove\n   * @returns `true` if an element was removed, `false` if the key wasn't found\n   *\n   * @example\n   * ```typescript\n   * cache.set('user', { id: 123, name: 'John' });\n   * cache.delete('user'); // Returns true\n   * cache.delete('unknown'); // Returns false\n   * ```\n   */\n  delete(key: any): boolean;\n\n  /**\n   * Retrieves the value associated with the specified key from the cache.\n   *\n   * @param key - The key of the value to retrieve\n   * @returns The cached value or undefined if not found\n   *\n   * @example\n   * ```typescript\n   * cache.set('user', { id: 123, name: 'John' });\n   * cache.get('user'); // Returns { id: 123, name: 'John' }\n   * cache.get('unknown'); // Returns undefined\n   * ```\n   */\n  get(key: any): any;\n\n  /**\n   * Checks if the cache contains a value for the specified key.\n   *\n   * @param key - The key to check for existence\n   * @returns `true` if the key exists in the cache, otherwise `false`\n   *\n   * @example\n   * ```typescript\n   * cache.set('user', { id: 123, name: 'John' });\n   * cache.has('user'); // Returns true\n   * cache.has('unknown'); // Returns false\n   * ```\n   */\n  has(key: any): boolean;\n\n  /**\n   * Stores a value in the cache with the specified key.\n   * If the key already exists, its value is updated.\n   *\n   * @param key - The key to associate with the value\n   * @param value - The value to store in the cache\n   * @returns The cache instance for method chaining\n   *\n   * @example\n   * ```typescript\n   * cache.set('user', { id: 123, name: 'John' })\n   *      .set('settings', { theme: 'dark' });\n   * ```\n   */\n  set(key: any, value: any): this;\n\n  /**\n   * Removes all key-value pairs from the cache.\n   * This method is optional as some cache implementations may be immutable.\n   *\n   * @example\n   * ```typescript\n   * cache.set('user', { id: 123, name: 'John' });\n   * cache.set('settings', { theme: 'dark' });\n   * cache.clear(); // Cache is now empty\n   * ```\n   */\n  clear?(): void;\n}\n\n/**\n * Constructor interface for creating a new MapCache instance.\n * This defines the shape of a constructor that can create cache objects\n * conforming to the MapCache interface.\n *\n * @example\n * ```typescript\n * class CustomCache implements MapCache {\n *   // Cache implementation\n * }\n *\n * const CacheConstructor: MapCacheConstructor = CustomCache;\n * const cache = new CacheConstructor();\n * ```\n */\ninterface MapCacheConstructor {\n  new (): MapCache;\n}\n\n/**\n * Represents a function that has been memoized.\n * A memoized function maintains the same signature as the original function\n * but adds a cache property to store previously computed results.\n *\n * @template T - The type of the original function being memoized\n */\n\ninterface MemoizedFunction {\n  /**\n   * The cache storing previously computed results\n   */\n  cache: MapCache;\n}\n\n/**\n * Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for\n * storing the result based on the arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is coerced to a string and used as the cache key. The func is invoked with\n * the this binding of the memoized function.\n *\n * @template T - The type of the original function being memoized\n * @param {T} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @return {MemoizedFunction<T>} Returns the new memoizing function.\n */\nexport function memoize<T extends (...args: any) => any>(\n  func: T,\n  resolver?: (...args: Parameters<T>) => any\n): T & MemoizedFunction {\n  if (typeof func !== 'function' || (resolver != null && typeof resolver !== 'function')) {\n    throw new TypeError('Expected a function');\n  }\n\n  const memoized = function (this: unknown, ...args: Parameters<T>) {\n    const key = resolver ? resolver.apply(this, args) : args[0];\n    const cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n\n  const CacheConstructor = memoize.Cache || Map;\n  memoized.cache = new CacheConstructor();\n\n  return memoized as T & MemoizedFunction;\n}\n\nmemoize.Cache = Map as unknown as MapCacheConstructor;\n","import { toInteger } from '../util/toInteger.ts';\n\n/**\n * Creates a function that gets the argument at index `n`. If `n` is negative, the nth argument from the end is returned.\n *\n * @param {number} [n=0] - The index of the argument to return.\n * @returns {(...args: any[]) => any} Returns the new function.\n *\n * @example\n * var func = nthArg(1);\n * func('a', 'b', 'c', 'd');\n * // => 'b'\n *\n * var func = nthArg(-2);\n * func('a', 'b', 'c', 'd');\n * // => 'c'\n */\nexport function nthArg(n?: number): (...args: any[]) => any;\n\n/**\n * Creates a function that retrieves the argument at the specified index `n`.\n *\n * If `n` is negative, the nth argument from the end is returned.\n *\n * @param {number} [n=0] - The index of the argument to retrieve.\n *   If negative, counts from the end of the arguments list.\n * @returns {(args: any[]) => unknown} A new function that returns the argument at the specified index.\n *\n * @example\n * const getSecondArg = nthArg(1);\n * const result = getSecondArg('a', 'b', 'c');\n * console.log(result); // => 'b'\n *\n * @example\n * const getLastArg = nthArg(-1);\n * const result = getLastArg('a', 'b', 'c');\n * console.log(result); // => 'c'\n */\nexport function nthArg(n = 0): (...args: any[]) => unknown {\n  return function (...args: any[]) {\n    return args.at(toInteger(n));\n  };\n}\n","import { once as onceToolkit } from '../../function/once.ts';\n\nexport function once<T extends (...args: any) => any>(func: T): T {\n  return onceToolkit(func);\n}\n","/**\n * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value of the first invocation.\n *\n * @template T - The type of the function.\n * @param {T} func - The function to restrict.\n * @returns {T} Returns the new restricted function.\n *\n * @example\n * var initialize = once(createApplication);\n * initialize();\n * initialize();\n * // => `createApplication` is invoked once\n */\nexport function once<T extends (...args: any) => any>(func: T): T;\n\n/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F} func - The function to restrict.\n * @returns {(...args: Parameters<F>) => ReturnType<F>} A new function that invokes `func` once and caches the result.\n *\n * @example\n * const initialize = once(() => {\n *   console.log('Initialized!');\n *   return true;\n * });\n *\n * initialize(); // Logs: 'Initialized!' and returns true\n * initialize(); // Returns true without logging\n */\nexport function once<F extends (() => any) | ((...args: any[]) => void)>(func: F): F {\n  let called = false;\n  let cache: ReturnType<F>;\n\n  return function (...args: Parameters<F>): ReturnType<F> {\n    if (!called) {\n      called = true;\n      cache = func(...args);\n    }\n\n    return cache;\n  } as F;\n}\n","import { identity } from '../../function/identity.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a function that invokes `func` with its arguments transformed by corresponding transform functions.\n *\n * Transform functions can be:\n * - Functions that accept and return a value\n * - Property names (strings) to get a property value from each argument\n * - Objects to check if arguments match the object properties\n * - Arrays of [property, value] to check if argument properties match values\n *\n * If a transform is nullish, the identity function is used instead.\n * Only transforms arguments up to the number of transform functions provided.\n *\n * @template F - The type of the function to wrap\n * @template T - The type of the transform functions array\n * @param {F} func - The function to wrap\n * @param {T} transforms - The functions to transform arguments. Each transform can be:\n *   - A function that accepts and returns a value\n *   - A string to get a property value (e.g. 'name' gets the name property)\n *   - An object to check if arguments match its properties\n *   - An array of [property, value] to check property matches\n * @returns {(...args: any[]) => ReturnType<F>} A new function that transforms arguments before passing them to func\n * @throws {TypeError} If func is not a function.\n * @example\n * ```ts\n * function doubled(n: number) {\n *   return n * 2;\n * }\n *\n * function square(n: number) {\n *   return n * n;\n * }\n *\n * const func = overArgs((x, y) => [x, y], [doubled, square]);\n *\n * func(5, 3);\n * // => [10, 9]\n *\n * // With property shorthand\n * const user = { name: 'John', age: 30 };\n * const getUserInfo = overArgs(\n *   (name, age) => `${name} is ${age} years old`,\n *   ['name', 'age']\n * );\n * getUserInfo(user, user);\n * // => \"John is 30 years old\"\n * ```\n */\nexport function overArgs(\n  func: (...args: any[]) => any,\n  ..._transforms: Array<Many<(...args: any[]) => any>>\n): (...args: any[]) => any {\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  const transforms = _transforms.flat();\n\n  return function (this: any, ...args: any[]) {\n    const length = Math.min(args.length, transforms.length);\n    const transformedArgs = [...args];\n\n    for (let i = 0; i < length; i++) {\n      const transform = iteratee(transforms[i] ?? identity);\n      transformedArgs[i] = transform.call(this, args[i]);\n    }\n\n    return func.apply(this, transformedArgs);\n  };\n}\n","import { partialImpl } from '../../function/partial.ts';\nimport type { Toolkit } from '../toolkit.ts';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype __ = Placeholder | Toolkit;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting} ${name}`;\n * const sayHello = partial(greet, _, 'world');\n * console.log(sayHello('Hello')); // => 'Hello world'\n */\nexport function partial<T1, T2, R>(func: (t1: T1, t2: T2) => R, plc1: __, arg2: T2): (t1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const calculate = (x: number, y: number, z: number) => x + y + z;\n * const addToY = partial(calculate, _, 2);\n * console.log(addToY(1, 3)); // => 6\n */\nexport function partial<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, plc1: __, arg2: T2): (t1: T1, t3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const calculate = (x: number, y: number, z: number) => x + y + z;\n * const addZ = partial(calculate, _, _, 3);\n * console.log(addZ(1, 2)); // => 6\n */\nexport function partial<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  plc1: __,\n  plc2: __,\n  arg3: T3\n): (t1: T1, t2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const calculate = (x: number, y: number, z: number) => x + y + z;\n * const withXandZ = partial(calculate, 1, _, 3);\n * console.log(withXandZ(2)); // => 6\n */\nexport function partial<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arg1: T1,\n  plc2: __,\n  arg3: T3\n): (t2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const calculate = (x: number, y: number, z: number) => x + y + z;\n * const withYandZ = partial(calculate, _, 2, 3);\n * console.log(withYandZ(1)); // => 6\n */\nexport function partial<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  plc1: __,\n  arg2: T2,\n  arg3: T3\n): (t1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withB = partial(format, _, 'b');\n * console.log(withB('a', 'c', 'd')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  arg2: T2\n): (t1: T1, t3: T3, t4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withC = partial(format, _, _, 'c');\n * console.log(withC('a', 'b', 'd')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  plc2: __,\n  arg3: T3\n): (t1: T1, t2: T2, t4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withAandC = partial(format, 'a', _, 'c');\n * console.log(withAandC('b', 'd')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  arg3: T3\n): (t2: T2, t4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withBandC = partial(format, _, 'b', 'c');\n * console.log(withBandC('a', 'd')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  arg2: T2,\n  arg3: T3\n): (t1: T1, t4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withD = partial(format, _, _, _, 'd');\n * console.log(withD('a', 'b', 'c')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  plc2: __,\n  plc3: __,\n  arg4: T4\n): (t1: T1, t2: T2, t3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withAandD = partial(format, 'a', _, _, 'd');\n * console.log(withAandD('b', 'c')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  plc3: __,\n  arg4: T4\n): (t2: T2, t3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withBandD = partial(format, _, 'b', _, 'd');\n * console.log(withBandD('a', 'c')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  arg2: T2,\n  plc3: __,\n  arg4: T4\n): (t1: T1, t3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withABandD = partial(format, 'a', 'b', _, 'd');\n * console.log(withABandD('c')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  plc3: __,\n  arg4: T4\n): (t3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withCandD = partial(format, _, _, 'c', 'd');\n * console.log(withCandD('a', 'b')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  plc2: __,\n  arg3: T3,\n  arg4: T4\n): (t1: T1, t2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withACandD = partial(format, 'a', _, 'c', 'd');\n * console.log(withACandD('b')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  arg3: T3,\n  arg4: T4\n): (t2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string) => `${a}-${b}-${c}-${d}`;\n * const withBCandD = partial(format, _, 'b', 'c', 'd');\n * console.log(withBCandD('a')); // => 'a-b-c-d'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  plc1: __,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (t1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const sum = (...numbers: number[]) => numbers.reduce((a, b) => a + b, 0);\n * const partialSum = partial(sum);\n * console.log(partialSum(1, 2, 3)); // => 6\n */\nexport function partial<TS extends any[], R>(func: (...ts: TS) => R): (...ts: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const log = (prefix: string, ...messages: string[]) => console.log(prefix, ...messages);\n * const debugLog = partial(log, '[DEBUG]');\n * debugLog('message 1', 'message 2'); // => '[DEBUG] message 1 message 2'\n */\nexport function partial<TS extends any[], T1, R>(func: (t1: T1, ...ts: TS) => R, arg1: T1): (...ts: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (prefix: string, separator: string, ...messages: string[]) => `${prefix}${messages.join(separator)}`;\n * const logWithPrefix = partial(format, '[LOG]', ' - ');\n * console.log(logWithPrefix('msg1', 'msg2')); // => '[LOG]msg1 - msg2'\n */\nexport function partial<TS extends any[], T1, T2, R>(\n  func: (t1: T1, t2: T2, ...ts: TS) => R,\n  t1: T1,\n  t2: T2\n): (...ts: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (type: string, level: string, message: string, ...tags: string[]) =>\n *   `[${type}][${level}] ${message} ${tags.join(',')}`;\n * const errorLog = partial(format, 'ERROR', 'HIGH', 'Something went wrong');\n * console.log(errorLog('critical', 'urgent')); // => '[ERROR][HIGH] Something went wrong critical,urgent'\n */\nexport function partial<TS extends any[], T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3, ...ts: TS) => R,\n  t1: T1,\n  t2: T2,\n  t3: T3\n): (...ts: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * @example\n * const format = (a: string, b: string, c: string, d: string, ...rest: string[]) =>\n *   `${a}-${b}-${c}-${d}:${rest.join(',')}`;\n * const prefixedFormat = partial(format, 'a', 'b', 'c', 'd');\n * console.log(prefixedFormat('e', 'f')); // => 'a-b-c-d:e,f'\n */\nexport function partial<TS extends any[], T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: TS) => R,\n  t1: T1,\n  t2: T2,\n  t3: T3,\n  t4: T4\n): (...ts: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const sayHelloTo = partial(greet, 'hello');\n * sayHelloTo('fred');\n * // => 'hello fred'\n *\n * // Partially applied with placeholders.\n * const greetFred = partial(greet, partial.placeholder, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return partialImpl<F, Placeholder>(func, partial.placeholder, ...partialArgs);\n}\n\npartial.placeholder = Symbol('compat.partial.placeholder') as Placeholder;\n\ntype Placeholder = symbol | (((value: any) => any) & { partial: typeof partial });\n","/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(): R} A new function that takes no arguments and returns the result of the original function.\n *\n * @example\n * const addOne = (x: number) => x + 1;\n * const addOneToFive = partial(addOne, 5);\n * console.log(addOneToFive()); // => 6\n */\nexport function partial<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number) => x * y;\n * const double = partial(multiply, 2);\n * console.log(double(5)); // => 10\n */\nexport function partial<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2): R} func The function to partially apply.\n * @param {Placeholder} placeholder The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg1: T1): R} A new function that takes the first argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithHello = partial(greet, partial.placeholder, 'John');\n * console.log(greetWithHello('Hello')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, R>(\n  func: (arg1: T1, arg2: T2) => R,\n  placeholder: Placeholder,\n  arg2: T2\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2, arg3: T3): R} A new function that takes the second and third arguments and returns the result of the original function.\n *\n * @example\n * const sumThree = (a: number, b: number, c: number) => a + b + c;\n * const addFive = partial(sumThree, 5);\n * console.log(addFive(3, 2)); // => 10\n */\nexport function partial<T1, T2, T3, R>(func: (arg1: T1, arg2: T2, arg3: T3) => R, arg1: T1): (arg2: T2, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, partial.placeholder, 'John');\n * console.log(greetWithPlaceholder('Hello')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: Placeholder,\n  arg2: T2\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number) => x * y * z;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2);\n * console.log(multiplyWithPlaceholders(3, 4)); // => 24\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder);\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The first argument to apply.\n * @param {T2} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder);\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  plc1: Placeholder,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const double = partial(multiply, 2);\n * console.log(double(5, 4, 3)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1\n): (arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholders(4, 5)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg3: T3, arg4: T4): R} A new function that takes the third and fourth arguments and returns the result of the original function.\n *\n * @example\n * const sumFour = (a: number, b: number, c: number, d: number) => a + b + c + d;\n * const addOneAndTwo = partial(sumFour, 1, 2);\n * console.log(addOneAndTwo(3, 4)); // => 10\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2\n): (arg3: T3, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg2: T2, arg4: T4): R} A new function that takes the second and fourth arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder, '!');\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholder = partial(multiply, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholder(4)); // => 24\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholders(4, 5)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg4: T4): R} A new function that takes the fourth argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): (arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg3: T3): R} A new function that takes the third argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1): R} A new function that takes the first argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template R The return type of the function.\n * @param {function(...args: TS): R} func The function to partially apply.\n * @returns {function(...args: TS): R} A new function that takes the same arguments as the original function.\n *\n * @example\n * const add = (...numbers: number[]) => numbers.reduce((sum, n) => sum + n, 0);\n * const addFive = partial(add, 5);\n * console.log(addFive(1, 2, 3)); // => 11\n */\nexport function partial<TS extends any[], R>(func: (...args: TS) => R): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, ...args: TS): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, ...names: string[]) => `${greeting}, ${names.join(', ')}!`;\n * const greetHello = partial(greet, 'Hello');\n * console.log(greetHello('Alice', 'Bob')); // => 'Hello, Alice, Bob!'\n */\nexport function partial<TS extends any[], T1, R>(func: (arg1: T1, ...args: TS) => R, arg1: T1): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, ...args: TS): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', '!');\n * console.log(greetWithHello('John')); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, R>(\n  func: (arg1: T1, arg2: T2, ...args: TS) => R,\n  t1: T1,\n  arg2: T2\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(t1: T1, arg2: T2, arg3: T3, ...args: TS): R} func The function to partially apply.\n * @param {T1} t1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', 'John', '!');\n * console.log(greetWithHello()); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, T3, R>(\n  func: (t1: T1, arg2: T2, arg3: T3, ...args: TS) => R,\n  t1: T1,\n  arg2: T2,\n  arg3: T3\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(t1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: TS): R} func The function to partially apply.\n * @param {T1} t1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', 'John', '!');\n * console.log(greetWithHello()); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, T3, T4, R>(\n  func: (t1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: TS) => R,\n  t1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply.\n * @param {...any[]} partialArgs The arguments to be partially applied.\n * @returns {function(...args: any[]): ReturnType<F>} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const add = (...numbers: number[]) => numbers.reduce((sum, n) => sum + n, 0);\n * const addFive = partial(add, 5);\n * console.log(addFive(1, 2, 3)); // => 11\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F>;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const sayHelloTo = partial(greet, 'hello');\n * sayHelloTo('fred');\n * // => 'hello fred'\n *\n * // Partially applied with placeholders.\n * const greetFred = partial(greet, partial.placeholder, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return partialImpl<F, Placeholder>(func, placeholderSymbol, ...partialArgs);\n}\n\nexport function partialImpl<F extends (...args: any[]) => any, P>(\n  func: F,\n  placeholder: P,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  const partialed = function (this: unknown, ...providedArgs: any[]) {\n    let providedArgsIndex = 0;\n\n    const substitutedArgs: any[] = partialArgs\n      .slice()\n      .map(arg => (arg === placeholder ? providedArgs[providedArgsIndex++] : arg));\n\n    const remainingArgs = providedArgs.slice(providedArgsIndex);\n\n    return func.apply(this, substitutedArgs.concat(remainingArgs));\n  };\n\n  if (func.prototype) {\n    partialed.prototype = Object.create(func.prototype);\n  }\n\n  return partialed;\n}\n\nconst placeholderSymbol: unique symbol = Symbol('partial.placeholder');\npartial.placeholder = placeholderSymbol;\n\ntype Placeholder = typeof placeholderSymbol;\n","import { partialRightImpl } from '../../function/partialRight.ts';\nimport type { Toolkit } from '../toolkit.ts';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype __ = Placeholder | Toolkit;\n\n/**\n * Creates a function that invokes the provided function with no arguments.\n *\n * @template R The return type of the function\n * @param {() => R} func The function to partially apply\n * @returns {() => R} Returns the new partially applied function\n *\n * @example\n * const greet = () => 'Hello!';\n * const sayHello = partialRight(greet);\n * sayHello(); // => 'Hello!'\n */\nexport function partialRight<R>(func: () => R): () => R;\n\n/**\n * Creates a function that invokes the provided function with one argument.\n *\n * @template T The type of the argument\n * @template R The return type of the function\n * @param {(t1: T) => R} func The function to partially apply\n * @returns {(t1: T) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (name: string) => `Hello ${name}!`;\n * const greetPerson = partialRight(greet);\n * greetPerson('Fred'); // => 'Hello Fred!'\n */\nexport function partialRight<T, R>(func: (t1: T) => R): (t1: T) => R;\n\n/**\n * Creates a function that invokes the provided function with one argument pre-filled.\n *\n * @template T The type of the argument\n * @template R The return type of the function\n * @param {(t1: T) => R} func The function to partially apply\n * @param {T} arg1 The argument to pre-fill\n * @returns {() => R} Returns the new partially applied function\n *\n * @example\n * const greet = (name: string) => `Hello ${name}!`;\n * const greetFred = partialRight(greet, 'Fred');\n * greetFred(); // => 'Hello Fred!'\n */\nexport function partialRight<T, R>(func: (t1: T) => R, arg1: T): () => R;\n\n/**\n * Creates a function that invokes the provided function with two arguments.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2) => R} func The function to partially apply\n * @returns {(t1: T1, t2: T2) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting} ${name}!`;\n * const greetWithParams = partialRight(greet);\n * greetWithParams('Hi', 'Fred'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, R>(func: (t1: T1, t2: T2) => R): (t1: T1, t2: T2) => R;\n\n/**\n * Creates a function that invokes the provided function with one argument pre-filled and a placeholder.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2) => R} func The function to partially apply\n * @param {T1} arg1 The argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @returns {(t2: T2) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting} ${name}!`;\n * const hiWithName = partialRight(greet, 'Hi', partialRight.placeholder);\n * hiWithName('Fred'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, R>(func: (t1: T1, t2: T2) => R, arg1: T1, plc2: __): (t2: T2) => R;\n\n/**\n * Creates a function that invokes the provided function with the second argument pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2) => R} func The function to partially apply\n * @param {T2} arg2 The argument to pre-fill\n * @returns {(t1: T1) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting} ${name}!`;\n * const greetFred = partialRight(greet, 'Fred');\n * greetFred('Hi'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, R>(func: (t1: T1, t2: T2) => R, arg2: T2): (t1: T1) => R;\n\n/**\n * Creates a function that invokes the provided function with both arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @returns {() => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting} ${name}!`;\n * const sayHiToFred = partialRight(greet, 'Hi', 'Fred');\n * sayHiToFred(); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, R>(func: (t1: T1, t2: T2) => R, arg1: T1, arg2: T2): () => R;\n/**\n * Creates a function that invokes the provided function with no pre-filled arguments.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @returns {(t1: T1, t2: T2, t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const greetWithArgs = partialRight(greet);\n * greetWithArgs('Hi', 'Fred', '!'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R): (t1: T1, t2: T2, t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the first argument pre-filled and placeholders for the rest.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @param {__} plc3 The placeholder for the third argument\n * @returns {(t2: T2, t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const hiWithNameAndPunc = partialRight(greet, 'Hi', partialRight.placeholder, partialRight.placeholder);\n * hiWithNameAndPunc('Fred', '!'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arg1: T1,\n  plc2: __,\n  plc3: __\n): (t2: T2, t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the second argument pre-filled and a placeholder for the third.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T2} arg2 The second argument to pre-fill\n * @param {__} plc3 The placeholder for the third argument\n * @returns {(t1: T1, t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const greetFredWithPunc = partialRight(greet, 'Fred', partialRight.placeholder);\n * greetFredWithPunc('Hi', '!'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arg2: T2,\n  plc3: __\n): (t1: T1, t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the first two arguments pre-filled and a placeholder for the third.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @param {__} plc3 The placeholder for the third argument\n * @returns {(t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const hiToFredWithPunc = partialRight(greet, 'Hi', 'Fred', partialRight.placeholder);\n * hiToFredWithPunc('!'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  plc3: __\n): (t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the third argument pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T3} arg3 The third argument to pre-fill\n * @returns {(t1: T1, t2: T2) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const greetWithExclamation = partialRight(greet, '!');\n * greetWithExclamation('Hi', 'Fred'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arg3: T3): (t1: T1, t2: T2) => R;\n\n/**\n * Creates a function that invokes the provided function with the first and third arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @param {T3} arg3 The third argument to pre-fill\n * @returns {(t2: T2) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const hiWithNameAndExclamation = partialRight(greet, 'Hi', partialRight.placeholder, '!');\n * hiWithNameAndExclamation('Fred'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (t1: T1, t2: T2, t3: T3) => R,\n  arg1: T1,\n  plc2: __,\n  arg3: T3\n): (t2: T2) => R;\n\n/**\n * Creates a function that invokes the provided function with the second and third arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T2} arg2 The second argument to pre-fill\n * @param {T3} arg3 The third argument to pre-fill\n * @returns {(t1: T1) => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const greetFredWithExclamation = partialRight(greet, 'Fred', '!');\n * greetFredWithExclamation('Hi'); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arg2: T2, arg3: T3): (t1: T1) => R;\n\n/**\n * Creates a function that invokes the provided function with all three arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @param {T3} arg3 The third argument to pre-fill\n * @returns {() => R} Returns the new partially applied function\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting} ${name}${punctuation}`;\n * const sayHiToFredWithExclamation = partialRight(greet, 'Hi', 'Fred', '!');\n * sayHiToFredWithExclamation(); // => 'Hi Fred!'\n */\nexport function partialRight<T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arg1: T1, arg2: T2, arg3: T3): () => R;\n\n/**\n * Creates a function that invokes the provided function with no pre-filled arguments.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @returns {(t1: T1, t2: T2, t3: T3, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const formatWithArgs = partialRight(format);\n * formatWithArgs('Hi', 'Fred', 'morning', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R\n): (t1: T1, t2: T2, t3: T3, t4: T4) => R;\n/**\n * Creates a function that invokes the provided function with the first argument pre-filled and placeholders for the rest.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @param {__} plc3 The placeholder for the third argument\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t2: T2, t3: T3, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiWithRest = partialRight(format, 'Hi', partialRight.placeholder, partialRight.placeholder, partialRight.placeholder);\n * hiWithRest('Fred', 'morning', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  plc3: __,\n  plc4: __\n): (t2: T2, t3: T3, t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the second argument pre-filled and placeholders for the rest.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T2} arg2 The second argument to pre-fill\n * @param {__} plc3 The placeholder for the third argument\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t1: T1, t3: T3, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const greetFredWithRest = partialRight(format, 'Fred', partialRight.placeholder, partialRight.placeholder);\n * greetFredWithRest('Hi', 'morning', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg2: T2,\n  plc3: __,\n  plc4: __\n): (t1: T1, t3: T3, t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the first two arguments pre-filled and placeholders for the rest.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @param {__} plc3 The placeholder for the third argument\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t3: T3, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiToFredWithRest = partialRight(format, 'Hi', 'Fred', partialRight.placeholder, partialRight.placeholder);\n * hiToFredWithRest('morning', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  plc3: __,\n  plc4: __\n): (t3: T3, t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the third argument pre-filled and a placeholder for the fourth.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T3} arg3 The third argument to pre-fill\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t1: T1, t2: T2, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const atMorningWithPunc = partialRight(format, 'morning', partialRight.placeholder);\n * atMorningWithPunc('Hi', 'Fred', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg3: T3,\n  plc4: __\n): (t1: T1, t2: T2, t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the first and third arguments pre-filled and a placeholder for the fourth.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @param {T3} arg3 The third argument to pre-fill\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t2: T2, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiAtMorningWithNameAndPunc = partialRight(format, 'Hi', partialRight.placeholder, 'morning', partialRight.placeholder);\n * hiAtMorningWithNameAndPunc('Fred', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  arg3: T3,\n  plc4: __\n): (t2: T2, t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the second and third arguments pre-filled and a placeholder for the fourth.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T2} arg2 The second argument to pre-fill\n * @param {T3} arg3 The third argument to pre-fill\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t1: T1, t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const greetFredAtMorningWithPunc = partialRight(format, 'Fred', 'morning', partialRight.placeholder);\n * greetFredAtMorningWithPunc('Hi', '!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  plc4: __\n): (t1: T1, t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the first three arguments pre-filled and a placeholder for the fourth.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @param {T3} arg3 The third argument to pre-fill\n * @param {__} plc4 The placeholder for the fourth argument\n * @returns {(t4: T4) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiToFredAtMorningWithPunc = partialRight(format, 'Hi', 'Fred', 'morning', partialRight.placeholder);\n * hiToFredAtMorningWithPunc('!'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  plc4: __\n): (t4: T4) => R;\n\n/**\n * Creates a function that invokes the provided function with the fourth argument pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t1: T1, t2: T2, t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const withExclamation = partialRight(format, '!');\n * withExclamation('Hi', 'Fred', 'morning'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg4: T4\n): (t1: T1, t2: T2, t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the first and fourth arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @param {__} plc3 The placeholder for the third argument\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t2: T2, t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiWithExclamation = partialRight(format, 'Hi', partialRight.placeholder, partialRight.placeholder, '!');\n * hiWithExclamation('Fred', 'morning'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  plc3: __,\n  arg4: T4\n): (t2: T2, t3: T3) => R;\n/**\n * Creates a function that invokes the provided function with the second and fourth arguments pre-filled and a placeholder for the third.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T2} arg2 The second argument to pre-fill\n * @param {__} plc3 The placeholder for the third argument\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t1: T1, t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const greetFredWithTime = partialRight(format, 'Fred', partialRight.placeholder, '!');\n * greetFredWithTime('Hi', 'morning'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg2: T2,\n  plc3: __,\n  arg4: T4\n): (t1: T1, t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the first, second and fourth arguments pre-filled and a placeholder for the third.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @param {__} plc3 The placeholder for the third argument\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t3: T3) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiToFredWithTime = partialRight(format, 'Hi', 'Fred', partialRight.placeholder, '!');\n * hiToFredWithTime('morning'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  plc3: __,\n  arg4: T4\n): (t3: T3) => R;\n\n/**\n * Creates a function that invokes the provided function with the third and fourth arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T3} arg3 The third argument to pre-fill\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t1: T1, t2: T2) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const inMorningWithExclamation = partialRight(format, 'morning', '!');\n * inMorningWithExclamation('Hi', 'Fred'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg3: T3,\n  arg4: T4\n): (t1: T1, t2: T2) => R;\n\n/**\n * Creates a function that invokes the provided function with the first, third and fourth arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {__} plc2 The placeholder for the second argument\n * @param {T3} arg3 The third argument to pre-fill\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t2: T2) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const hiInMorningWithExclamation = partialRight(format, 'Hi', partialRight.placeholder, 'morning', '!');\n * hiInMorningWithExclamation('Fred'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  plc2: __,\n  arg3: T3,\n  arg4: T4\n): (t2: T2) => R;\n\n/**\n * Creates a function that invokes the provided function with the second, third and fourth arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T2} arg2 The second argument to pre-fill\n * @param {T3} arg3 The third argument to pre-fill\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {(t1: T1) => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const greetFredInMorningWithExclamation = partialRight(format, 'Fred', 'morning', '!');\n * greetFredInMorningWithExclamation('Hi'); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (t1: T1) => R;\n\n/**\n * Creates a function that invokes the provided function with all arguments pre-filled.\n *\n * @template T1 The type of the first argument\n * @template T2 The type of the second argument\n * @template T3 The type of the third argument\n * @template T4 The type of the fourth argument\n * @template R The return type of the function\n * @param {(t1: T1, t2: T2, t3: T3, t4: T4) => R} func The function to partially apply\n * @param {T1} arg1 The first argument to pre-fill\n * @param {T2} arg2 The second argument to pre-fill\n * @param {T3} arg3 The third argument to pre-fill\n * @param {T4} arg4 The fourth argument to pre-fill\n * @returns {() => R} Returns the new partially applied function\n *\n * @example\n * const format = (greeting: string, name: string, time: string, punctuation: string) =>\n *   `${greeting} ${name}, it's ${time}${punctuation}`;\n * const sayHiToFredInMorningWithExclamation = partialRight(format, 'Hi', 'Fred', 'morning', '!');\n * sayHiToFredInMorningWithExclamation(); // => 'Hi Fred, it's morning!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (t1: T1, t2: T2, t3: T3, t4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): () => R;\n\n/**\n * Creates a function that invokes the provided function with partially applied arguments appended to the arguments it receives.\n * The partialRight.placeholder value can be used as a placeholder for partially applied arguments.\n *\n * @template F The type of the function to partially apply\n * @param {F} func The function to partially apply arguments to\n * @param {...any[]} args The arguments to be partially applied\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function\n *\n * @example\n * function greet(greeting: string, name: string) {\n *   return greeting + ' ' + name;\n * }\n *\n * const greetFred = partialRight(greet, 'Fred');\n * greetFred('Hi'); // => 'Hi Fred'\n *\n * // Using placeholders\n * const sayHelloTo = partialRight(greet, 'Hello', partialRight.placeholder);\n * sayHelloTo('Fred'); // => 'Hello Fred'\n */\nexport function partialRight(func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const greetFred = partialRight(greet, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n *\n * // Partially applied with placeholders.\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\n * sayHelloTo('fred');\n * // => 'hello fred'\n */\nexport function partialRight<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return partialRightImpl<F, Placeholder>(func, partialRight.placeholder, ...partialArgs);\n}\n\npartialRight.placeholder = Symbol('compat.partialRight.placeholder') as Placeholder;\n\ntype Placeholder = symbol | (((value: any) => any) & { partialRight: typeof partialRight });\n","/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template R The return type of the function.\n * @param {() => R} func The function to invoke.\n * @returns {() => R} Returns the new function.\n * @example\n * const getValue = () => 42;\n * const getValueFunc = partialRight(getValue);\n * console.log(getValueFunc()); // => 42\n */\nexport function partialRight<R>(func: () => R): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const addOne = (num: number) => num + 1;\n * const addOneFunc = partialRight(addOne, 1);\n * console.log(addOneFunc()); // => 2\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const multiplyBy = (factor: number) => (num: number) => num * factor;\n * const double = partialRight(multiplyBy(2));\n * console.log(double(5)); // => 10\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const greet = (name: string) => `Hello, ${name}!`;\n * const greetJohn = partialRight(greet, 'John');\n * console.log(greetJohn()); // => 'Hello, John!'\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const subtract = (a: number, b: number) => a - b;\n * const subtractFive = partialRight(subtract);\n * console.log(subtractFive(10, 5)); // => 5\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R): (arg1: T1, arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @returns {(arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const concat = (a: string, b: string) => a + b;\n * const concatWithHello = partialRight(concat, 'Hello', partialRight.placeholder);\n * console.log(concatWithHello(' World!')); // => 'Hello World!'\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1, arg2: Placeholder): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const divide = (a: number, b: number) => a / b;\n * const divideByTwo = partialRight(divide, 2);\n * console.log(divideByTwo(10)); // => 5\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg2: T2): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const multiply = (a: number, b: number) => a * b;\n * const multiplyByThreeAndFour = partialRight(multiply, 3, 4);\n * console.log(multiplyByThreeAndFour()); // => 12\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1, arg2: T2): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const sumThree = (a: number, b: number, c: number) => a + b + c;\n * const sumWithFive = partialRight(sumThree);\n * console.log(sumWithFive(1, 2, 5)); // => 8\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R\n): (arg1: T1, arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg2: T2, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const formatDate = (day: number, month: number, year: number) => `${day}/${month}/${year}`;\n * const formatDateWithDay = partialRight(formatDate, 1, partialRight.placeholder, partialRight.placeholder);\n * console.log(formatDateWithDay(12, 2023)); // => '1/12/2023'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder\n): (arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg1: T1, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const createUser = (name: string, age: number, country: string) => `${name}, ${age} years old from ${country}`;\n * const createUserFromUSA = partialRight(createUser, 'USA', partialRight.placeholder);\n * console.log(createUserFromUSA('John', 30)); // => 'John, 30 years old from USA'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg2: T2,\n  arg3: Placeholder\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const logMessage = (level: string, message: string, timestamp: string) => `[${level}] ${message} at ${timestamp}`;\n * const logError = partialRight(logMessage, 'ERROR', '2023-10-01');\n * console.log(logError('Something went wrong!')); // => '[ERROR] Something went wrong! at 2023-10-01'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder\n): (arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const calculateArea = (length: number, width: number) => length * width;\n * const calculateAreaWithWidth = partialRight(calculateArea, 5);\n * console.log(calculateAreaWithWidth(10)); // => 50\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg3: T3\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const formatCurrency = (amount: number, currency: string) => `${amount} ${currency}`;\n * const formatUSD = partialRight(formatCurrency, 100, partialRight.placeholder);\n * console.log(formatUSD('USD')); // => '100 USD'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const createProfile = (name: string, age: number, country: string) => `${name}, ${age} from ${country}`;\n * const createProfileFromCanada = partialRight(createProfile, 'Canada', 'John');\n * console.log(createProfileFromCanada(30)); // => 'John, 30 from Canada'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1) => R;\n\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): () => R;\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} Returns a new function that takes four arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R\n): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg2: T2, arg3: T3, arg4: T4) => R} Returns a new function that takes the second, third, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg3: T3, arg4: T4) => R} Returns a new function that takes the first, third, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg1: T1, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg3: T3, arg4: T4) => R} Returns a new function that takes the third and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg2: T2, arg4: T4) => R} Returns a new function that takes the first, second, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg3: T3,\n  arg4: Placeholder\n): (arg1: T1, arg2: T2, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with the first argument, a placeholder for the second argument,\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg2: T2, arg4: T4) => R} Returns a new function that takes the second and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: Placeholder\n): (arg2: T2, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg4: T4) => R} Returns a new function that takes the first and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: Placeholder\n): (arg1: T1, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg4: T4) => R} Returns a new function that takes the fourth argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: Placeholder\n): (arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2, arg3: T3) => R} Returns a new function that takes the first, second, and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg4: T4\n): (arg1: T1, arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg2: T2, arg3: T3) => R} Returns a new function that takes the second and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder,\n  arg4: T4\n): (arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg3: T3) => R} Returns a new function that takes the first and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg3: T3) => R} Returns a new function that takes the third argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2) => R} Returns a new function that takes the first and second arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg2: T2) => R} Returns a new function that takes the second argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns a new function that takes the first argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const concatenate = (a: string, b: string, c: string, d: string) => a + b + c + d;\n * const concatenateHelloWorld = partialRight(concatenate, 'Hello', ' ', 'World', '!');\n * console.log(concatenateHelloWorld()); // => 'Hello World!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {...any[]} args The arguments to be partially applied.\n * @returns {function(...args: any[]): ReturnType<F>} Returns the new partially applied function.\n * @example\n * const log = (...messages: string[]) => console.log(...messages);\n * const logError = partialRight(log, 'Error:');\n * logError('Something went wrong!'); // => 'Error: Something went wrong!'\n */\nexport function partialRight(func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const greetFred = partialRight(greet, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n *\n * // Partially applied with placeholders.\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\n * sayHelloTo('fred');\n * // => 'hello fred'\n */\nexport function partialRight<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return partialRightImpl<F, Placeholder>(func, placeholderSymbol, ...partialArgs);\n}\n\nexport function partialRightImpl<F extends (...args: any[]) => any, P>(\n  func: F,\n  placeholder: P,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  const partialedRight = function (this: any, ...providedArgs: any[]) {\n    const placeholderLength = partialArgs.filter(arg => arg === placeholder).length;\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n    const remainingArgs: any[] = providedArgs.slice(0, rangeLength);\n\n    let providedArgsIndex = rangeLength;\n\n    const substitutedArgs = partialArgs\n      .slice()\n      .map(arg => (arg === placeholder ? providedArgs[providedArgsIndex++] : arg));\n\n    return func.apply(this, remainingArgs.concat(substitutedArgs));\n  };\n\n  if (func.prototype) {\n    partialedRight.prototype = Object.create(func.prototype);\n  }\n\n  return partialedRight;\n}\n\nconst placeholderSymbol: unique symbol = Symbol('partialRight.placeholder');\npartialRight.placeholder = placeholderSymbol;\n\ntype Placeholder = typeof placeholderSymbol;\n","import { Many } from '../_internal/Many.ts';\nimport { flatten } from '../array/flatten.ts';\n\n/**\n * Creates a function that invokes `func` with arguments arranged according to the specified `indices`\n * where the argument value at the first index is provided as the first argument,\n * the argument value at the second index is provided as the second argument, and so on.\n *\n * @template F The type of the function to re-arrange.\n * @param {F} func The function to rearrange arguments for.\n * @param {Array<number | number[]>} indices The arranged argument indices.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const rearrangedGreet = rearg(greet, 1, 0);\n * console.log(rearrangedGreet('World', 'Hello')); // Output: \"Hello, World!\"\n */\nexport function rearg(func: (...args: any[]) => any, ...indices: Array<Many<number>>): (...args: any[]) => any {\n  const flattenIndices = flatten(indices);\n\n  return function (this: any, ...args: any[]) {\n    const reorderedArgs: any[] = flattenIndices.map(i => args[i]).slice(0, args.length);\n\n    for (let i = reorderedArgs.length; i < args.length; i++) {\n      reorderedArgs.push(args[i]);\n    }\n\n    return func.apply(this, reorderedArgs);\n  };\n}\n","import { rest as restToolkit } from '../../function/rest.ts';\n\n/**\n * Creates a function that transforms the arguments of the provided function `func`.\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\n * are grouped into an array, while the previous arguments are passed as individual elements.\n *\n * @template F - The type of the function being transformed.\n * @param {F} func - The function whose arguments are to be transformed.\n * @param {number} [start=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\n *\n * The transformed arguments are:\n * - The first `start` arguments as individual elements.\n * - The remaining arguments from index `start` onward grouped into an array.\n * @example\n * function fn(a, b, c) {\n *   return [a, b, c];\n * }\n *\n * // Using default start index (func.length - 1, which is 2 in this case)\n * const transformedFn = rest(fn);\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\n *\n * // Using start index 1\n * const transformedFnWithStart = rest(fn, 1);\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\n *\n * // With fewer arguments than the start index\n * console.log(transformedFn(1)); // [1, undefined, []]\n */\nexport function rest(func: (...args: any[]) => any, start: number = func.length - 1): (...args: any[]) => any {\n  start = Number.parseInt(start as any, 10);\n\n  if (Number.isNaN(start) || start < 0) {\n    start = func.length - 1;\n  }\n\n  return restToolkit(func, start);\n}\n","/**\n * Creates a function that transforms the arguments of the provided function `func`.\n * The transformed arguments are passed to `func` such that the arguments starting from a specified index\n * are grouped into an array, while the previous arguments are passed as individual elements.\n *\n * @template F - The type of the function being transformed.\n * @param {F} func - The function whose arguments are to be transformed.\n * @param {number} [startIndex=func.length - 1] - The index from which to start grouping the remaining arguments into an array.\n *                                            Defaults to `func.length - 1`, grouping all arguments after the last parameter.\n * @returns {(...args: any[]) => ReturnType<F>} A new function that, when called, returns the result of calling `func` with the transformed arguments.\n *\n * The transformed arguments are:\n * - The first `start` arguments as individual elements.\n * - The remaining arguments from index `start` onward grouped into an array.\n * @example\n * function fn(a, b, c) {\n *   return [a, b, c];\n * }\n *\n * // Using default start index (func.length - 1, which is 2 in this case)\n * const transformedFn = rest(fn);\n * console.log(transformedFn(1, 2, 3, 4)); // [1, 2, [3, 4]]\n *\n * // Using start index 1\n * const transformedFnWithStart = rest(fn, 1);\n * console.log(transformedFnWithStart(1, 2, 3, 4)); // [1, [2, 3, 4]]\n *\n * // With fewer arguments than the start index\n * console.log(transformedFn(1)); // [1, undefined, []]\n */\nexport function rest<F extends (...args: any[]) => any>(\n  func: F,\n  startIndex = func.length - 1\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: any[]) {\n    const rest = args.slice(startIndex);\n    const params = args.slice(0, startIndex);\n    while (params.length < startIndex) {\n      params.push(undefined);\n    }\n    return func.apply(this, [...params, rest]);\n  };\n}\n","/**\n * Creates a new function that spreads elements of an array argument into individual arguments\n * for the original function. The array argument is positioned based on the `argsIndex` parameter.\n *\n * @template F - A function type with any number of parameters and any return type.\n * @param {F} func - The function to be transformed. It can be any function with any number of arguments.\n * @param {number} [argsIndex=0] - The index where the array argument is positioned among the other arguments.\n *   If `argsIndex` is negative or `NaN`, it defaults to `0`. If it's a fractional number, it is rounded to the nearest integer.\n * @returns {(...args: any[]) => ReturnType<F>} - A new function that takes multiple arguments, including an array of arguments at the specified `argsIndex`,\n *   and returns the result of calling the original function with those arguments.\n *\n * @example\n * function add(a, b) {\n *   return a + b;\n * }\n *\n * const spreadAdd = spread(add);\n * console.log(spreadAdd([1, 2])); // Output: 3\n *\n * @example\n * // Example function to spread arguments over\n * function add(a, b) {\n *   return a + b;\n * }\n *\n * // Create a new function that uses `spread` to combine arguments\n * const spreadAdd = spread(add, 1);\n *\n * // Calling `spreadAdd` with an array as the second argument\n * console.log(spreadAdd(1, [2])); // Output: 3\n *\n * @example\n * // Function with default arguments\n * function greet(name, greeting = 'Hello') {\n *   return `${greeting}, ${name}!`;\n * }\n *\n * // Create a new function that uses `spread` to position the argument array at index 0\n * const spreadGreet = spread(greet, 0);\n *\n * // Calling `spreadGreet` with an array of arguments\n * console.log(spreadGreet(['Alice'])); // Output: Hello, Alice!\n * console.log(spreadGreet(['Bob', 'Hi'])); // Output: Hi, Bob!\n */\nexport function spread<R>(func: (...args: any[]) => R, argsIndex = 0): (...args: any[]) => R {\n  argsIndex = Number.parseInt(argsIndex as any, 10);\n\n  if (Number.isNaN(argsIndex) || argsIndex < 0) {\n    argsIndex = 0;\n  }\n\n  return function (this: any, ...args: any[]) {\n    const array = args[argsIndex];\n    const params = args.slice(0, argsIndex);\n\n    if (array) {\n      params.push(...array);\n    }\n\n    return func.apply(this, params);\n  };\n}\n","import { debounce, DebouncedFunc, DebouncedFuncLeading } from './debounce.ts';\n\ninterface ThrottleSettings {\n  /**\n   * If `true`, the function will be invoked on the leading edge of the timeout.\n   * @default true\n   */\n  leading?: boolean | undefined;\n  /**\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\n   * @default true\n   */\n  trailing?: boolean | undefined;\n}\n\ntype ThrottleSettingsLeading = (ThrottleSettings & { leading: true }) | Omit<ThrottleSettings, 'leading'>;\n\n/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @param {ThrottleOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<T extends (...args: any) => any>(\n  func: T,\n  throttleMs?: number,\n  options?: ThrottleSettingsLeading\n): DebouncedFuncLeading<T>;\n\n/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @param {ThrottleOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<T extends (...args: any) => any>(\n  func: T,\n  throttleMs?: number,\n  options?: ThrottleSettings\n): DebouncedFunc<T>;\n\n/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @param {ThrottleOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<F extends (...args: any[]) => any>(\n  func: F,\n  throttleMs = 0,\n  options: ThrottleSettings = {}\n): DebouncedFunc<F> {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  const { leading = true, trailing = true } = options;\n\n  return debounce(func, throttleMs, {\n    leading,\n    trailing,\n    maxWait: throttleMs,\n  });\n}\n","import { ary } from './ary.ts';\n\n/**\n * Creates a function that accepts up to one argument, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a, b, c) {\n *   console.log(arguments);\n * }\n *\n * unary(fn)(1, 2, 3); // [Arguments] { '0': 1 }\n */\nexport function unary<T, U>(func: (arg1: T, ...args: any[]) => U): (arg1: T) => U {\n  return ary(func, 1);\n}\n","import { identity } from '../../function/identity.ts';\nimport { isFunction } from '../../predicate/isFunction.ts';\n\n/**\n * Creates a new function that wraps the given function `func`.\n * In this process, you can apply additional logic defined in the `wrapper` function before and after the execution of the original function.\n *\n * If a `value` is provided instead of a function, this value is passed as the first argument to the `wrapper` function.\n *\n * @example\n * // Wrap a function\n * const greet = (name: string) => `Hi, ${name}`;\n * const wrapped = wrap(greet, (value, name) => `[LOG] ${value(name)}`);\n * wrapped('Bob'); // => \"[LOG] Hi, Bob\"\n *\n * @example\n * // Wrap a primitive value\n * const wrapped = wrap('value', v => `<p>${v}</p>`);\n * wrapped(); // => \"<p>value</p>\"\n */\nexport function wrap<T, U, V>(value: T, wrapper: (value: T, ...args: U[]) => V): (...args: U[]) => V {\n  return function (this: unknown, ...args: any[]): any {\n    const wrapFn = isFunction(wrapper) ? (wrapper as (value: unknown, ...args: unknown[]) => unknown) : identity;\n\n    return wrapFn.apply(this, [value, ...args]);\n  };\n}\n","/**\n * Converts `value` to a string.\n *\n * An empty string is returned for `null` and `undefined` values.\n * The sign of `-0` is preserved.\n *\n * @param {any} value - The value to convert.\n * @returns {string} Returns the converted string.\n *\n * @example\n * toString(null) // returns ''\n * toString(undefined) // returns ''\n * toString(-0) // returns '-0'\n * toString([1, 2, -0]) // returns '1,2,-0'\n * toString([Symbol('a'), Symbol('b')]) // returns 'Symbol(a),Symbol(b)'\n */\nexport function toString(value: any): string {\n  if (value == null) {\n    return '';\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(toString).join(',');\n  }\n\n  const result = String(value);\n\n  if (result === '0' && Object.is(Number(value), -0)) {\n    return '-0';\n  }\n\n  return result;\n}\n","import { toNumber } from '../util/toNumber.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Adds two numbers while safely handling `NaN` values.\n *\n * This function takes two numbers and returns their sum. If either of the numbers is `NaN`,\n * the function returns `NaN`.\n *\n * @param {number} value - The first number to add.\n * @param {number} other - The second number to add.\n * @returns {number} The sum of the two numbers, or `NaN` if any input is `NaN`.\n *\n * @example\n * const result1 = add(2, 3);    // result1 will be 5\n * const result2 = add(5, NaN);  // result2 will be NaN\n * const result3 = add(NaN, 10); // result3 will be NaN\n */\nexport function add(value: number, other: number): number {\n  if (value === undefined && other === undefined) {\n    return 0;\n  }\n  if (value === undefined || other === undefined) {\n    return value ?? other;\n  }\n  if (typeof value === 'string' || typeof other === 'string') {\n    value = toString(value) as any;\n    other = toString(other) as any;\n  } else {\n    value = toNumber(value);\n    other = toNumber(other);\n  }\n  return value + other;\n}\n","export function decimalAdjust(\n  type: 'round' | 'floor' | 'ceil',\n  number: number | string,\n  precision: number | string = 0\n): number {\n  number = Number(number);\n  if (Object.is(number, -0)) {\n    number = '-0';\n  }\n  precision = Math.min(Number.parseInt(precision as string, 10), 292);\n  if (precision) {\n    const [magnitude, exponent = 0] = number.toString().split('e');\n    let adjustedValue: string | number = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));\n    if (Object.is(adjustedValue, -0)) {\n      adjustedValue = '-0';\n    }\n    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split('e');\n    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);\n  }\n  return Math[type](Number(number));\n}\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\n\n/**\n * Computes number rounded up to precision.\n *\n * @param {number | string} number The number to round up.\n * @param {number | string} precision The precision to round up to.\n * @returns {number} Returns the rounded up number.\n *\n * @example\n * ceil(4.006); // => 5\n * ceil(6.004, 2); // => 6.01\n * ceil(6040, -2); // => 6100\n */\nexport function ceil(number: number, precision = 0): number {\n  return decimalAdjust('ceil', number, precision);\n}\n","import { toNumber } from '../util/toNumber.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Divide two numbers.\n *\n * If either of the numbers is `NaN`, the function returns `NaN`.\n *\n * @param {number} value The first number in a division.\n * @param {number} other The second number in a division.\n * @returns {number} The quotient of value and other.\n *\n * @example\n * divide(6, 3); // => 2\n * divide(2, NaN); // => NaN\n * divide(NaN, 3); // => NaN\n * divide(NaN, NaN); // => NaN\n */\nexport function divide(value: number, other: number): number {\n  if (value === undefined && other === undefined) {\n    return 1;\n  }\n\n  if (value === undefined || other === undefined) {\n    return value ?? other;\n  }\n\n  if (typeof value === 'string' || typeof other === 'string') {\n    value = toString(value) as any;\n    other = toString(other) as any;\n  } else {\n    value = toNumber(value);\n    other = toNumber(other);\n  }\n\n  return value / other;\n}\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\n\n/**\n * Computes number rounded down to precision.\n *\n * @param {number | string} number The number to round down.\n * @param {number | string} precision The precision to round down to.\n * @returns {number} Returns the rounded down number.\n *\n * @example\n * floor(4.006); // => 4\n * floor(0.046, 2); // => 0.04\n * floor(4060, -2); // => 4000\n */\nexport function floor(number: number, precision = 0): number {\n  return decimalAdjust('floor', number, precision);\n}\n","import { inRange as inRangeToolkit } from '../../math/inRange.ts';\n\n/**\n * Checks if the value is within a specified range.\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\n *\n * @example\n * const result1 = inRange(3, 5); // result1 will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\n */\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\n  if (!minimum) {\n    minimum = 0;\n  }\n\n  if (maximum != null && !maximum) {\n    maximum = 0;\n  }\n\n  if (minimum != null && typeof minimum !== 'number') {\n    minimum = Number(minimum);\n  }\n\n  if (maximum == null && minimum === 0) {\n    return false;\n  }\n\n  if (maximum != null && typeof maximum !== 'number') {\n    maximum = Number(maximum);\n  }\n\n  if (maximum != null && minimum > maximum) {\n    [minimum, maximum] = [maximum, minimum];\n  }\n\n  if (minimum === maximum) {\n    return false;\n  }\n\n  return inRangeToolkit(value, minimum, maximum!);\n}\n","/**\n * Checks if the value is less than the maximum.\n *\n * @param {number} value The value to check.\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is less than the maximum, otherwise `false`.\n *\n * @example\n * const result = inRange(3, 5); // result will be true.\n * const result2 = inRange(5, 5); // result2 will be false.\n */\nexport function inRange(value: number, maximum: number): boolean;\n\n/**\n * Checks if the value is within the range defined by minimum (inclusive) and maximum (exclusive).\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n *\n * @example\n * const result = inRange(3, 2, 5); // result will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n */\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\n\n/**\n * Checks if the value is within a specified range.\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\n *\n * @example\n * const result1 = inRange(3, 5); // result1 will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\n */\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('The maximum value must be greater than the minimum value.');\n  }\n\n  return minimum <= value && value < maximum;\n}\n","/**\n * Finds the element in an array that has the maximum value.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} [items] - The array of elements to search. Defaults to an empty array.\n * @returns {T | undefined} - The element with the maximum value, or undefined if the array is empty.\n */\nexport function max<T>(items: ArrayLike<T> | null | undefined): T | undefined {\n  if (!items || items.length === 0) {\n    return undefined;\n  }\n\n  let maxResult: T | undefined = undefined;\n\n  for (let i = 0; i < items.length; i++) {\n    const current = items[i];\n\n    if (current == null || Number.isNaN(current) || typeof current === 'symbol') {\n      continue;\n    }\n\n    if (maxResult === undefined || current > (maxResult as T)) {\n      maxResult = current;\n    }\n  }\n\n  return maxResult;\n}\n","import { maxBy as maxByToolkit } from '../../array/maxBy.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Finds the element in an array that has the maximum value when applying\n * the `iteratee` to each element.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} items The array of elements to search.\n * @param {ValueIteratee<T>} iteratee\n * The criteria used to determine the maximum value.\n *  - If a **function** is provided, it extracts a numeric value from each element.\n *  - If a **string** is provided, it is treated as a key to extract values from the objects.\n *  - If a **[key, value]** pair is provided, it matches elements with the specified key-value pair.\n *  - If an **object** is provided, it matches elements that contain the specified properties.\n * @returns {T | undefined} The element with the maximum value as determined by the `iteratee`.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n * maxBy([{ a: 1 }, { a: 2 }], 'a'); // Returns: { a: 2 }\n * maxBy([{ a: 1 }, { a: 2 }], ['a', 1]); // Returns: { a: 1 }\n * maxBy([{ a: 1 }, { a: 2 }], { a: 1 }); // Returns: { a: 1 }\n */\nexport function maxBy<T>(items: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): T | undefined {\n  if (items == null) {\n    return undefined;\n  }\n\n  return maxByToolkit(Array.from(items), iterateeToolkit(iteratee ?? identity));\n}\n","/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the maximum value as determined by the `getValue` function.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n */\nexport function maxBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\n/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function,\n * or `undefined` if the array is empty.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n */\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\n/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the maximum value as determined by the `getValue` function,\n * or `undefined` if the array is empty.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n * maxBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'john', age: 30 }\n */\nexport function maxBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined {\n  if (items.length === 0) {\n    return undefined;\n  }\n\n  let maxElement = items[0];\n  let max = getValue(maxElement);\n\n  for (let i = 1; i < items.length; i++) {\n    const element = items[i];\n    const value = getValue(element);\n    if (value > max) {\n      max = value;\n      maxElement = element;\n    }\n  }\n\n  return maxElement;\n}\n","import { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Computes the sum of the values that are returned by the `iteratee` function.\n *\n * It does not coerce values to `number`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T> | null | undefined} array - The array to iterate over.\n * @param {((value: T) => number) | string} iteratee - The function invoked per iteration.\n * @returns {number} Returns the sum.\n *\n * @example\n * sumBy([1, undefined, 2], value => value); // => 3\n * sumBy(null); // => 0\n * sumBy(undefined); // => 0\n * sumBy([1, 2, 3]); // => 6\n * sumBy([1n, 2n, 3n]); // => 6n\n * sumBy([{ a: \"1\" }, { a: \"2\" }], object => object.a); // => \"12\"\n */\nexport function sumBy<T>(array: ArrayLike<T> | null | undefined, iteratee?: ((value: T) => number) | string): number {\n  if (!array || !array.length) {\n    return 0;\n  }\n\n  if (iteratee != null) {\n    iteratee = iterateeToolkit(iteratee);\n  }\n\n  let result: any = undefined;\n\n  for (let i = 0; i < array.length; i++) {\n    const current = iteratee ? iteratee(array[i]) : array[i];\n\n    if (current !== undefined) {\n      if (result === undefined) {\n        result = current;\n      } else {\n        result += current;\n      }\n    }\n  }\n\n  return result;\n}\n","import { sumBy } from './sumBy.ts';\n\n/**\n * Computes the sum of the values that are returned by the `iteratee` function.\n *\n * It does not coerce values to `number`.\n *\n * @param {ArrayLike<any> | null | undefined} array - The array to iterate over.\n * @returns {number} Returns the sum.\n *\n * @example\n * sum([1, 2, 3]); // => 6\n * sum([1n, 2n, 3n]); // => 6n\n * sum([\"1\", \"2\"]); // => \"12\"\n * sum([1, undefined, 2]); // => 3\n * sum(null); // => 0\n * sum(undefined); // => 0\n */\nexport function sum(array: ArrayLike<any> | null | undefined): number {\n  return sumBy(array);\n}\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the average of an array of numbers.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {ArrayLike<any> | null | undefined} nums - An array of numbers to calculate the average.\n * @returns {number} The average of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = mean(numbers);\n * // result will be 3\n */\nexport function mean(nums: ArrayLike<any> | null | undefined): number {\n  const length = nums ? nums.length : 0;\n  return length === 0 ? NaN : sum(nums) / length;\n}\n","import { identity } from '../../function/identity.ts';\nimport { meanBy as meanByToolkit } from '../../math/meanBy.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Calculates the average of an array of numbers when applying\n * the `iteratee` function to each element.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the average.\n * @param {((element: T) => unknown) | PropertyKey | [PropertyKey, any] | PartialShallow<T>} iteratee\n * The criteria used to determine the maximum value.\n *  - If a **function** is provided, it extracts a numeric value from each element.\n *  - If a **string** is provided, it is treated as a key to extract values from the objects.\n *  - If a **[key, value]** pair is provided, it matches elements with the specified key-value pair.\n *  - If an **object** is provided, it matches elements that contain the specified properties.\n * @returns {number} The average of all the numbers as determined by the `iteratee` function.\n *\n * @example\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\n * meanBy([], x => x.a); // Returns: NaN\n * meanBy([[2], [3], [1]], 0); // Returns: 2\n * meanBy([{ a: 2 }, { a: 3 }, { a: 1 }], 'a'); // Returns: 2\n */\nexport function meanBy<T>(items: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): number {\n  if (items == null) {\n    return NaN;\n  }\n\n  return meanByToolkit(Array.from(items), iterateeToolkit(iteratee ?? identity));\n}\n","import { mean } from './mean.ts';\n\n/**\n * Calculates the average of an array of numbers when applying\n * the `getValue` function to each element.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the average.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\n *\n * @example\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\n * meanBy([], x => x.a); // Returns: NaN\n */\nexport function meanBy<T>(items: readonly T[], getValue: (element: T) => number): number {\n  const nums = items.map(x => getValue(x));\n\n  return mean(nums);\n}\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the average of an array of numbers.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the average.\n * @returns {number} The average of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = mean(numbers);\n * // result will be 3\n */\nexport function mean(nums: readonly number[]): number {\n  return sum(nums) / nums.length;\n}\n","/**\n * Calculates the sum of an array of numbers.\n *\n * This function takes an array of numbers and returns the sum of all the elements in the array.\n *\n * @param {number[]} nums - An array of numbers to be summed.\n * @returns {number} The sum of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = sum(numbers);\n * // result will be 15\n */\nexport function sum(nums: readonly number[]): number {\n  let result = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    result += nums[i];\n  }\n\n  return result;\n}\n","/**\n * Finds the element in an array that has the minimum value.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} [items] - The array of elements to search. Defaults to an empty array.\n * @returns {T | undefined} - The element with the minimum value, or undefined if the array is empty.\n */\nexport function min<T>(items: ArrayLike<T> | null | undefined): T | undefined {\n  if (!items || items.length === 0) {\n    return undefined;\n  }\n\n  let minResult: T | undefined = undefined;\n\n  for (let i = 0; i < items.length; i++) {\n    const current = items[i];\n\n    if (current == null || Number.isNaN(current) || typeof current === 'symbol') {\n      continue;\n    }\n\n    if (minResult === undefined || current < (minResult as T)) {\n      minResult = current;\n    }\n  }\n\n  return minResult;\n}\n","import { minBy as minByToolkit } from '../../array/minBy.ts';\nimport { identity } from '../../function/identity.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Finds the element in an array that has the minium value when applying\n * the `iteratee` to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {((element: T) => number) | keyof T | [keyof T, unknown] | Partial<T>} iteratee\n * The criteria used to determine the minium value.\n *  - If a **function** is provided, it extracts a numeric value from each element.\n *  - If a **string** is provided, it is treated as a key to extract values from the objects.\n *  - If a **[key, value]** pair is provided, it matches elements with the specified key-value pair.\n *  - If an **object** is provided, it matches elements that contain the specified properties.\n * @returns {T | undefined} The element with the minium value as determined by the `iteratee`.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n * minBy([{ a: 1 }, { a: 2 }], 'a'); // Returns: { a: 1 }\n * minBy([{ a: 1 }, { a: 2 }], ['a', 1]); // Returns: { a: 2 }\n * minBy([{ a: 1 }, { a: 2 }], { a: 1 }); // Returns: { a: 2 }\n */\nexport function minBy<T>(items: ArrayLike<T> | null | undefined, iteratee?: ValueIteratee<T>): T | undefined {\n  if (items == null) {\n    return undefined;\n  }\n\n  return minByToolkit(Array.from(items), iterateeToolkit(iteratee ?? identity));\n}\n","/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} items The nonempty array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the minimum value as determined by the `getValue` function.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n */\nexport function minBy<T>(items: readonly [T, ...T[]], getValue: (element: T) => number): T;\n/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function,\n * or `undefined` if the array is empty.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n */\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined;\n/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T | undefined} The element with the minimum value as determined by the `getValue` function,\n * or `undefined` if the array is empty.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n * minBy(\n *   [\n *     { name: 'john', age: 30 },\n *     { name: 'jane', age: 28 },\n *     { name: 'joe', age: 26 },\n *   ],\n *   x => x.age\n * ); // Returns: { name: 'joe', age: 26 }\n */\nexport function minBy<T>(items: readonly T[], getValue: (element: T) => number): T | undefined {\n  if (items.length === 0) {\n    return undefined;\n  }\n\n  let minElement = items[0];\n  let min = getValue(minElement);\n\n  for (let i = 1; i < items.length; i++) {\n    const element = items[i];\n    const value = getValue(element);\n    if (value < min) {\n      min = value;\n      minElement = element;\n    }\n  }\n\n  return minElement;\n}\n","import { toNumber } from '../util/toNumber.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Multiply two numbers.\n *\n * If either of the numbers is `NaN`, the function returns `NaN`.\n *\n * @param {number} value The first number in a multiplication\n * @param {number} other The second number in a multiplication\n * @returns {number} The product of value and other\n *\n * @example\n * multiply(2, 3); // => 6\n * multiply(2, NaN); // => NaN\n * multiply(NaN, 3); // => NaN\n * multiply(NaN, NaN); // => NaN\n */\n\nexport function multiply(value: number, other: number): number {\n  if (value === undefined && other === undefined) {\n    return 1;\n  }\n\n  if (value === undefined || other === undefined) {\n    return value ?? other;\n  }\n\n  if (typeof value === 'string' || typeof other === 'string') {\n    value = toString(value) as any;\n    other = toString(other) as any;\n  } else {\n    value = toNumber(value);\n    other = toNumber(other);\n  }\n\n  return value * other;\n}\n","/**\n * Converts `string` to an integer of the specified radix. If `radix` is undefined or 0, a `radix` of 10 is used unless `string` is a hexadecimal, in which case a `radix` of 16 is used.\n *\n * @param {string} string The string to convert to an integer.\n * @param {number} radix The radix to use when converting the string to an integer. Defaults to `0`.\n * @param {unknown} guard Enables use as an iteratee for methods like `Array#map`.\n * @returns {number} Returns the converted integer.\n *\n * @example\n * parseInt('08'); // => 8\n * parseInt('0x20'); // => 32\n *\n * parseInt('08', 10); // => 8\n * parseInt('0x20', 16); // => 32\n *\n * ['6', '08', '10'].map(parseInt); // => [6, 8, 10]\n */\nexport function parseInt(string: string, radix?: number): number;\n\n/**\n * Converts `string` to an integer of the specified radix. If `radix` is undefined or 0, a `radix` of 10 is used unless `string` is a hexadecimal, in which case a `radix` of 16 is used.\n *\n * @param {string} string The string to convert to an integer.\n * @param {number} radix The radix to use when converting the string to an integer. Defaults to `0`.\n * @param {unknown} guard Enables use as an iteratee for methods like `Array#map`.\n * @returns {number} Returns the converted integer.\n *\n * @example\n * parseInt('08'); // => 8\n * parseInt('0x20'); // => 32\n *\n * parseInt('08', 10); // => 8\n * parseInt('0x20', 16); // => 32\n *\n * ['6', '08', '10'].map(parseInt); // => [6, 8, 10]\n */\nexport function parseInt(string: string, radix = 0, guard?: unknown): number {\n  if (guard) {\n    radix = 0;\n  }\n\n  return Number.parseInt(string, radix);\n}\n","import { clamp } from './clamp.ts';\nimport { random as randomToolkit } from '../../math/random.ts';\nimport { randomInt as randomIntToolkit } from '../../math/randomInt.ts';\n\n/**\n * Generate a random number between 0 and 1.\n * @param {boolean} [floating] - Whether to return a floating point number. Defaults to true.\n * @returns {number} A random number between 0 and 1.\n * @example\n * random(); // Returns a random number between 0 and 1\n * random(true); // Returns a random floating point number between 0 and 1\n * random(false); // Returns a random integer between 0 and 1\n */\nexport function random(floating?: boolean): number;\n\n/**\n * Generate a random number between 0 and max.\n * @param {number} max - The upper bound (exclusive).\n * @param {boolean} [floating] - Whether to return a floating point number. Defaults to true.\n * @returns {number} A random number between 0 and max.\n * @example\n * random(5); // Returns a random number between 0 and 5\n * random(10, true); // Returns a random floating point number between 0 and 10\n * random(3, false); // Returns a random integer between 0 and 3\n */\nexport function random(max: number, floating?: boolean): number;\n\n/**\n * Generate a random number between min and max.\n * @param {number} min - The lower bound (inclusive).\n * @param {number} max - The upper bound (exclusive).\n * @param {boolean} [floating] - Whether to return a floating point number. Defaults to true.\n * @returns {number} A random number between min and max.\n * @example\n * random(1, 5); // Returns a random number between 1 and 5\n * random(0, 10, true); // Returns a random floating point number between 0 and 10\n * random(1, 6, false); // Returns a random integer between 1 and 6\n */\nexport function random(min: number, max: number, floating?: boolean): number;\n\n/**\n * Generate a random number between 0 and min, using guard object for special cases.\n * @param {number} min - The upper bound (exclusive).\n * @param {string | number} index - The index or key to check in the guard object.\n * @param {object} guard - The guard object to validate the parameters.\n * @returns {number} A random number between 0 and min.\n * @example\n * const guard = { 5: 5 };\n * random(5, 5, guard); // Returns a random number between 0 and 5\n */\nexport function random(min: number, index: string | number, guard: object): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(...args: any[]): number {\n  let minimum = 0;\n  let maximum = 1;\n  let floating = false;\n\n  switch (args.length) {\n    case 1: {\n      if (typeof args[0] === 'boolean') {\n        floating = args[0];\n      } else {\n        maximum = args[0];\n      }\n\n      break;\n    }\n    case 2: {\n      if (typeof args[1] === 'boolean') {\n        maximum = args[0];\n        floating = args[1];\n      } else {\n        minimum = args[0];\n        maximum = args[1];\n      }\n    }\n    // eslint-disable-next-line no-fallthrough\n    case 3: {\n      if (typeof args[2] === 'object' && args[2] != null && args[2][args[1]] === args[0]) {\n        minimum = 0;\n        maximum = args[0];\n        floating = false;\n      } else {\n        minimum = args[0];\n        maximum = args[1];\n        floating = args[2];\n      }\n    }\n  }\n\n  if (typeof minimum !== 'number') {\n    minimum = Number(minimum);\n  }\n\n  if (typeof maximum !== 'number') {\n    minimum = Number(maximum);\n  }\n\n  if (!minimum) {\n    minimum = 0;\n  }\n\n  if (!maximum) {\n    maximum = 0;\n  }\n\n  if (minimum > maximum) {\n    [minimum, maximum] = [maximum, minimum];\n  }\n\n  minimum = clamp(minimum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n  maximum = clamp(maximum, -Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n  if (minimum === maximum) {\n    return minimum;\n  }\n\n  if (floating) {\n    return randomToolkit(minimum, maximum + 1);\n  } else {\n    return randomIntToolkit(minimum, maximum + 1);\n  }\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { toFinite } from '../util/toFinite.ts';\n\n/**\n * Creates an array of numbers progressing from `start` up to, but not including, `end`.\n *\n * @param {number} start - The starting number of the range (inclusive)\n * @param {number} end - The end number of the range (exclusive)\n * @param {number} step - The value to increment or decrement by\n * @returns {number[]} An array of numbers from start to end\n * @example\n * range(4)\n * // => [0, 1, 2, 3]\n *\n * range(1, 5)\n * // => [1, 2, 3, 4]\n *\n * range(0, 20, 5)\n * // => [0, 5, 10, 15]\n */\nexport function range(start: number, end?: number, step?: number): number[];\n\n/**\n * Creates an array of numbers progressing from 0 up to, but not including, `end`.\n * Used internally when range is called as an iteratee.\n *\n * @param {number} end - The end of the range (exclusive)\n * @param {string|number} index - The index argument passed to the iteratee\n * @param {object} guard - The guard object passed to the iteratee\n * @returns {number[]} An array of numbers from 0 to end\n * @example\n * [1, 2, 3].map(range)\n * // => [[0], [0, 1], [0, 1, 2]]\n */\nexport function range(end: number, index: string | number, guard: object): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n */\nexport function range(start: number, end?: PropertyKey, step?: any): number[] {\n  // Enables use as an iteratee for methods like `_.map`.\n  if (step && typeof step !== 'number' && isIterateeCall(start, end, step)) {\n    end = step = undefined;\n  }\n  start = toFinite(start);\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    end = toFinite(end);\n  }\n  step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n\n  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);\n  const result = new Array(length);\n  for (let index = 0; index < length; index++) {\n    result[index] = start;\n    start += step;\n  }\n  return result;\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { toFinite } from '../util/toFinite.ts';\n\n/**\n * Creates an array of numbers from `start` to `end` with optional `step`.\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} [end] - The end number of the range (exclusive).\n * @param {number} [step] - The step value for the range.\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\n * @example\n * // Returns [0, 1, 2, 3]\n * rangeRight(4);\n * @example\n * // Returns [0, 2, 4, 6]\n * rangeRight(0, 8, 2);\n * @example\n * // Returns [5, 4, 3, 2, 1]\n * rangeRight(1, 6);\n */\nexport function rangeRight(start: number, end?: number, step?: number): number[];\n\n/**\n * Creates an array of numbers from 0 to `end` with step 1.\n * Used when called as an iteratee for methods like `_.map`.\n * @param {number} end - The end number of the range (exclusive).\n * @param {string | number} index - The index parameter (used for iteratee calls).\n * @param {object} guard - The guard parameter (used for iteratee calls).\n * @returns {number[]} An array of numbers from 0 to `end` with step 1.\n * @example\n * // Returns [0, 1, 2, 3]\n * rangeRight(4, 'index', {});\n */\nexport function rangeRight(end: number, index: string | number, guard: object): number[];\n\n/**\n * Returns an array of numbers from `end` (exclusive) to `start` (inclusive), decrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {string | number} end - The end number of the range (exclusive).\n * @param {number | object} step - The step value for the range.\n * @returns {number[]} An array of numbers from `end` (exclusive) to `start` (inclusive) with the specified `step`.\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\n *\n * @example\n * // Returns [3, 2, 1, 0]\n * rangeRight(4);\n *\n * @example\n * // Returns [-3, -2, -1, 0]\n * rangeRight(0, -4, -1);\n */\nexport function rangeRight(start: number, end?: string | number, step?: number | object): number[] {\n  // Enables use as an iteratee for methods like `_.map`.\n  if (step && typeof step !== 'number' && isIterateeCall(start, end, step)) {\n    end = step = undefined;\n  }\n  start = toFinite(start);\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    end = toFinite(end);\n  }\n  step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n\n  const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);\n  const result = new Array(length);\n  for (let index = length - 1; index >= 0; index--) {\n    result[index] = start;\n    start += step;\n  }\n  return result;\n}\n","import { decimalAdjust } from '../_internal/decimalAdjust.ts';\n\n/**\n * Computes number rounded to precision.\n *\n * @param {number} number  The number to round.\n * @param {number} precision The precision to round to.\n * @returns {number} Returns the rounded number.\n *\n * @example\n * round(4.006); // => 4\n * round(4.006, 2); // => 4.01\n * round(4060, -2); // => 4100\n */\nexport function round(number: number, precision = 0): number {\n  return decimalAdjust('round', number, precision);\n}\n","import { toNumber } from '../util/toNumber.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Subtracts one number from another.\n *\n * If either of the numbers is `NaN`, the function returns `NaN`.\n *\n * @param {number} value The first number. (minuend)\n * @param {number} other The second number.(subtrahend)\n * @returns {number} The difference of the two numbers, or `NaN` if any input is `NaN`.\n *\n * @example\n * subtract(6, 3); // => 3\n * subtract(6, NaN); // => NaN\n * subtract(NaN, 3); // => NaN\n */\nexport function subtract(value: number, other: number): number {\n  if (value === undefined && other === undefined) {\n    return 0;\n  }\n  if (value === undefined || other === undefined) {\n    return value ?? other;\n  }\n  if (typeof value === 'string' || typeof other === 'string') {\n    value = toString(value) as any;\n    other = toString(other) as any;\n  } else {\n    value = toNumber(value);\n    other = toNumber(other);\n  }\n  return value - other;\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function noop(..._: any[]): void {}\n","export function isPrototype(value: object) {\n  const constructor = value?.constructor;\n  const prototype = typeof constructor === 'function' ? constructor.prototype : Object.prototype;\n\n  return value === prototype;\n}\n","import { isTypedArray as isTypedArrayToolkit } from '../../predicate/isTypedArray.ts';\n\n/**\n * Checks if a value is a TypedArray.\n * @param {any} x The value to check.\n * @returns {boolean} Returns true if `x` is a TypedArray, false otherwise.\n *\n * @example\n * const arr = new Uint8Array([1, 2, 3]);\n * isTypedArray(arr); // true\n *\n * const regularArray = [1, 2, 3];\n * isTypedArray(regularArray); // false\n *\n * const buffer = new ArrayBuffer(16);\n * isTypedArray(buffer); // false\n */\nexport function isTypedArray(x: any): boolean {\n  return isTypedArrayToolkit(x);\n}\n","import { toInteger } from './toInteger.ts';\n\n/**\n * Invokes the iteratee function n times, returning an array of the results.\n *\n * @template T The return type of the iteratee function.\n * @param {number} n - The number of times to invoke iteratee.\n * @param {(num: number) => T} iteratee - The function to invoke for each index.\n * @returns {T[]} An array containing the results of invoking iteratee n times.\n * @example\n * times(3, (i) => i * 2); // => [0, 2, 4]\n * times(2, () => 'es-toolkit'); // => ['es-toolkit', 'es-toolkit']\n */\nexport function times<T>(n: number, iteratee: (num: number) => T): T[];\n\n/**\n * Invokes the default iteratee function n times, returning an array of indices.\n *\n * @param {number} n - The number of times to invoke the default iteratee.\n * @returns {number[]} An array containing indices from 0 to n-1.\n * @example\n * times(3); // => [0, 1, 2]\n */\nexport function times(n: number): number[];\n\n/**\n * Invokes the getValue function n times, returning an array of the results.\n *\n * @template R The return type of the getValue function.\n * @param {number} n - The number of times to invoke getValue.\n * @param {(index: number) => R} getValue - The function to invoke for each index.\n * @returns {R[]} An array containing the results of invoking getValue n times.\n * @example\n * times(3, (i) => i * 2); // => [0, 2, 4]\n * times(2, () => 'es-toolkit'); // => ['es-toolkit', 'es-toolkit']\n */\nexport function times<R = number>(n?: number, getValue?: (index: number) => R): R[] {\n  n = toInteger(n);\n\n  if (n < 1 || !Number.isSafeInteger(n)) {\n    return [];\n  }\n\n  const result = new Array(n);\n\n  for (let i = 0; i < n; i++) {\n    result[i] = typeof getValue === 'function' ? getValue(i) : i;\n  }\n\n  return result;\n}\n","import { isBuffer } from '../../predicate/isBuffer.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { times } from '../util/times.ts';\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * Non-object values are coerced to objects.\n *\n * @param {object} object The object to query.\n * @returns {string[]} Returns the array of property names.\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n * Foo.prototype.c = 3;\n * keys(new Foo); // ['a', 'b'] (iteration order is not guaranteed)\n *\n * keys('hi'); // ['0', '1']\n * keys([1, 2, 3]); // ['0', '1', '2']\n * keys({ a: 1, b: 2 }); // ['a', 'b']\n */\nexport function keys(object?: any): string[] {\n  if (isArrayLike(object)) {\n    return arrayLikeKeys(object);\n  }\n\n  const result = Object.keys(Object(object));\n\n  if (!isPrototype(object)) {\n    return result;\n  }\n\n  return result.filter(key => key !== 'constructor');\n}\n\nfunction arrayLikeKeys(object: ArrayLike<any>): string[] {\n  const indices = times(object.length, index => `${index}`);\n\n  const filteredKeys = new Set(indices);\n\n  if (isBuffer(object)) {\n    // Node.js 0.10 has enumerable non-index properties on buffers.\n    filteredKeys.add('offset');\n    filteredKeys.add('parent');\n  }\n\n  if (isTypedArray(object)) {\n    // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    filteredKeys.add('buffer');\n    filteredKeys.add('byteLength');\n    filteredKeys.add('byteOffset');\n  }\n\n  return [...indices, ...Object.keys(object).filter(key => !filteredKeys.has(key))];\n}\n","import { keys as keysToolkit } from './keys.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Assigns properties from one source object to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source - The source object whose properties will be assigned to the target object.\n * @returns {T & U} The updated target object with properties from the source object assigned.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n * const result = assign(target, source);\n * // => { a: 1, b: 3, c: 4 }\n */\nexport function assign<T, U>(object: T, source: U): T & U;\n\n/**\n * Assigns properties from two source objects to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @returns {T & U & V} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const result = assign(target, source1, source2);\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function assign<T, U, V>(object: T, source1: U, source2: V): T & U & V;\n\n/**\n * Assigns properties from three source objects to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @returns {T & U & V & W} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const result = assign(target, source1, source2, source3);\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assign<T, U, V, W>(object: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n/**\n * Assigns properties from four source objects to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @template X - The type of the fourth source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @param {X} source4 - The fourth source object whose properties will be assigned to the target object.\n * @returns {T & U & V & W & X} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n * const result = assign(target, source1, source2, source3, source4);\n * // => { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function assign<T, U, V, W, X>(object: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\n\n/**\n * Assigns properties from a target object to itself.\n *\n * @template T - The type of the target object.\n * @param {T} object - The target object.\n * @returns {T} The target object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const result = assign(target);\n * // => { a: 1, b: 2 }\n */\nexport function assign<T>(object: T): T;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} otherArgs - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assign(target, { b: 2 }, { c: 3 }, { d: 4 });\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assign(object: any, ...otherArgs: any[]): any;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object.\n * If a property in the source objects is equal to the corresponding property in the target object,\n * it will not be overwritten.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assign(target, { b: 2 }, { c: 3 });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assign(object: any, ...sources: any[]): any {\n  for (let i = 0; i < sources.length; i++) {\n    assignImpl(object, sources[i]);\n  }\n\n  return object;\n}\n\nfunction assignImpl(object: any, source: any): any {\n  const keys = keysToolkit(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!(key in object) || !eq(object[key], source[key])) {\n      object[key] = source[key];\n    }\n  }\n}\n","import { isBuffer } from '../../predicate/isBuffer.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { times } from '../util/times.ts';\n\n/**\n * This function retrieves the names of string-keyed properties from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {any} [object] - The object to inspect for keys.\n * @returns {string[]} An array of string keys from the object.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * console.log(keysIn(obj)); // ['a', 'b']\n *\n * const arr = [1, 2, 3];\n * console.log(keysIn(arr)); // ['0', '1', '2']\n *\n * function Foo() {}\n * Foo.prototype.a = 1;\n * console.log(keysIn(new Foo())); // ['a']\n */\nexport function keysIn(object?: any): string[] {\n  if (object == null) {\n    return [];\n  }\n\n  switch (typeof object) {\n    case 'object':\n    case 'function': {\n      if (isArrayLike(object)) {\n        return arrayLikeKeysIn(object);\n      }\n\n      if (isPrototype(object)) {\n        return prototypeKeysIn(object);\n      }\n\n      return keysInImpl(object);\n    }\n\n    default: {\n      return keysInImpl(Object(object));\n    }\n  }\n}\n\nfunction keysInImpl(object: object): string[] {\n  const result: string[] = [];\n\n  for (const key in object) {\n    result.push(key);\n  }\n\n  return result;\n}\n\nfunction prototypeKeysIn(object: object): string[] {\n  const keys = keysInImpl(object);\n\n  return keys.filter(key => key !== 'constructor');\n}\n\nfunction arrayLikeKeysIn(object: ArrayLike<any>): string[] {\n  const indices = times(object.length, index => `${index}`);\n\n  const filteredKeys = new Set(indices);\n\n  if (isBuffer(object)) {\n    // Node.js 0.10 has enumerable non-index properties on buffers.\n    filteredKeys.add('offset');\n    filteredKeys.add('parent');\n  }\n\n  if (isTypedArray(object)) {\n    // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    filteredKeys.add('buffer');\n    filteredKeys.add('byteLength');\n    filteredKeys.add('byteOffset');\n  }\n\n  return [...indices, ...keysInImpl(object).filter(key => !filteredKeys.has(key))];\n}\n","import { keysIn } from './keysIn.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Assigns own and inherited properties from one source object to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source - The source object whose properties will be assigned to the target object.\n * @returns {T & U} The updated target object with properties from the source object assigned.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n * const result = assignIn(target, source);\n * // => { a: 1, b: 3, c: 4 }\n */\nexport function assignIn<T, U>(object: T, source: U): T & U;\n\n/**\n * Assigns own and inherited properties from two source objects to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @returns {T & U & V} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const result = assignIn(target, source1, source2);\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function assignIn<T, U, V>(object: T, source1: U, source2: V): T & U & V;\n\n/**\n * Assigns own and inherited properties from three source objects to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @returns {T & U & V & W} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const result = assignIn(target, source1, source2, source3);\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assignIn<T, U, V, W>(object: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n/**\n * Assigns own and inherited properties from four source objects to a target object.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @template X - The type of the fourth source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @param {X} source4 - The fourth source object whose properties will be assigned to the target object.\n * @returns {T & U & V & W & X} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n * const result = assignIn(target, source1, source2, source3, source4);\n * // => { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function assignIn<T, U, V, W, X>(object: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\n\n/**\n * Returns the target object as-is.\n *\n * @template T - The type of the target object.\n * @param {T} object - The target object.\n * @returns {T} The target object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const result = assignIn(target);\n * // => { a: 1, b: 2 }\n */\nexport function assignIn<T>(object: T): T;\n\n/**\n * Assigns own and inherited properties from multiple source objects to a target object.\n *\n * @template R - The type of the result.\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} otherArgs - The source objects whose properties will be assigned to the target object.\n * @returns {R} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignIn(target, { b: 2 }, { c: 3 }, { d: 4 });\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assignIn<R>(object: any, ...otherArgs: any[]): R;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignIn(target, { b: 2 }, { c: 3 });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn(object: any, ...sources: any[]): any {\n  for (let i = 0; i < sources.length; i++) {\n    assignInImpl(object, sources[i]);\n  }\n\n  return object;\n}\n\nfunction assignInImpl(object: any, source: any): any {\n  const keys = keysIn(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!(key in object) || !eq(object[key], source[key])) {\n      object[key] = source[key];\n    }\n  }\n}\n","import { keysIn } from './keysIn.ts';\nimport { eq } from '../util/eq.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ntype AssignCustomizer = (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}) => any;\n\n/**\n * Assigns own and inherited properties from one source object to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source - The source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U} The updated target object with properties from the source object assigned.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n * const result = assignInWith(target, source, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 4 }\n */\nexport function assignInWith<T, U>(object: T, source: U, customizer: AssignCustomizer): T & U;\n\n/**\n * Assigns own and inherited properties from two source objects to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U & V} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const result = assignInWith(target, source1, source2, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function assignInWith<T, U, V>(object: T, source1: U, source2: V, customizer: AssignCustomizer): T & U & V;\n\n/**\n * Assigns own and inherited properties from three source objects to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U & V & W} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const result = assignInWith(target, source1, source2, source3, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assignInWith<T, U, V, W>(\n  object: T,\n  source1: U,\n  source2: V,\n  source3: W,\n  customizer: AssignCustomizer\n): T & U & V & W;\n\n/**\n * Assigns own and inherited properties from four source objects to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @template X - The type of the fourth source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @param {X} source4 - The fourth source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U & V & W & X} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n * const result = assignInWith(target, source1, source2, source3, source4, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function assignInWith<T, U, V, W, X>(\n  object: T,\n  source1: U,\n  source2: V,\n  source3: W,\n  source4: X,\n  customizer: AssignCustomizer\n): T & U & V & W & X;\n\n/**\n * Returns the target object as-is.\n *\n * @template T - The type of the target object.\n * @param {T} object - The target object.\n * @returns {T} The target object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const result = assignInWith(target);\n * // => { a: 1, b: 2 }\n */\nexport function assignInWith<T>(object: T): T;\n\n/**\n * Assigns own and inherited properties from multiple source objects to a target object using a customizer function.\n *\n * @template R - The type of the result.\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} otherArgs - The source objects and customizer function.\n * @returns {R} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignInWith(target, { b: 2 }, { c: 3 }, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function assignInWith<R>(object: any, ...otherArgs: any[]): R;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n * You can provide a `getValueToAssign` function to determine what value will be assigned for each property.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * Unlike `assignIn`, this method accepts a `getValueToAssign` function that determines\n * the final value to be assigned to each property in the target object. The return value\n * of this function will be directly assigned to the corresponding property. This allows for\n * more precise control over how properties are merged between objects. If not provided,\n * the default behavior is equivalent to using the identity function (returning the source value).\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignInWith(target, { b: 2 }, { c: 3 }, function(objValue, srcValue) {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignInWith(object: any, ...sources: any[]): any {\n  let getValueToAssign = sources[sources.length - 1];\n\n  if (typeof getValueToAssign === 'function') {\n    sources.pop();\n  } else {\n    getValueToAssign = undefined;\n  }\n\n  for (let i = 0; i < sources.length; i++) {\n    assignInWithImpl(object, sources[i], getValueToAssign);\n  }\n\n  return object;\n}\n\nfunction assignInWithImpl(\n  object: any,\n  source: any,\n  getValueToAssign?: (objValue: any, srcValue: any, key: string, object: any, source: any) => any\n): any {\n  const keys = keysIn(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const objValue = object[key];\n    const srcValue = source[key];\n\n    const newValue = getValueToAssign?.(objValue, srcValue, key, object, source) ?? srcValue;\n\n    if (!(key in object) || !eq(objValue, newValue)) {\n      object[key] = newValue;\n    }\n  }\n}\n","import { keys as keysToolkit } from './keys.ts';\nimport { eq } from '../util/eq.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ntype AssignCustomizer = (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}) => any;\n\n/**\n * Assigns own properties from one source object to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source - The source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U} The updated target object with properties from the source object assigned.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n * const result = assignWith(target, source, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 4 }\n */\nexport function assignWith<T, U>(object: T, source: U, customizer: AssignCustomizer): T & U;\n\n/**\n * Assigns own properties from two source objects to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U & V} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const result = assignWith(target, source1, source2, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function assignWith<T, U, V>(object: T, source1: U, source2: V, customizer: AssignCustomizer): T & U & V;\n\n/**\n * Assigns own properties from three source objects to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U & V & W} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const result = assignWith(target, source1, source2, source3, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assignWith<T, U, V, W>(\n  object: T,\n  source1: U,\n  source2: V,\n  source3: W,\n  customizer: AssignCustomizer\n): T & U & V & W;\n\n/**\n * Assigns own properties from four source objects to a target object using a customizer function.\n *\n * @template T - The type of the target object.\n * @template U - The type of the first source object.\n * @template V - The type of the second source object.\n * @template W - The type of the third source object.\n * @template X - The type of the fourth source object.\n * @param {T} object - The target object to which properties will be assigned.\n * @param {U} source1 - The first source object whose properties will be assigned to the target object.\n * @param {V} source2 - The second source object whose properties will be assigned to the target object.\n * @param {W} source3 - The third source object whose properties will be assigned to the target object.\n * @param {X} source4 - The fourth source object whose properties will be assigned to the target object.\n * @param {AssignCustomizer} customizer - The function to customize assigned values.\n * @returns {T & U & V & W & X} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n * const result = assignWith(target, source1, source2, source3, source4, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function assignWith<T, U, V, W, X>(\n  object: T,\n  source1: U,\n  source2: V,\n  source3: W,\n  source4: X,\n  customizer: AssignCustomizer\n): T & U & V & W & X;\n\n/**\n * Returns the target object as-is.\n *\n * @template T - The type of the target object.\n * @param {T} object - The target object.\n * @returns {T} The target object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const result = assignWith(target);\n * // => { a: 1, b: 2 }\n */\nexport function assignWith<T>(object: T): T;\n\n/**\n * Assigns own properties from multiple source objects to a target object using a customizer function.\n *\n * @template R - The type of the result.\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} otherArgs - The source objects and customizer function.\n * @returns {R} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignWith(target, { b: 2 }, { c: 3 }, (objValue, srcValue) => {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function assignWith<R>(object: any, ...otherArgs: any[]): R;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n * You can provide a `getValueToAssign` function to determine what value will be assigned for each property.\n *\n * This function merges the properties of the source objects into the target object.\n * If a property in the source objects is equal to the corresponding property in the target object,\n * it will not be overwritten.\n *\n * Unlike `assign`, this method accepts a `getValueToAssign` function that determines\n * the final value to be assigned to each property in the target object. The return value\n * of this function will be directly assigned to the corresponding property. This allows for\n * more precise control over how properties are merged between objects. If not provided,\n * the default behavior is equivalent to using the identity function (returning the source value).\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignWith(target, { b: 2 }, { c: 3 }, function(objValue, srcValue) {\n *   return objValue === undefined ? srcValue : objValue;\n * });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignWith(object: any, ...sources: any[]): any {\n  let getValueToAssign = sources[sources.length - 1];\n\n  if (typeof getValueToAssign === 'function') {\n    sources.pop();\n  } else {\n    getValueToAssign = undefined;\n  }\n\n  for (let i = 0; i < sources.length; i++) {\n    assignWithImpl(object, sources[i], getValueToAssign);\n  }\n\n  return object;\n}\n\nfunction assignWithImpl(\n  object: any,\n  source: any,\n  getValueToAssign?: (objValue: any, srcValue: any, key: string, object: any, source: any) => any\n): any {\n  const keys = keysToolkit(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const objValue = object[key];\n    const srcValue = source[key];\n\n    const newValue = getValueToAssign?.(objValue, srcValue, key, object, source) ?? srcValue;\n\n    if (!(key in object) || !eq(objValue, newValue)) {\n      object[key] = newValue;\n    }\n  }\n}\n","import { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { getTag } from '../_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../_internal/tags.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Creates a shallow clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A shallow clone of the given object.\n *\n * @example\n * // Clone a primitive objs\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n */\nexport function clone<T>(obj: T): T {\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n\n  const tag = getTag(obj);\n\n  if (!isCloneableObject(obj)) {\n    return {} as T;\n  }\n\n  if (isArray(obj)) {\n    const result = Array.from(obj as any) as any;\n\n    if (obj.length > 0 && typeof obj[0] === 'string' && Object.hasOwn(obj, 'index')) {\n      result.index = (obj as any).index;\n      result.input = (obj as any).input;\n    }\n\n    return result;\n  }\n\n  if (isTypedArray(obj)) {\n    const typedArray = obj as unknown as ArrayBufferView;\n    const Ctor = typedArray.constructor as any;\n    return new Ctor(typedArray.buffer, typedArray.byteOffset, (typedArray as any).length) as any;\n  }\n\n  if (tag === arrayBufferTag) {\n    return new ArrayBuffer((obj as unknown as ArrayBuffer).byteLength) as any;\n  }\n\n  if (tag === dataViewTag) {\n    const dataView = obj as unknown as DataView;\n    const buffer = dataView.buffer;\n    const byteOffset = dataView.byteOffset;\n    const byteLength = dataView.byteLength;\n\n    const clonedBuffer = new ArrayBuffer(byteLength);\n    const srcView = new Uint8Array(buffer, byteOffset, byteLength);\n    const destView = new Uint8Array(clonedBuffer);\n    destView.set(srcView);\n\n    return new DataView(clonedBuffer) as any;\n  }\n\n  if (tag === booleanTag || tag === numberTag || tag === stringTag) {\n    const Ctor = (obj as any).constructor;\n    const clone = new Ctor((obj as any).valueOf()) as any;\n\n    if (tag === stringTag) {\n      cloneStringObjectProperties(clone, obj as any);\n    } else {\n      copyOwnProperties(clone, obj as any);\n    }\n\n    return clone;\n  }\n\n  if (tag === dateTag) {\n    return new Date(Number(obj as unknown as Date)) as any;\n  }\n\n  if (tag === regexpTag) {\n    const regExp = obj as unknown as RegExp;\n    const clone = new RegExp(regExp.source, regExp.flags) as any;\n    clone.lastIndex = regExp.lastIndex;\n    return clone;\n  }\n\n  if (tag === symbolTag) {\n    return Object(Symbol.prototype.valueOf.call(obj)) as any;\n  }\n\n  if (tag === mapTag) {\n    const map = obj as unknown as Map<any, any>;\n    const result = new Map();\n\n    map.forEach((obj, key) => {\n      result.set(key, obj);\n    });\n\n    return result as unknown as T;\n  }\n\n  if (tag === setTag) {\n    const set = obj as unknown as Set<any>;\n    const result = new Set();\n\n    set.forEach(obj => {\n      result.add(obj);\n    });\n\n    return result as unknown as T;\n  }\n\n  if (tag === argumentsTag) {\n    const args = obj as any;\n    const result = {} as any;\n\n    copyOwnProperties(result, args);\n\n    result.length = args.length;\n    result[Symbol.iterator] = args[Symbol.iterator];\n\n    return result as T;\n  }\n\n  const result = {} as any;\n\n  copyPrototype(result, obj);\n  copyOwnProperties(result, obj);\n  copySymbolProperties(result, obj);\n\n  return result;\n}\n\nfunction isCloneableObject(object: any): boolean {\n  switch (getTag(object)) {\n    case argumentsTag:\n    case arrayTag:\n    case arrayBufferTag:\n    case dataViewTag:\n    case booleanTag:\n    case dateTag:\n    case float32ArrayTag:\n    case float64ArrayTag:\n    case int8ArrayTag:\n    case int16ArrayTag:\n    case int32ArrayTag:\n    case mapTag:\n    case numberTag:\n    case objectTag:\n    case regexpTag:\n    case setTag:\n    case stringTag:\n    case symbolTag:\n    case uint8ArrayTag:\n    case uint8ClampedArrayTag:\n    case uint16ArrayTag:\n    case uint32ArrayTag: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\nfunction copyOwnProperties(target: any, source: any): void {\n  for (const key in source) {\n    if (Object.hasOwn(source, key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction copySymbolProperties(target: any, source: any): void {\n  const symbols = Object.getOwnPropertySymbols(source);\n  for (let i = 0; i < symbols.length; i++) {\n    const symbol = symbols[i];\n    if (Object.prototype.propertyIsEnumerable.call(source, symbol)) {\n      target[symbol] = source[symbol];\n    }\n  }\n}\n\nfunction cloneStringObjectProperties(target: any, source: any): void {\n  const stringLength = source.valueOf().length;\n\n  for (const key in source) {\n    if (Object.hasOwn(source, key) && (Number.isNaN(Number(key)) || Number(key) >= stringLength)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction copyPrototype(target: any, source: any): void {\n  const proto = Object.getPrototypeOf(source);\n  if (proto !== null) {\n    const Ctor = source.constructor;\n    if (typeof Ctor === 'function') {\n      Object.setPrototypeOf(target, proto);\n    }\n  }\n}\n","import { clone } from './clone.ts';\n\ntype CloneWithCustomizer<T, R> = (value: T, key: number | string | undefined, object: any, stack: any) => R;\n\n/**\n * Creates a shallow clone of a value with customizer that returns a specific result type.\n *\n * @template T - The type of the value to clone.\n * @template R - The result type extending primitive types or objects.\n * @param {T} value - The value to clone.\n * @param {CloneWithCustomizer<T, R>} customizer - The function to customize cloning.\n * @returns {R} Returns the cloned value.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * const cloned = cloneWith(obj, (value) => {\n *   if (typeof value === 'object') {\n *     return JSON.parse(JSON.stringify(value));\n *   }\n * });\n * // => { a: 1, b: 2 }\n */\nexport function cloneWith<T, R extends object | string | number | boolean | null>(\n  value: T,\n  customizer: CloneWithCustomizer<T, R>\n): R;\n\n/**\n * Creates a shallow clone of a value with optional customizer.\n *\n * @template T - The type of the value to clone.\n * @template R - The result type.\n * @param {T} value - The value to clone.\n * @param {CloneWithCustomizer<T, R | undefined>} customizer - The function to customize cloning.\n * @returns {R | T} Returns the cloned value or the customized result.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * const cloned = cloneWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2;\n *   }\n * });\n * // => { a: 2, b: 4 }\n */\nexport function cloneWith<T, R>(value: T, customizer: CloneWithCustomizer<T, R | undefined>): R | T;\n\n/**\n * Creates a shallow clone of a value.\n *\n * @template T - The type of the value to clone.\n * @param {T} value - The value to clone.\n * @returns {T} Returns the cloned value.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * const cloned = cloneWith(obj);\n * // => { a: 1, b: 2 }\n */\nexport function cloneWith<T>(value: T): T;\n\n/**\n * Creates a shallow clone of the given object with customization.\n * This method is like `_.clone` except that it accepts a customizer which\n * is invoked to produce the cloned value. If customizer returns undefined,\n * cloning is handled by the method instead.\n *\n * If no customizer is provided, it behaves like `clone`.\n *\n * @template T - The type of the object.\n * @param {T} value - The value to clone.\n * @param {Function} [customizer] - The function to customize cloning.\n * @returns {T} - A shallow clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = cloneWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = cloneWith(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = cloneWith(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n *   // Returning undefined uses the default cloning\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n */\nexport function cloneWith(value: any, customizer?: any): any {\n  if (!customizer) {\n    return clone(value);\n  }\n\n  const result = customizer(value);\n  if (result !== undefined) {\n    return result;\n  }\n\n  return clone(value);\n}\n","import { keys } from './keys.ts';\nimport { assignValue } from '../_internal/assignValue.ts';\nimport { isObject } from '../predicate/isObject.ts';\n\n/**\n * Creates an object that inherits from the prototype object.\n *\n * If `properties` are provided, they will be added to the new object.\n * Only string-keyed enumerable properties directly owned by the `properties` object are copied.\n * Inherited properties or those with `Symbol` keys are not copied.\n *\n * @template T - The prototype object type.\n * @template U - The properties object type.\n * @param {T} prototype - The object to inherit from.\n * @param {U} properties - The properties to assign to the created object.\n * @returns {T & U} The new object.\n */\nexport function create<T extends object, U extends object>(prototype: T, properties?: U): T & U {\n  const proto = isObject(prototype) ? Object.create(prototype) : ({} as unknown as T);\n  if (properties != null) {\n    const propsKeys = keys(properties);\n    for (let i = 0; i < propsKeys.length; i++) {\n      const key = propsKeys[i];\n      const propsValue = properties[key as keyof U];\n      assignValue(proto, key, propsValue);\n    }\n  }\n  return proto as T & U;\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S} source - The object that specifies the default values to apply.\n * @returns {NonNullable<S & T>} The `object` that has been updated with default values from `source`.\n *\n * @example\n * defaults({ a: 1 }, { b: 2 }); // { a: 1, b: 2 }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults<T, S>(object: T, source: S): NonNullable<S & T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @returns {NonNullable<S2 & S1 & T>} The `object` that has been updated with default values from `source1` and `source2`.\n *\n * @example\n * defaults({ a: 1 }, { b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: undefined }, { a: 1 }, { b: 2 }); // { a: 1, b: 2 }\n */\nexport function defaults<T, S1, S2>(object: T, source1: S1, source2: S2): NonNullable<S2 & S1 & T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @returns {NonNullable<S3 & S2 & S1 & T>} The `object` that has been updated with default values from `source1`, `source2`, and `source3`.\n *\n * @example\n * defaults({ a: 1 }, { b: 2 }, { c: 3 }, { d: 4 }); // { a: 1, b: 2, c: 3, d: 4 }\n * defaults({ a: undefined }, { a: 1 }, { b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n */\nexport function defaults<T, S1, S2, S3>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3\n): NonNullable<S3 & S2 & S1 & T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @template S4 - The type of the fourth object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @param {S4} source4 - The fourth object that specifies the default values to apply.\n * @returns {NonNullable<S4 & S3 & S2 & S1 & T>} The `object` that has been updated with default values from `source1`, `source2`, `source3`, and `source4`.\n *\n * @example\n * defaults({ a: 1 }, { b: 2 }, { c: 3 }, { d: 4 }, { e: 5 }); // { a: 1, b: 2, c: 3, d: 4, e: 5 }\n * defaults({ a: undefined }, { a: 1 }, { b: 2 }, { c: 3 }, { d: 4 }); // { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function defaults<T, S1, S2, S3, S4>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): NonNullable<S4 & S3 & S2 & S1 & T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * @template T - The type of the object being processed.\n * @param {T} object - The target object that will receive default values.\n * @returns {NonNullable<T>} The `object` that has been updated with default values.\n *\n * @example\n * defaults({ a: 1 }); // { a: 1 }\n * defaults({ a: undefined }); // { a: undefined }\n */\nexport function defaults<T>(object: T): NonNullable<T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * @param {any} object - The target object that will receive default values.\n * @param {...any[]} sources - The objects that specify the default values to apply.\n * @returns {any} The `object` that has been updated with default values from `sources`.\n *\n * @example\n * defaults({}, { a: 1 }, { b: 2 }); // { a: 1, b: 2 }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults(object: any, ...sources: any[]): any;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} source - The objects that specifies the default values to apply.\n * @returns {object} The `object` that has been updated with default values from `sources`, ensuring that all properties are defined and none are left as `undefined`.\n *\n * @example\n * defaults({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: null }, { a: 1 }); // { a: null }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults<T extends object, S extends object>(object: T, ...sources: S[]): object {\n  object = Object(object);\n  const objectProto = Object.prototype;\n\n  let length = sources.length;\n  const guard = length > 2 ? sources[2] : undefined;\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  for (let i = 0; i < length; i++) {\n    const source = sources[i];\n    const keys = Object.keys(source) as Array<keyof S>;\n\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j];\n      const value = (object as any)[key];\n\n      if (\n        value === undefined ||\n        (!Object.hasOwn(object, key) && eq(value, objectProto[key as keyof typeof objectProto]))\n      ) {\n        (object as any)[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * A plain object is an object created by the `{}` literal, `new Object()`, or\n * `Object.create(null)`.\n *\n * This function also handles objects with custom\n * `Symbol.toStringTag` properties.\n *\n * `Symbol.toStringTag` is a built-in symbol that a constructor can use to customize the\n * default string description of objects.\n *\n * @param {any} [object] - The value to check.\n * @returns {boolean} - True if the value is a plain object, otherwise false.\n *\n * @example\n * console.log(isPlainObject({})); // true\n * console.log(isPlainObject([])); // false\n * console.log(isPlainObject(null)); // false\n * console.log(isPlainObject(Object.create(null))); // true\n * console.log(isPlainObject(new Map())); // false\n */\nexport function isPlainObject(object?: any): boolean {\n  if (typeof object !== 'object') {\n    return false;\n  }\n\n  if (object == null) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(object) === null) {\n    return true;\n  }\n\n  if (Object.prototype.toString.call(object) !== '[object Object]') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tag = object[Symbol.toStringTag];\n\n    if (tag == null) {\n      return false;\n    }\n\n    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n\n    if (isTagReadonly) {\n      return false;\n    }\n\n    return object.toString() === `[object ${tag}]`;\n  }\n\n  let proto = object;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(object) === proto;\n}\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\n\n/**\n * Recursively assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * Similar to `defaults` but recursively applies default values to nested objects.\n * Source objects are applied in order from left to right, and once a property has been assigned a value,\n * any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`.\n *\n * @template T - The type of the object being processed.\n * @param {any} target - The target object that will receive default values.\n * @param {any[]} sources - One or more source objects that specify default values to apply.\n * @returns {any} The `object` that has been updated with default values from all sources, recursively merging nested objects.\n *\n * @example\n * defaultsDeep({ a: { b: 2 } }, { a: { b: 3, c: 3 }, d: 4 }); // { a: { b: 2, c: 3 }, d: 4 }\n * defaultsDeep({ a: { b: undefined } }, { a: { b: 1 } }); // { a: { b: 1 } }\n * defaultsDeep({ a: null }, { a: { b: 1 } }); // { a: null }\n */\nexport function defaultsDeep(target: any, ...sources: any[]): any {\n  target = Object(target);\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    if (source != null) {\n      const stack = new WeakMap();\n      defaultsDeepRecursive(target, source, stack);\n    }\n  }\n\n  return target;\n}\n\nfunction defaultsDeepRecursive(\n  target: Record<string, any>,\n  source: Record<string, any>,\n  stack: WeakMap<any, any>\n): void {\n  for (const key in source) {\n    const sourceValue = source[key];\n    const targetValue = target[key];\n    const targetHasKey = Object.hasOwn(target, key);\n\n    if (!targetHasKey || targetValue === undefined) {\n      if (stack.has(sourceValue)) {\n        target[key] = stack.get(sourceValue);\n      } else if (isPlainObject(sourceValue)) {\n        const newObj = {};\n        stack.set(sourceValue, newObj);\n        target[key] = newObj;\n        defaultsDeepRecursive(newObj, sourceValue, stack);\n      } else {\n        target[key] = sourceValue;\n      }\n    } else if (isPlainObject(targetValue) && isPlainObject(sourceValue)) {\n      const inStack = stack.has(sourceValue);\n      if (!inStack || (inStack && stack.get(sourceValue) !== targetValue)) {\n        stack.set(sourceValue, targetValue);\n        defaultsDeepRecursive(targetValue, sourceValue, stack);\n      }\n    }\n  }\n}\n","import { findKey as findKeyToolkit } from '../../object/findKey.ts';\nimport { ObjectIteratee } from '../_internal/ObjectIteratee.ts';\nimport { identity } from '../function/identity.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Finds the key of the first element that matches the given predicate.\n *\n * This function determines the type of the predicate and delegates the search\n * to the appropriate helper function. It supports predicates as functions, objects,\n * arrays, or strings.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {ObjectIteratee<T>} predicate - The predicate to match.\n * @returns {string | undefined} Returns the key of the matched element, else `undefined`.\n */\nexport function findKey<T>(obj: T | null | undefined, predicate?: ObjectIteratee<T>): string | undefined {\n  if (!isObject(obj)) {\n    return undefined;\n  }\n\n  const iteratee = createIteratee(predicate ?? identity);\n\n  return findKeyToolkit(obj, iteratee) as string | undefined;\n}\n","/**\n * Finds the key of the first element in the object that satisfies the provided testing function.\n *\n * @param {T} obj - The object to search.\n * @param {(value: T[keyof T], key: keyof T, obj: T) => boolean} predicate - The function to execute on each value in the object. It takes three arguments:\n *   - value: The current value being processed in the object.\n *   - key: The key of the current value being processed in the object.\n *   - obj: The object that findKey was called upon.\n * @returns {keyof T | undefined} The key of the first element in the object that passes the test, or undefined if no element passes.\n *\n * @example\n * const users = {\n *   'barney':  { 'age': 36, 'active': true },\n *   'fred':    { 'age': 40, 'active': false },\n *   'pebbles': { 'age': 1,  'active': true }\n * };\n * findKey(users, function(o) { return o.age < 40; }); => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T, obj: T) => boolean\n): keyof T | undefined {\n  const keys = Object.keys(obj) as Array<keyof T>;\n\n  return keys.find(key => predicate(obj[key], key, obj));\n}\n","import { ObjectIteratee } from '../_internal/ObjectIteratee.ts';\nimport { identity } from '../function/identity.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Finds the key of the last element that matches the given predicate.\n *\n * This function determines the type of the predicate and delegates the search\n * to the appropriate helper function. It supports predicates as functions, objects,\n * arrays, or strings.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} obj - The object to inspect.\n * @param {ObjectIteratee<T>} predicate - The predicate to match.\n * @returns {string | undefined} Returns the key of the matched element, else `undefined`.\n */\nexport function findLastKey<T>(obj: T | null | undefined, predicate?: ObjectIteratee<T>): string | undefined {\n  if (!isObject(obj)) {\n    return undefined;\n  }\n\n  const iteratee = createIteratee(predicate ?? identity);\n\n  const keys = Object.keys(obj);\n\n  return keys.findLast(key => iteratee(obj[key as keyof T], key, obj));\n}\n","import { identity } from '../../function/identity.ts';\n\n/**\n * Iterates over an object and invokes the `iteratee` function for each property.\n *\n * Iterates over string keyed properties including inherited properties.\n *\n * The iteration is terminated early if the `iteratee` function returns `false`.\n *\n * @template T - The type of the object\n * @param {T} object - The object to iterate over\n * @param {(value: T[keyof T], key: string, obj: T) => any} iteratee - The function invoked per iteration\n * @returns {T} Returns the object\n *\n * @example\n * // Iterate over all properties including inherited ones\n * const obj = { a: 1, b: 2 };\n * forIn(obj, (value, key) => {\n *   console.log(key, value);\n * });\n * // Output: 'a' 1, 'b' 2\n *\n * // Early termination\n * forIn(obj, (value, key) => {\n *   console.log(key, value);\n *   return key !== 'a'; // stop after 'a'\n * });\n * // Output: 'a' 1\n */\nexport function forIn<T>(object: T, iteratee?: (value: T[keyof T], key: string, collection: T) => any): T;\n\n/**\n * Iterates over an object and invokes the `iteratee` function for each property.\n *\n * Iterates over string keyed properties including inherited properties.\n *\n * The iteration is terminated early if the `iteratee` function returns `false`.\n *\n * @template T - The type of the object\n * @param {T | null | undefined} object - The object to iterate over\n * @param {(value: T[keyof T], key: string, obj: T) => any} iteratee - The function invoked per iteration\n * @returns {T | null | undefined} Returns the object\n *\n * @example\n * // Iterate over all properties including inherited ones\n * const obj = { a: 1, b: 2 };\n * forIn(obj, (value, key) => {\n *   console.log(key, value);\n * });\n * // Output: 'a' 1, 'b' 2\n *\n * // Early termination\n * forIn(obj, (value, key) => {\n *   console.log(key, value);\n *   return key !== 'a'; // stop after 'a'\n * });\n * // Output: 'a' 1\n */\nexport function forIn<T>(\n  object: T | null | undefined,\n  iteratee?: (value: T[keyof T], key: string, collection: T) => any\n): T | null | undefined;\n\n/**\n * Iterates over an object and invokes the `iteratee` function for each property.\n *\n * Iterates over string keyed properties including inherited properties.\n *\n * The iteration is terminated early if the `iteratee` function returns `false`.\n *\n * @template T - The type of the object\n * @param {T | null | undefined} object - The object to iterate over\n * @param {(value: T[keyof T], key: string, obj: T) => any} iteratee - The function invoked per iteration\n * @returns {T | null | undefined} Returns the object\n *\n * @example\n * // Iterate over all properties including inherited ones\n * const obj = { a: 1, b: 2 };\n * forIn(obj, (value, key) => {\n *   console.log(key, value);\n * });\n * // Output: 'a' 1, 'b' 2\n *\n * // Early termination\n * forIn(obj, (value, key) => {\n *   console.log(key, value);\n *   return key !== 'a'; // stop after 'a'\n * });\n * // Output: 'a' 1\n */\nexport function forIn<T>(\n  object: T | null | undefined,\n  iteratee: (value: T[keyof T], key: string, collection: T) => any = identity\n): T | null | undefined {\n  if (object == null) {\n    return object;\n  }\n\n  for (const key in object) {\n    const result = iteratee(object[key as keyof T], key, object);\n\n    if (result === false) {\n      break;\n    }\n  }\n\n  return object;\n}\n","import { identity } from '../../function/identity.ts';\n\n/**\n * Iterates over an object in reverse order and invokes the `iteratee` function for each property.\n *\n * Iterates over string keyed properties including inherited properties in reverse order.\n *\n * The iteration is terminated early if the `iteratee` function returns `false`.\n *\n * @template T - The type of the object\n * @param {T} object - The object to iterate over\n * @param {(value: T[keyof T], key: string, collection: T) => any} iteratee - The function invoked per iteration\n * @returns {T} Returns the object\n *\n * @example\n * // Iterate over all properties including inherited ones\n * const obj = { a: 1, b: 2 };\n * forInRight(obj, (value, key) => {\n *   console.log(key, value);\n * });\n * // Output: 'b' 2, 'a' 1\n *\n * // Early termination\n * forInRight(obj, (value, key) => {\n *   console.log(key, value);\n *   return key !== 'a'; // stop after 'a'\n * });\n * // Output: 'b' 2\n */\nexport function forInRight<T>(object: T, iteratee?: (value: T[keyof T], key: string, collection: T) => any): T;\n\n/**\n * Iterates over an object in reverse order and invokes the `iteratee` function for each property.\n *\n * Iterates over string keyed properties including inherited properties in reverse order.\n *\n * The iteration is terminated early if the `iteratee` function returns `false`.\n *\n * @template T - The type of the object\n * @param {T | null | undefined} object - The object to iterate over\n * @param {(value: T[keyof T], key: string, obj: T) => any} iteratee - The function invoked per iteration\n * @returns {T | null | undefined} Returns the object\n *\n * @example\n * // Iterate over all properties including inherited ones\n * const obj = { a: 1, b: 2 };\n * forInRight(obj, (value, key) => {\n *   console.log(key, value);\n * });\n * // Output: 'b' 2, 'a' 1\n *\n * // Early termination\n * forInRight(obj, (value, key) => {\n *   console.log(key, value);\n *   return key !== 'a'; // stop after 'a'\n * });\n * // Output: 'b' 2\n */\nexport function forInRight<T>(\n  object: T | null | undefined,\n  iteratee?: (value: T[keyof T], key: string, collection: T) => any\n): T | null | undefined;\n\n/**\n * Iterates over an object in reverse order and invokes the `iteratee` function for each property.\n *\n * Iterates over string keyed properties including inherited properties in reverse order.\n *\n * The iteration is terminated early if the `iteratee` function returns `false`.\n *\n * @template T - The type of the object\n * @param {T | null | undefined} object - The object to iterate over\n * @param {(value: T[keyof T], key: string, obj: T) => any} iteratee - The function invoked per iteration\n * @returns {T | null | undefined} Returns the object\n *\n * @example\n * // Iterate over all properties including inherited ones\n * const obj = { a: 1, b: 2 };\n * forInRight(obj, (value, key) => {\n *   console.log(key, value);\n * });\n * // Output: 'b' 2, 'a' 1\n *\n * // Early termination\n * forInRight(obj, (value, key) => {\n *   console.log(key, value);\n *   return key !== 'a'; // stop after 'a'\n * });\n * // Output: 'b' 2\n */\nexport function forInRight<T>(\n  object: T | null | undefined,\n  iteratee: (value: T[keyof T], key: string, collection: T) => any = identity\n): T | null | undefined {\n  if (object == null) {\n    return object;\n  }\n\n  const keys: string[] = [];\n\n  for (const key in object) {\n    keys.push(key);\n  }\n\n  for (let i = keys.length - 1; i >= 0; i--) {\n    const key = keys[i];\n    const result = iteratee(object[key as keyof T], key, object);\n\n    if (result === false) {\n      break;\n    }\n  }\n\n  return object;\n}\n","import { keys as keysToolkit } from './keys.ts';\nimport { identity } from '../../function/identity.ts';\n\n/**\n * Iterates over an object's properties and calls the `iteratee` function for each property.\n *\n * It only iterates over the object's own properties, not including inherited properties or properties with `Symbol` keys.\n *\n * The `iteratee` function can terminate the iteration early by returning `false`.\n *\n * @template T - The type of the object.\n * @param {T} object The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => any} [iteratee=identity] The function invoked per iteration. If not provided, the identity function will be used.\n * @return {T} Returns object.\n *\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * forOwn(new Foo(), function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nexport function forOwn<T>(object: T, iteratee?: (value: T[keyof T], key: string, collection: T) => any): T;\n\n/**\n * Iterates over an object's properties and calls the `iteratee` function for each property.\n *\n * It only iterates over the object's own properties, not including inherited properties or properties with `Symbol` keys.\n *\n * The `iteratee` function can terminate the iteration early by returning `false`.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} object The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => any} [iteratee=identity] The function invoked per iteration. If not provided, the identity function will be used.\n * @return {T | null | undefined} Returns object.\n *\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * forOwn(new Foo(), function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nexport function forOwn<T>(\n  object: T | null | undefined,\n  iteratee?: (value: T[keyof T], key: string, collection: T) => any\n): T | null | undefined;\n\n/**\n * Iterates over an object's properties and calls the `iteratee` function for each property.\n *\n * It only iterates over the object's own properties, not including inherited properties or properties with `Symbol` keys.\n *\n * The `iteratee` function can terminate the iteration early by returning `false`.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} object The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => any} [iteratee=identity] The function invoked per iteration. If not provided, the identity function will be used.\n * @return {T | null | undefined} Returns object.\n *\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * forOwn(new Foo(), function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nexport function forOwn<T>(\n  object: T | null | undefined,\n  iteratee: (value: T[keyof T], key: string, collection: T) => any = identity\n): T | null | undefined {\n  if (object == null) {\n    return object;\n  }\n\n  const iterable = Object(object);\n  const keys = keysToolkit(object);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (iteratee(iterable[key], key, iterable) === false) {\n      break;\n    }\n  }\n\n  return object;\n}\n","import { keys as keysToolkit } from './keys.ts';\nimport { identity } from '../../function/identity.ts';\n\n/**\n * Iterates over an object's properties in reverse order and calls the `iteratee` function for each property.\n *\n * It only iterates over the object's own properties, not including inherited properties or properties with `Symbol` keys.\n *\n * The `iteratee` function can terminate the iteration early by returning `false`.\n *\n * @template T - The type of the object.\n * @param {T} object The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => any} [iteratee=identity] The function invoked per iteration. If not provided, the identity function will be used.\n * @return {T} Returns object.\n *\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * forOwnRight(new Foo(), function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'b' then 'a' (iteration order is not guaranteed).\n */\nexport function forOwnRight<T>(object: T, iteratee?: (value: T[keyof T], key: string, collection: T) => any): T;\n\n/**\n * Iterates over an object's properties in reverse order and calls the `iteratee` function for each property.\n *\n * It only iterates over the object's own properties, not including inherited properties or properties with `Symbol` keys.\n *\n * The `iteratee` function can terminate the iteration early by returning `false`.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} object The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => any} [iteratee=identity] The function invoked per iteration. If not provided, the identity function will be used.\n * @return {T | null | undefined} Returns object.\n *\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * forOwnRight(new Foo(), function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'b' then 'a' (iteration order is not guaranteed).\n */\nexport function forOwnRight<T>(\n  object: T | null | undefined,\n  iteratee?: (value: T[keyof T], key: string, collection: T) => any\n): T | null | undefined;\n\n/**\n * Iterates over an object's properties in reverse order and calls the `iteratee` function for each property.\n *\n * It only iterates over the object's own properties, not including inherited properties or properties with `Symbol` keys.\n *\n * The `iteratee` function can terminate the iteration early by returning `false`.\n *\n * @template T - The type of the object.\n * @param {T | null | undefined} object The object to iterate over.\n * @param {(value: T[keyof T], key: string, collection: T) => any} [iteratee=identity] The function invoked per iteration. If not provided, the identity function will be used.\n * @return {T | null | undefined} Returns object.\n *\n * @example\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * forOwnRight(new Foo(), function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'b' then 'a' (iteration order is not guaranteed).\n */\nexport function forOwnRight<T>(\n  object: T | null | undefined,\n  iteratee: (value: T[keyof T], key: string, collection: T) => any = identity\n): T | null | undefined {\n  if (object == null) {\n    return object;\n  }\n\n  const iterable = Object(object);\n  const keys = keysToolkit(object);\n\n  for (let i = keys.length - 1; i >= 0; --i) {\n    const key = keys[i];\n    if (iteratee(iterable[key], key, iterable) === false) {\n      break;\n    }\n  }\n\n  return object;\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\ntype PropertyName = string | number | symbol;\n\n/**\n * Converts an array of key-value pairs into an object.\n *\n * @template T - The type of the values.\n * @param {ArrayLike<[PropertyName, T]> | null | undefined} pairs - An array of key-value pairs.\n * @returns {Record<string, T>} - An object where keys are strings and values are of type T.\n *\n * @example\n * const pairs = [['a', 1], ['b', 2]];\n * const result = fromPairs(pairs);\n * // => { a: 1, b: 2 }\n */\nexport function fromPairs<T>(pairs: ArrayLike<[PropertyName, T]> | null | undefined): Record<string, T>;\n\n/**\n * Converts an array of key-value pairs into an object.\n *\n * @param {ArrayLike<any[]> | null | undefined} pairs - An array of key-value pairs.\n * @returns {Record<string, any>} - An object where keys are strings and values can be any type.\n *\n * @example\n * const pairs = [['a', 1], ['b', 'hello']];\n * const result = fromPairs(pairs);\n * // => { a: 1, b: 'hello' }\n */\nexport function fromPairs(pairs: ArrayLike<any[]> | null | undefined): Record<string, any>;\n\n/**\n * Converts an array of key-value pairs into an object.\n *\n * @template T - The type of the keys in the resulting object. It must extend `PropertyKey`.\n * @template U - The type of the values in the resulting object.\n *\n * @param {Array<[T, U]>} pairs - An array of key-value pairs where each key is a `PropertyKey` and each value is of type `U`.\n * @returns {Record<T, U>} - An object where the keys are of type `T` and the values are of type `U`.\n *\n * @example\n * const pairs = [['a', 1], ['b', 2]];\n * const result = fromPairs(pairs);\n * // result will be: { a: 1, b: 2 }\n */\nexport function fromPairs<T>(\n  pairs: ArrayLike<[PropertyName, T]> | ArrayLike<any[]> | null | undefined\n): Record<string, any> | Record<string, T> {\n  if (!isArrayLike(pairs)) {\n    return {};\n  }\n\n  const result: Record<string, any> = {};\n\n  for (let i = 0; i < pairs.length; i++) {\n    const [key, value] = pairs[i];\n    result[key] = value;\n  }\n\n  return result;\n}\n","import { keys } from './keys.ts';\n\n/**\n * Creates an array of property names from an object where the property values are functions.\n *\n * @param {any} object - The object to inspect.\n * @returns {string[]} - An array of function property names.\n *\n * @example\n * function Foo() {\n *   this.a = () => 'a';\n *   this.b = () => 'b';\n * }\n *\n * Foo.prototype.c = () => 'c';\n *\n * functions(new Foo);\n * // => ['a', 'b']\n */\nexport function functions(object: any): string[];\n\n/**\n * Creates an array of property names from an object where the property values are functions.\n *\n * Only checks for own properties with string keys. Inherited properties or\n * properties with Symbol keys are not included.\n *\n * @param {unknown} object The object to inspect.\n * @returns {string[]} An array of function property names.\n *\n * @example\n *\n * function Foo() {\n *   this.a = () => 'a'\n *   this.b = () => 'b'\n * }\n *\n * Foo.prototype.c = () => 'c'\n *\n * functions(new Foo)\n * // => ['a', 'b']\n */\nexport function functions(object: any): string[] {\n  if (object == null) {\n    return [];\n  }\n\n  return keys(object).filter(key => typeof object[key as keyof typeof object] === 'function');\n}\n","import { isFunction } from '../../predicate/isFunction.ts';\n\n/**\n * Returns an array of property names whose values are functions, including inherited properties.\n *\n * @param {*} object The object to inspect.\n * @returns {Array} Returns the function names.\n * @example\n *\n * function Foo() {\n *   this.a = function() { return 'a'; };\n *   this.b = function() { return 'b'; };\n * }\n *\n * Foo.prototype.c = function() { return 'c'; };\n *\n * functionsIn(new Foo);\n * // => ['a', 'b', 'c']\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-object-type\nexport function functionsIn<T extends {}>(object: any): string[] {\n  if (object == null) {\n    return [];\n  }\n\n  const result: string[] = [];\n\n  for (const key in object) {\n    if (isFunction(object[key])) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Checks if a given path exists in an object, **including inherited properties**.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * Unlike `has`, which only checks for own properties, `hasIn` also checks for properties\n * in the prototype chain.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @template T\n * @param {T} object - The object to query.\n * @param {PropertyPath} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists (own or inherited), `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * hasIn(obj, 'a'); // true\n * hasIn(obj, ['a', 'b']); // true\n * hasIn(obj, ['a', 'b', 'c']); // true\n * hasIn(obj, 'a.b.c'); // true\n * hasIn(obj, 'a.b.d'); // false\n * hasIn(obj, ['a', 'b', 'c', 'd']); // false\n *\n * // Example with inherited properties:\n * function Rectangle() {}\n * Rectangle.prototype.area = function() {};\n *\n * const rect = new Rectangle();\n * hasIn(rect, 'area'); // true\n * has(rect, 'area'); // false - has only checks own properties\n */\nexport function hasIn<T>(object: T, path: PropertyPath): boolean {\n  if (object == null) {\n    return false;\n  }\n\n  let resolvedPath;\n\n  if (Array.isArray(path)) {\n    resolvedPath = path;\n  } else if (typeof path === 'string' && isDeepKey(path) && (object as any)[path] == null) {\n    resolvedPath = toPath(path);\n  } else {\n    resolvedPath = [path];\n  }\n\n  if (resolvedPath.length === 0) {\n    return false;\n  }\n\n  let current = object;\n\n  for (let i = 0; i < resolvedPath.length; i++) {\n    const key = resolvedPath[i] as keyof T;\n\n    // hasIn: check both own and inherited properties\n    if (current == null || !(key in Object(current))) {\n      const isSparseIndex =\n        (Array.isArray(current) || isArguments(current)) && isIndex(key) && (key as number) < current.length;\n\n      if (!isSparseIndex) {\n        return false;\n      }\n    }\n\n    current = current[key] as NonNullable<T>;\n  }\n\n  return true;\n}\n","import { invert as invertToolkit } from '../../object/invert.ts';\n\n/**\n * Inverts the keys and values of an object.\n *\n * @param {object} object - The object to invert.\n * @returns {Record<string, string>} - Returns the new inverted object.\n *\n * @example\n * invert({ a: 1, b: 2, c: 3 });\n * // => { '1': 'a', '2': 'b', '3': 'c' }\n */\nexport function invert(object: object): Record<string, string>;\n\n/**\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\n *\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\n * of the input object's key-value pairs.\n *\n * @template K - Type of the keys in the input object (string, number, symbol)\n * @template V - Type of the values in the input object (string, number, symbol)\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\n * @returns {Record<V, K>} - A new object with keys and values inverted\n *\n * @example\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\n */\nexport function invert(obj: object): Record<string, string> {\n  return invertToolkit(obj);\n}\n","/**\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\n *\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\n * of the input object's key-value pairs.\n *\n * @template K - Type of the keys in the input object (string, number, symbol)\n * @template V - Type of the values in the input object (string, number, symbol)\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\n * @returns {Record<V, K>} - A new object with keys and values inverted\n *\n * @example\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\n */\nexport function invert<K extends PropertyKey, V extends PropertyKey>(obj: Record<K, V>): Record<V, K> {\n  const result = {} as Record<V, K>;\n\n  const keys = Object.keys(obj) as K[];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n    result[value] = key;\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { isNil } from '../../predicate/isNil.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Creates a new object that reverses the keys and values of the given object, similar to the invert.\n * The values of the new object are arrays of keys that correspond to the value returned by the `iteratee` function.\n *\n * @param {Record<string|number, T>} object - The object to iterate over\n * @param {ValueIteratee<T>} [iteratee] - Optional function to transform values into keys\n * @returns {Record<string, string[]>} An object with transformed values as keys and arrays of original keys as values\n *\n * @example\n * const obj = { a: 1, b: 2, c: 1 };\n * invertBy(obj); // => { '1': ['a', 'c'], '2': ['b'] }\n *\n * @example\n * const obj = { a: 1, b: 2, c: 1 };\n * invertBy(obj, value => `group${value}`); // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n */\nexport function invertBy<T>(\n  object: Record<string, T> | Record<number, T> | null | undefined,\n  interatee?: ValueIteratee<T>\n): Record<string, string[]>;\n\n/**\n * Creates a new object that reverses the keys and values of the given object, similar to the invert.\n * The values of the new object are arrays of keys that correspond to the value returned by the `iteratee` function.\n *\n * @param {T} object - The object to iterate over\n * @param {ValueIteratee<T[keyof T]>} [iteratee] - Optional function to transform values into keys\n * @returns {Record<string, string[]>} An object with transformed values as keys and arrays of original keys as values\n *\n * @example\n * const obj = { foo: { id: 1 }, bar: { id: 2 }, baz: { id: 1 } };\n * invertBy(obj, value => String(value.id)); // => { '1': ['foo', 'baz'], '2': ['bar'] }\n */\nexport function invertBy<T extends object>(\n  object: T | null | undefined,\n  interatee?: ValueIteratee<T[keyof T]>\n): Record<string, string[]>;\n\n/**\n * Creates a new object that reverses the keys and values of the given object, similar to the invert.\n *\n * The `iteratee` function specifies how the values are reversed into keys. If no `iteratee` function is provided, the values are used as keys as-is.\n *\n * The values of the new object are arrays of keys that correspond to the value returned by the `iteratee` function.\n *\n * @param {Record<K, V>} object - The object to iterate over.\n * @param {(value: V) => string} [iteratee] - Optional. A function that generates a key based on each value in the object.\n * If not provided, the function defaults to using the value as a string.\n *\n * @returns {Record<string, K[]>} An object where the keys are generated by the iteratee, and the values\n * are arrays of property names (keys) from the input object that correspond to those keys.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 1 };\n * const result = invertBy(obj);\n * // result => { '1': ['a', 'c'], '2': ['b'] }\n *\n * @example\n * const obj = { a: 1, b: 2, c: 1 };\n * const result = invertBy(obj, value => `group${value}`);\n * // result => { 'group1': ['a', 'c'], 'group2': ['b'] }\n */\nexport function invertBy<T extends object>(\n  object: T | null | undefined,\n  iteratee?: ValueIteratee<T[keyof T]>\n): Record<string, string[]> {\n  const result = {} as Record<string, string[]>;\n\n  if (isNil(object)) {\n    return result;\n  }\n\n  if (iteratee == null) {\n    iteratee = identity as (value: T[keyof T]) => string;\n  }\n\n  const keys = Object.keys(object);\n  const getString = iterateeToolkit(iteratee);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as string;\n\n    const value = (object as any)[key];\n    const valueStr = getString(value);\n\n    if (Array.isArray(result[valueStr])) {\n      result[valueStr].push(key);\n    } else {\n      result[valueStr] = [key];\n    }\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { mapKeys as mapKeysToolkit } from '../../object/mapKeys.ts';\nimport { ListIteratee } from '../_internal/ListIteratee.ts';\nimport { ObjectIteratee } from '../_internal/ObjectIteratee.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Creates an object with the same values as `object` and keys generated by running each own enumerable string keyed property through `iteratee`.\n *\n * @template T\n * @param {ArrayLike<T> | null | undefined} object - The object to iterate over.\n * @param {ValueIteratee<T>} [iteratee] - The function invoked per iteration.\n * @returns {Record<string, T>} - Returns the new mapped object.\n *\n * @example\n * mapKeys([1, 2, 3], (value, index) => `key${index}`);\n * // => { 'key0': 1, 'key1': 2, 'key2': 3 }\n */\nexport function mapKeys<T>(object: ArrayLike<T> | null | undefined, iteratee?: ListIteratee<T>): Record<string, T>;\n\n/**\n * Creates an object with the same values as `object` and keys generated by running each own enumerable string keyed property through `iteratee`.\n *\n * @template T\n * @param {T | null | undefined} object - The object to iterate over.\n * @param {ValueIteratee<T[keyof T]>} [iteratee] - The function invoked per iteration.\n * @returns {Record<string, T[keyof T]>} - Returns the new mapped object.\n *\n * @example\n * mapKeys({ a: 1, b: 2 }, (value, key) => key + value);\n * // => { 'a1': 1, 'b2': 2 }\n */\nexport function mapKeys<T extends object>(\n  object: T | null | undefined,\n  iteratee?: ObjectIteratee<T>\n): Record<string, T[keyof T]>;\n\n/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the keys in the object.\n * @template K2 - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K1], key: K1, object: T) => K2} [getNewKey] - The function invoked per own enumerable property, or a path to generate new keys.\n * @returns {Record<K2, T[K1]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys(object: any, getNewKey: ListIteratee<any> = identity): Record<string, any> {\n  if (object == null) {\n    return {};\n  }\n\n  return mapKeysToolkit(object, iteratee(getNewKey));\n}\n","/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => K} getNewKey - The function invoked per own enumerable property.\n * @returns {Record<K, T[keyof T]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends Record<PropertyKey, any>, K extends PropertyKey>(\n  object: T,\n  getNewKey: (value: T[keyof T], key: keyof T, object: T) => K\n): Record<K, T[keyof T]> {\n  const result = {} as Record<K, T[keyof T]>;\n  const keys = Object.keys(object) as Array<keyof T>;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = object[key];\n\n    result[getNewKey(value, key, object)] = value as any;\n  }\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { mapValues as mapValuesToolkit } from '../../object/mapValues.ts';\nimport { ArrayIterator } from '../_internal/ArrayIterator.ts';\nimport { ObjectIterator } from '../_internal/ObjectIterator.ts';\nimport { StringIterator } from '../_internal/StringIterator.ts';\nimport { ValueIteratee } from '../_internal/ValueIteratee.ts';\nimport { iteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a new object by mapping each character in a string to a value.\n * @param obj - The string to iterate over\n * @param callback - The function invoked per character\n * @returns A new object with numeric keys and mapped values\n * @example\n * mapValues('abc', (char) => char.toUpperCase())\n * // => { '0': 'A', '1': 'B', '2': 'C' }\n */\nexport function mapValues<T>(obj: string | null | undefined, callback: StringIterator<T>): Record<number, T>;\n\n/**\n * Creates a new object by mapping each element in an array to a value.\n * @param array - The array to iterate over\n * @param callback - The function invoked per element\n * @returns A new object with numeric keys and mapped values\n * @example\n * mapValues([1, 2], (num) => num * 2)\n * // => { '0': 2, '1': 4 }\n */\nexport function mapValues<T, U>(array: T[], callback: ArrayIterator<T, U>): Record<number, U>;\n\n/**\n * Creates a new object by mapping each property value in an object to a new value.\n * @param obj - The object to iterate over\n * @param callback - The function invoked per property\n * @returns A new object with the same keys and mapped values\n * @example\n * mapValues({ a: 1, b: 2 }, (num) => num * 2)\n * // => { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, U>(\n  obj: T | null | undefined,\n  callback: ObjectIterator<T, U>\n): { [P in keyof T]: U };\n\n/**\n * Creates a new object by checking each value against a matcher object.\n * @param obj - The object to iterate over\n * @param iteratee - The object to match against\n * @returns A new object with boolean values indicating matches\n * @example\n * mapValues({ a: { x: 1 }, b: { x: 2 } }, { x: 2 })\n * // => { a: false, b: true }\n */\nexport function mapValues<T>(\n  obj: Record<string, T> | Record<number, T> | null | undefined,\n  iteratee: object\n): Record<string, boolean>;\n\n/**\n * Creates a new object by checking each value against a matcher object.\n * @param obj - The object to iterate over\n * @param iteratee - The object to match against\n * @returns A new object with boolean values indicating matches\n * @example\n * mapValues({ a: { x: 1 }, b: { x: 2 } }, { x: 2 })\n * // => { a: false, b: true }\n */\nexport function mapValues<T extends object>(obj: T | null | undefined, iteratee: object): { [P in keyof T]: boolean };\n\n/**\n * Creates a new object by extracting a property from each value.\n * @param obj - The object to iterate over\n * @param iteratee - The property key to extract\n * @returns A new object with extracted property values\n * @example\n * mapValues({ a: { x: 1 }, b: { x: 2 } }, 'x')\n * // => { a: 1, b: 2 }\n */\nexport function mapValues<T, K extends keyof T>(\n  obj: Record<string, T> | Record<number, T> | null | undefined,\n  iteratee: K\n): Record<string, T[K]>;\n\n/**\n * Creates a new object by extracting values at a path from each value.\n * @param obj - The object to iterate over\n * @param iteratee - The path to extract\n * @returns A new object with extracted values\n * @example\n * mapValues({ a: { x: { y: 1 } }, b: { x: { y: 2 } } }, 'x.y')\n * // => { a: 1, b: 2 }\n */\nexport function mapValues<T>(\n  obj: Record<string, T> | Record<number, T> | null | undefined,\n  iteratee: string\n): Record<string, any>;\n\n/**\n * Creates a new object by extracting values at a path from each value.\n * @param obj - The object to iterate over\n * @param iteratee - The path to extract\n * @returns A new object with extracted values\n * @example\n * mapValues({ a: { x: { y: 1 } }, b: { x: { y: 2 } } }, 'x.y')\n * // => { a: 1, b: 2 }\n */\nexport function mapValues<T extends object>(obj: T | null | undefined, iteratee: string): { [P in keyof T]: any };\n\n/**\n * Creates a new object from a string using identity function.\n * @param obj - The string to convert\n * @returns A new object with characters as values\n * @example\n * mapValues('abc')\n * // => { '0': 'a', '1': 'b', '2': 'c' }\n */\nexport function mapValues(obj: string | null | undefined): Record<number, string>;\n\n/**\n * Creates a new object using identity function.\n * @param obj - The object to clone\n * @returns A new object with the same values\n * @example\n * mapValues({ a: 1, b: 2 })\n * // => { a: 1, b: 2 }\n */\nexport function mapValues<T>(obj: Record<string, T> | Record<number, T> | null | undefined): Record<string, T>;\n\n/**\n * Creates a new object using identity function.\n * @param obj - The object to clone\n * @returns A new object with the same values\n * @example\n * mapValues({ a: 1, b: 2 })\n * // => { a: 1, b: 2 }\n */\nexport function mapValues<T extends object>(obj: T): T;\n\n/**\n * Creates a new object using identity function.\n * @param obj - The object to clone\n * @returns A new object with the same values, or empty object if input is null/undefined\n * @example\n * mapValues({ a: 1, b: 2 })\n * // => { a: 1, b: 2 }\n * mapValues(null)\n * // => {}\n */\nexport function mapValues<T extends object>(obj: T | null | undefined): Partial<T>;\n\n/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V | PropertyKey | readonly PropertyKey[] | null | undefined} [getNewValue] -\n *        The function invoked per own enumerable property, or a path to generate new values.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues(object: any, getNewValue: ValueIteratee<any> = identity): Record<string, any> {\n  if (object == null) {\n    return {};\n  }\n\n  return mapValuesToolkit(object, iteratee(getNewValue));\n}\n","/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue: (value: T[K], key: K, object: T) => V\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as K;\n    const value = object[key];\n\n    result[key] = getNewValue(value, key, object);\n  }\n\n  return result;\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { isUnsafeProperty } from '../../_internal/isUnsafeProperty.ts';\nimport { clone } from '../../object/clone.ts';\nimport { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { getSymbols } from '../_internal/getSymbols.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\nimport { isPlainObject } from '../predicate/isPlainObject.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\ntype MergeWithCustomizer = (objValue: any, srcValue: any, key: string, object: any, source: any, stack: any) => any;\n\n/**\n * Merges the properties of a source object into the target object using a customizer function.\n *\n * @template TObject\n * @template TSource\n * @param {TObject} object - The target object into which the source object properties will be merged.\n * @param {TSource} source - The source object whose properties will be merged into the target object.\n * @param {MergeWithCustomizer} customizer - The function to customize assigned values.\n * @returns {TObject & TSource} Returns the updated target object with properties from the source object merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (typeof objValue === 'number' && typeof srcValue === 'number') {\n *     return objValue + srcValue;\n *   }\n * });\n * // => { a: 1, b: 5, c: 4 }\n */\nexport function mergeWith<TObject, TSource>(\n  object: TObject,\n  source: TSource,\n  customizer: MergeWithCustomizer\n): TObject & TSource;\n\n/**\n * Merges the properties of two source objects into the target object using a customizer function.\n *\n * @template TObject\n * @template TSource1\n * @template TSource2\n * @param {TObject} object - The target object into which the source objects properties will be merged.\n * @param {TSource1} source1 - The first source object.\n * @param {TSource2} source2 - The second source object.\n * @param {MergeWithCustomizer} customizer - The function to customize assigned values.\n * @returns {TObject & TSource1 & TSource2} Returns the updated target object with properties from the source objects merged in.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n *\n * const result = mergeWith(target, source1, source2, (objValue, srcValue) => {\n *   if (typeof objValue === 'number' && typeof srcValue === 'number') {\n *     return objValue + srcValue;\n *   }\n * });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function mergeWith<TObject, TSource1, TSource2>(\n  object: TObject,\n  source1: TSource1,\n  source2: TSource2,\n  customizer: MergeWithCustomizer\n): TObject & TSource1 & TSource2;\n\n/**\n * Merges the properties of three source objects into the target object using a customizer function.\n *\n * @template TObject\n * @template TSource1\n * @template TSource2\n * @template TSource3\n * @param {TObject} object - The target object into which the source objects properties will be merged.\n * @param {TSource1} source1 - The first source object.\n * @param {TSource2} source2 - The second source object.\n * @param {TSource3} source3 - The third source object.\n * @param {MergeWithCustomizer} customizer - The function to customize assigned values.\n * @returns {TObject & TSource1 & TSource2 & TSource3} Returns the updated target object with properties from the source objects merged in.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n *\n * const result = mergeWith(target, source1, source2, source3, (objValue, srcValue) => {\n *   if (typeof objValue === 'number' && typeof srcValue === 'number') {\n *     return objValue + srcValue;\n *   }\n * });\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function mergeWith<TObject, TSource1, TSource2, TSource3>(\n  object: TObject,\n  source1: TSource1,\n  source2: TSource2,\n  source3: TSource3,\n  customizer: MergeWithCustomizer\n): TObject & TSource1 & TSource2 & TSource3;\n\n/**\n * Merges the properties of four source objects into the target object using a customizer function.\n *\n * @template TObject\n * @template TSource1\n * @template TSource2\n * @template TSource3\n * @template TSource4\n * @param {TObject} object - The target object into which the source objects properties will be merged.\n * @param {TSource1} source1 - The first source object.\n * @param {TSource2} source2 - The second source object.\n * @param {TSource3} source3 - The third source object.\n * @param {TSource4} source4 - The fourth source object.\n * @param {MergeWithCustomizer} customizer - The function to customize assigned values.\n * @returns {TObject & TSource1 & TSource2 & TSource3 & TSource4} Returns the updated target object with properties from the source objects merged in.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n *\n * const result = mergeWith(target, source1, source2, source3, source4, (objValue, srcValue) => {\n *   if (typeof objValue === 'number' && typeof srcValue === 'number') {\n *     return objValue + srcValue;\n *   }\n * });\n * // => { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function mergeWith<TObject, TSource1, TSource2, TSource3, TSource4>(\n  object: TObject,\n  source1: TSource1,\n  source2: TSource2,\n  source3: TSource3,\n  source4: TSource4,\n  customizer: MergeWithCustomizer\n): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged.\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (typeof objValue === 'number' && typeof srcValue === 'number') {\n *     return objValue + srcValue;\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any;\n\n/**\n * Merges the properties of one or more source objects into the target object using a customizer function.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any {\n  const sources = otherArgs.slice(0, -1);\n  const merge = otherArgs[otherArgs.length - 1] as (\n    targetValue: any,\n    sourceValue: any,\n    key: string | symbol,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any;\n\n  let result = object;\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n\n    result = mergeWithDeep(result, source, merge, new Map());\n  }\n\n  return result;\n}\n\nfunction mergeWithDeep(\n  target: any,\n  source: any,\n  merge: (\n    targetValue: any,\n    sourceValue: any,\n    key: string | symbol,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any,\n  stack: Map<any, any>\n) {\n  if (isPrimitive(target)) {\n    target = Object(target);\n  }\n\n  if (source == null || typeof source !== 'object') {\n    return target;\n  }\n\n  if (stack.has(source)) {\n    return clone(stack.get(source));\n  }\n\n  stack.set(source, target);\n\n  if (Array.isArray(source)) {\n    source = source.slice();\n    for (let i = 0; i < source.length; i++) {\n      source[i] = source[i] ?? undefined;\n    }\n  }\n\n  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    if (isUnsafeProperty(key)) {\n      continue;\n    }\n\n    let sourceValue = source[key];\n    let targetValue = target[key];\n\n    if (isArguments(sourceValue)) {\n      sourceValue = { ...sourceValue };\n    }\n\n    if (isArguments(targetValue)) {\n      targetValue = { ...targetValue };\n    }\n\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n      sourceValue = cloneDeep(sourceValue);\n    }\n\n    if (Array.isArray(sourceValue)) {\n      if (typeof targetValue === 'object' && targetValue != null) {\n        const cloned: any = [];\n        const targetKeys = Reflect.ownKeys(targetValue);\n\n        for (let i = 0; i < targetKeys.length; i++) {\n          const targetKey = targetKeys[i];\n          cloned[targetKey] = targetValue[targetKey];\n        }\n\n        targetValue = cloned;\n      } else {\n        targetValue = [];\n      }\n    }\n\n    const merged = merge(targetValue, sourceValue, key, target, source, stack);\n\n    if (merged != null) {\n      target[key] = merged;\n    } else if (Array.isArray(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (targetValue == null && isPlainObject(sourceValue)) {\n      target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n    } else if (targetValue == null && isTypedArray(sourceValue)) {\n      target[key] = cloneDeep(sourceValue);\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","import { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Creates a shallow clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A shallow clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n */\nexport function clone<T>(obj: T): T {\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n\n  if (\n    Array.isArray(obj) ||\n    isTypedArray(obj) ||\n    obj instanceof ArrayBuffer ||\n    (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)\n  ) {\n    return obj.slice(0) as T;\n  }\n\n  const prototype = Object.getPrototypeOf(obj);\n  const Constructor = prototype.constructor;\n\n  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n    return new Constructor(obj);\n  }\n\n  if (obj instanceof RegExp) {\n    const newRegExp = new Constructor(obj);\n    newRegExp.lastIndex = obj.lastIndex;\n\n    return newRegExp;\n  }\n\n  if (obj instanceof DataView) {\n    return new Constructor(obj.buffer.slice(0));\n  }\n\n  if (obj instanceof Error) {\n    const newError = new Constructor(obj.message);\n\n    newError.stack = obj.stack;\n    newError.name = obj.name;\n    newError.cause = obj.cause;\n\n    return newError;\n  }\n\n  if (typeof File !== 'undefined' && obj instanceof File) {\n    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n    return newFile;\n  }\n\n  if (typeof obj === 'object') {\n    const newObject = Object.create(prototype);\n    return Object.assign(newObject, obj);\n  }\n\n  return obj;\n}\n","import { mergeWith } from './mergeWith.ts';\nimport { noop } from '../../function/noop.ts';\n\n/**\n * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.\n *\n * @template T\n * @template U\n * @param {T} object - The destination object.\n * @param {U} source - The source object.\n * @returns {T & U} - Returns `object`.\n *\n * @example\n * const object = { a: [{ b: 2 }, { d: 4 }] };\n * const other = { a: [{ c: 3 }, { e: 5 }] };\n * merge(object, other);\n * // => { a: [{ b: 2, c: 3 }, { d: 4, e: 5 }] }\n */\nexport function merge<T, U>(object: T, source: U): T & U;\n\n/**\n * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.\n *\n * @template T\n * @template U\n * @template V\n * @param {T} object - The destination object.\n * @param {U} source1 - The first source object.\n * @param {V} source2 - The second source object.\n * @returns {T & U & V} - Returns `object`.\n *\n * @example\n * merge({ a: 1 }, { b: 2 }, { c: 3 });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function merge<T, U, V>(object: T, source1: U, source2: V): T & U & V;\n\n/**\n * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.\n *\n * @template T\n * @template U\n * @template V\n * @template W\n * @param {T} object - The destination object.\n * @param {U} source1 - The first source object.\n * @param {V} source2 - The second source object.\n * @param {W} source3 - The third source object.\n * @returns {T & U & V & W} - Returns `object`.\n *\n * @example\n * merge({ a: 1 }, { b: 2 }, { c: 3 }, { d: 4 });\n * // => { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function merge<T, U, V, W>(object: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n/**\n * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.\n *\n * @template T\n * @template U\n * @template V\n * @template W\n * @template X\n * @param {T} object - The destination object.\n * @param {U} source1 - The first source object.\n * @param {V} source2 - The second source object.\n * @param {W} source3 - The third source object.\n * @param {X} source4 - The fourth source object.\n * @returns {T & U & V & W & X} - Returns `object`.\n *\n * @example\n * merge({ a: 1 }, { b: 2 }, { c: 3 }, { d: 4 }, { e: 5 });\n * // => { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function merge<T, U, V, W, X>(object: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\n\n/**\n * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.\n *\n * @param {any} object - The destination object.\n * @param {...any[]} otherArgs - The source objects.\n * @returns {any} - Returns `object`.\n *\n * @example\n * merge({ a: 1 }, { b: 2 }, { c: 3 });\n * // => { a: 1, b: 2, c: 3 }\n */\nexport function merge(object: any, ...otherArgs: any[]): any;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge(object: any, ...sources: any[]): any {\n  return mergeWith(object, ...sources, noop);\n}\n","import { unset } from './unset.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\nimport { Many } from '../_internal/Many.ts';\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * @template T - The type of object.\n * @template K - The type of keys to omit.\n * @param {T | null | undefined} object - The object to omit keys from.\n * @param {...K} paths - The keys to be omitted from the object.\n * @returns {Pick<T, Exclude<keyof T, K[number]>>} A new object with the specified keys omitted.\n *\n * @example\n * omit({ a: 1, b: 2, c: 3 }, 'a', 'c');\n * // => { b: 2 }\n */\nexport function omit<T extends object, K extends PropertyKey[]>(\n  object: T | null | undefined,\n  ...paths: K\n): Pick<T, Exclude<keyof T, K[number]>>;\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * @template T - The type of object.\n * @template K - The type of keys to omit.\n * @param {T | null | undefined} object - The object to omit keys from.\n * @param {...Array<Many<K>>} paths - The keys to be omitted from the object.\n * @returns {Omit<T, K>} A new object with the specified keys omitted.\n *\n * @example\n * omit({ a: 1, b: 2, c: 3 }, 'a', ['b', 'c']);\n * // => {}\n */\nexport function omit<T extends object, K extends keyof T>(\n  object: T | null | undefined,\n  ...paths: Array<Many<K>>\n): Omit<T, K>;\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * @template T - The type of object.\n * @param {T | null | undefined} object - The object to omit keys from.\n * @param {...Array<Many<PropertyKey>>} paths - The keys to be omitted from the object.\n * @returns {Partial<T>} A new object with the specified keys omitted.\n *\n * @example\n * omit({ a: 1, b: 2, c: 3 }, 'a', 'b');\n * // => { c: 3 }\n */\nexport function omit<T extends object>(object: T | null | undefined, ...paths: Array<Many<PropertyKey>>): Partial<T>;\n\n/**\n * Creates a new object with specified keys omitted.\n *\n * This function takes an object and a variable number of keys, and returns a new object that\n * excludes the properties corresponding to the specified keys. Note that keys can be deep.\n *\n * Deep keys can be specified for keys.\n *\n * @template T - The type of object.\n * @param {T | null | undefined} obj - The object to omit keys from.\n * @param {...Array<Many<PropertyKey>> | Array<Many<PropertyKey[]>>} keysArr - A variable number of keys to be omitted from the object.\n * @returns {Partial<T>} A new object with the specified keys omitted.\n *\n * @example\n * omit({ a: 1, b: 2, c: 3 }, 'a', 'b');\n * // => { c: 3 }\n *\n * omit({ a: { b: 1, c: 2 }, d: 3 }, 'a.b', 'd');\n * // => { a: { c: 2 } }\n */\nexport function omit<T extends object>(\n  obj: T | null | undefined,\n  ...keysArr: Array<Many<PropertyKey>> | Array<Many<PropertyKey[]>>\n): Partial<T> {\n  if (obj == null) {\n    return {};\n  }\n\n  const result = cloneDeep(obj);\n\n  for (let i = 0; i < keysArr.length; i++) {\n    let keys = keysArr[i];\n\n    switch (typeof keys) {\n      case 'object': {\n        if (!Array.isArray(keys)) {\n          keys = Array.from(keys as PropertyKey[]);\n        }\n\n        for (let j = 0; j < keys.length; j++) {\n          const key = keys[j];\n\n          unset(result, key);\n        }\n\n        break;\n      }\n      case 'string':\n      case 'symbol':\n      case 'number': {\n        unset(result, keys);\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n","import { getSymbols } from './getSymbols.ts';\n\nexport function getSymbolsIn(object: any) {\n  const result: PropertyKey[] = [];\n  while (object) {\n    result.push(...getSymbols(object));\n    object = Object.getPrototypeOf(object);\n  }\n  return result;\n}\n","import { keysIn } from './keysIn.ts';\nimport { range } from '../../math/range.ts';\nimport { getSymbolsIn } from '../_internal/getSymbolsIn.ts';\nimport { ValueKeyIteratee } from '../_internal/ValueKeyIteratee.ts';\nimport { identity } from '../function/identity.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isSymbol } from '../predicate/isSymbol.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * @template T\n * @param {Record<string, T> | null | undefined} object - The source object.\n * @param {ValueKeyIteratee<T>} predicate - The function invoked per property.\n * @returns {Record<string, T>} Returns the new object.\n *\n * @example\n * omitBy({ 'a': 1, 'b': '2', 'c': 3 }, isString);\n * // => { 'a': 1, 'c': 3 }\n */\nexport function omitBy<T>(\n  object: Record<string, T> | null | undefined,\n  predicate?: ValueKeyIteratee<T>\n): Record<string, T>;\n\n/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * @template T\n * @param {Record<number, T> | null | undefined} object - The source object.\n * @param {ValueKeyIteratee<T>} predicate - The function invoked per property.\n * @returns {Record<number, T>} Returns the new object.\n *\n * @example\n * omitBy({ 0: 1, 1: '2', 2: 3 }, isString);\n * // => { 0: 1, 2: 3 }\n */\nexport function omitBy<T>(\n  object: Record<number, T> | null | undefined,\n  predicate?: ValueKeyIteratee<T>\n): Record<number, T>;\n\n/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * @template T\n * @param {T | null | undefined} object - The source object.\n * @param {ValueKeyIteratee<T[keyof T]>} predicate - The function invoked per property.\n * @returns {Partial<T>} Returns the new object.\n *\n * @example\n * omitBy({ 'a': 1, 'b': '2', 'c': 3 }, isString);\n * // => { 'a': 1, 'c': 3 }\n */\nexport function omitBy<T extends object>(\n  object: T | null | undefined,\n  predicate: ValueKeyIteratee<T[keyof T]>\n): Partial<T>;\n\n/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns false.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to omit properties from.\n * @param {(value: T[keyof T], key: keyof T, obj: T) => boolean} shouldOmit - A predicate function that determines\n * whether a property should be omitted. It takes the property's value, key, and the source object as arguments and returns `true`\n * if the property should be omitted, and `false` otherwise.\n * @returns {Partial<T>} Returns the new object.\n *\n * @example\n * const obj = { a: 1, b: 'omit', c: 3 };\n * const shouldOmit = (value) => typeof value === 'string';\n * const result = omitBy(obj, shouldOmit);\n * // result will be { a: 1, c: 3 }\n */\nexport function omitBy<T, S extends T>(\n  object: Record<string, T> | Record<number, T> | object | null | undefined,\n  shouldOmit?: ValueKeyIteratee<T[keyof T]> | ValueKeyIteratee<T>\n): Record<string, S> | Record<number, S> | Partial<T> {\n  if (object == null) {\n    return {};\n  }\n\n  const result: Partial<T> = {};\n\n  const predicate = createIteratee(shouldOmit ?? identity);\n\n  const keys = isArrayLike(object)\n    ? range(0, object.length)\n    : ([...keysIn(object), ...getSymbolsIn(object)] as Array<keyof T>);\n  for (let i = 0; i < keys.length; i++) {\n    const key = (isSymbol(keys[i]) ? keys[i] : keys[i].toString()) as keyof T;\n    const value = object[key as keyof typeof object];\n\n    if (!predicate(value, key, object)) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n","import { get } from './get.ts';\nimport { has } from './has.ts';\nimport { set } from './set.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isNil } from '../predicate/isNil.ts';\n\n/**\n * Creates a new object composed of the picked object properties.\n *\n * @template T - The type of object.\n * @template U - The type of keys to pick.\n * @param {T} object - The object to pick keys from.\n * @param {...Array<Many<U>>} props - An array of keys to be picked from the object.\n * @returns {Pick<T, U>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n */\nexport function pick<T extends object, U extends keyof T>(object: T, ...props: Array<Many<U>>): Pick<T, U>;\n\n/**\n * Creates a new object composed of the picked object properties.\n *\n * @template T - The type of object.\n * @param {T | null | undefined} object - The object to pick keys from.\n * @param {...Array<Many<PropertyPath>>} props - An array of keys to be picked from the object.\n * @returns {Partial<T>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n */\nexport function pick<T>(object: T | null | undefined, ...props: Array<Many<PropertyPath>>): Partial<T>;\n\n/**\n * Creates a new object composed of the picked object properties.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * includes only the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template U - The type of keys to pick.\n * @param {T | any | null | undefined} object - The object to pick keys from.\n * @param {...Array<Many<U>> | Array<Many<PropertyPath>>} props - An array of keys to be picked from the object. received keys goes through a flattening process before being used.\n * @returns {Pick<T, U> | Partial<T>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n *\n * // each path can be passed individually as an argument\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, 'a', 'c');\n *\n * // pick a key over a path\n * const obj = { 'a.b': 1, a: { b: 2 } };\n * const result = pick(obj, 'a.b');\n * // result will be { 'a.b': 1 }\n */\nexport function pick<T extends object, U extends keyof T>(\n  obj: T | any | null | undefined,\n  ...keysArr: Array<Many<U>> | Array<Many<PropertyPath>>\n): Pick<T, U> | Partial<T> {\n  if (isNil(obj)) {\n    return {};\n  }\n\n  const result: any = {};\n\n  for (let i = 0; i < keysArr.length; i++) {\n    let keys = keysArr[i];\n    switch (typeof keys) {\n      case 'object': {\n        if (!Array.isArray(keys)) {\n          if (isArrayLike(keys)) {\n            // eslint-disable-next-line\n            // @ts-ignore\n            keys = Array.from(keys) as PropertyKey[];\n          } else {\n            keys = [keys];\n          }\n        }\n        break;\n      }\n      case 'string':\n      case 'symbol':\n      case 'number': {\n        keys = [keys];\n        break;\n      }\n    }\n\n    for (const key of keys) {\n      const value = get(obj, key);\n\n      if (value === undefined && !has(obj, key)) {\n        continue;\n      }\n\n      if (typeof key === 'string' && Object.hasOwn(obj, key)) {\n        result[key] = value;\n      } else {\n        set(result, key, value);\n      }\n    }\n  }\n\n  return result;\n}\n","import { keysIn } from './keysIn.ts';\nimport { range } from '../../math/range.ts';\nimport { getSymbolsIn } from '../_internal/getSymbolsIn.ts';\nimport { ValueKeyIteratee } from '../_internal/ValueKeyIteratee.ts';\nimport { ValueKeyIterateeTypeGuard } from '../_internal/ValueKeyIterateeTypeGuard.ts';\nimport { identity } from '../function/identity.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isSymbol } from '../predicate/isSymbol.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * @template T - The type of object values.\n * @template S - The type of filtered values.\n * @param {Record<string, T> | null | undefined} object - The source object.\n * @param {ValueKeyIterateeTypeGuard<T, S>} predicate - The function invoked per property.\n * @returns {Record<string, S>} Returns the new filtered object.\n *\n * @example\n * const users = {\n *   'fred': { 'user': 'fred', 'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n * pickBy(users, ({ age }) => age < 40);\n * // => { 'pebbles': { 'user': 'pebbles', 'age': 1 } }\n */\nexport function pickBy<T, S extends T>(\n  object: Record<string, T> | null | undefined,\n  predicate: ValueKeyIterateeTypeGuard<T, S>\n): Record<string, S>;\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * @template T - The type of object values.\n * @template S - The type of filtered values.\n * @param {Record<number, T> | null | undefined} object - The source object.\n * @param {ValueKeyIterateeTypeGuard<T, S>} predicate - The function invoked per property.\n * @returns {Record<number, S>} Returns the new filtered object.\n *\n * @example\n * const array = [1, 2, 3, 4];\n * pickBy(array, (value) => value % 2 === 0);\n * // => { 1: 2, 3: 4 }\n */\nexport function pickBy<T, S extends T>(\n  object: Record<number, T> | null | undefined,\n  predicate: ValueKeyIterateeTypeGuard<T, S>\n): Record<number, S>;\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * @template T - The type of object values.\n * @param {Record<string, T> | null | undefined} object - The source object.\n * @param {ValueKeyIteratee<T>} [predicate] - The function invoked per property.\n * @returns {Record<string, T>} Returns the new filtered object.\n *\n * @example\n * const object = { 'a': 1, 'b': '2', 'c': 3 };\n * pickBy(object, (value) => typeof value === 'string');\n * // => { 'b': '2' }\n */\nexport function pickBy<T>(\n  object: Record<string, T> | null | undefined,\n  predicate?: ValueKeyIteratee<T>\n): Record<string, T>;\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * @template T - The type of object values.\n * @param {Record<number, T> | null | undefined} object - The source object.\n * @param {ValueKeyIteratee<T>} [predicate] - The function invoked per property.\n * @returns {Record<number, T>} Returns the new filtered object.\n *\n * @example\n * const array = [1, 2, 3, 4];\n * pickBy(array, (value) => value > 2);\n * // => { 2: 3, 3: 4 }\n */\nexport function pickBy<T>(\n  object: Record<number, T> | null | undefined,\n  predicate?: ValueKeyIteratee<T>\n): Record<number, T>;\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * @template T - The type of object.\n * @param {T | null | undefined} object - The source object.\n * @param {ValueKeyIteratee<T[keyof T]>} [predicate] - The function invoked per property.\n * @returns {Partial<T>} Returns the new filtered object.\n *\n * @example\n * const object = { 'a': 1, 'b': '2', 'c': 3 };\n * pickBy(object, (value) => typeof value === 'string');\n * // => { 'b': '2' }\n */\nexport function pickBy<T extends object>(\n  object: T | null | undefined,\n  predicate?: ValueKeyIteratee<T[keyof T]>\n): Partial<T>;\n\n/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns true.\n *\n * @template T - The type of object.\n * @param {Record<string, T> | Record<number, T> | object | null | undefined} obj - The object to pick properties from.\n * @param {ValueKeyIterateeTypeGuard<T, S> | ValueKeyIteratee<T[keyof T]> | ValueKeyIteratee<T>} [shouldPick] - A predicate function that determines\n * whether a property should be picked. It takes the property's key and value as arguments and returns `true`\n * if the property should be picked, and `false` otherwise.\n * @returns {Record<string, S> | Record<number, S> | Partial<T>} A new object with the properties that satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'pick', c: 3 };\n * const shouldPick = (value) => typeof value === 'string';\n * const result = pickBy(obj, shouldPick);\n * // result will be { b: 'pick' }\n */\nexport function pickBy<T, S extends T>(\n  obj: Record<string, T> | Record<number, T> | object | null | undefined,\n  shouldPick?: ValueKeyIterateeTypeGuard<T, S> | ValueKeyIteratee<T[keyof T]> | ValueKeyIteratee<T>\n): Record<string, S> | Record<number, S> | Partial<T> {\n  if (obj == null) {\n    return {};\n  }\n\n  const predicate = createIteratee(shouldPick ?? identity);\n\n  const result: Partial<T> = {};\n\n  const keys = isArrayLike(obj) ? range(0, obj.length) : ([...keysIn(obj), ...getSymbolsIn(obj)] as Array<keyof T>);\n  for (let i = 0; i < keys.length; i++) {\n    const key = (isSymbol(keys[i]) ? keys[i] : keys[i].toString()) as keyof T;\n    const value = obj[key as keyof typeof obj];\n\n    if (predicate(value, key, obj)) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n","import { get } from './get.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport function propertyOf<T extends {}>(object: T): (path: PropertyPath) => any;\n\n/**\n * Creates a function that returns the value at a given path of an object.\n *\n * Unlike `property`, which creates a function bound to a specific path and allows you to query different objects,\n * `propertyOf` creates a function bound to a specific object and allows you to query different paths within that object.\n *\n * @template T - The type of object.\n * @param {T} object - The object to query.\n * @returns {(path: PropertyPath) => any} - Returns a new function that takes a path and retrieves the value from the object at the specified path.\n *\n * @example\n * const getValue = propertyOf({ a: { b: { c: 3 } } });\n * const result = getValue('a.b.c');\n * console.log(result); // => 3\n *\n * @example\n * const getValue = propertyOf({ a: { b: { c: 3 } } });\n * const result = getValue(['a', 'b', 'c']);\n * console.log(result); // => 3\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport function propertyOf<T extends {}>(object: T): (path: PropertyPath) => any {\n  return function (path: PropertyPath) {\n    return get(object, path);\n  };\n}\n","import { isKey } from '../_internal/isKey.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Retrieves the value at a given path of an object.\n * If the resolved value is a function, it is invoked with the object as its `this` context.\n * If the value is `undefined`, the `defaultValue` is returned.\n *\n * @template T - The type of object.\n * @template R - The type of the value to return.\n * @param {T} object - The object to query.\n * @param {PropertyPath} path - The path of the property to get.\n * @param {R | ((...args: any[]) => R)} [defaultValue] - The value returned if the resolved value is `undefined`.\n * @returns {R} - Returns the resolved value.\n *\n * @example\n * const obj = { a: { b: { c: 3 } } };\n * result(obj, 'a.b.c');\n * // => 3\n *\n * @example\n * const obj = { a: () => 5 };\n * result(obj, 'a');\n * // => 5 (calls the function `a` and returns its result)\n *\n * @example\n * const obj = { a: { b: null } };\n * result(obj, 'a.b.c', 'default');\n * // => 'default'\n *\n * @example\n * const obj = { a: { b: { c: 3 } } };\n * result(obj, 'a.b.d', () => 'default');\n * // => 'default'\n */\nexport function result<R>(object: any, path: PropertyPath, defaultValue?: R | ((...args: any[]) => R)): R {\n  if (isKey(path, object)) {\n    path = [path];\n  } else if (!Array.isArray(path)) {\n    path = toPath(toString(path));\n  }\n\n  const pathLength = Math.max(path.length, 1);\n\n  for (let index = 0; index < pathLength; index++) {\n    const value = object == null ? undefined : object[toKey(path[index])];\n\n    if (value === undefined) {\n      return typeof defaultValue === 'function' ? (defaultValue as any).call(object) : (defaultValue as R);\n    }\n\n    object = typeof value === 'function' ? value.call(object) : value;\n  }\n\n  return object;\n}\n","import { updateWith } from './updateWith.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\n\n/**\n * Sets the value at the specified path of the given object using a customizer function.\n * If any part of the path does not exist, it will be created based on the customizer's result.\n *\n * The customizer is invoked to produce the objects of the path. If the customizer returns\n * a value, that value is used for the current path segment. If the customizer returns\n * `undefined`, the method will create an appropriate object based on the path - an array\n * if the next path segment is a valid array index, or an object otherwise.\n *\n * @template T - The type of the object.\n * @param {T} object - The object to modify.\n * @param {PropertyPath} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @param {(nsValue: any, key: string, nsObject: T) => any} [customizer] - The function to customize assigned values.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value with a customizer that creates arrays for numeric path segments\n * const object = {};\n * setWith(object, '[0][1]', 'a', (value) => Array.isArray(value) ? value : []);\n * // => { '0': ['a'] }\n */\nexport function setWith<T extends object>(\n  object: T,\n  path: PropertyPath,\n  value: any,\n  customizer?: (nsValue: any, key: string, nsObject: T) => any\n): T;\n\n/**\n * Sets the value at the specified path of the given object using a customizer function.\n * If any part of the path does not exist, it will be created based on the customizer's result.\n *\n * The customizer is invoked to produce the objects of the path. If the customizer returns\n * a value, that value is used for the current path segment. If the customizer returns\n * `undefined`, the method will create an appropriate object based on the path - an array\n * if the next path segment is a valid array index, or an object otherwise.\n *\n * @template T - The type of the object.\n * @template R - The type of the return value.\n * @param {T} object - The object to modify.\n * @param {PropertyPath} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @param {(nsValue: any, key: string, nsObject: T) => any} [customizer] - The function to customize assigned values.\n * @returns {R} - The modified object.\n *\n * @example\n * // Set a value with a customizer that creates arrays for numeric path segments\n * const object = {};\n * setWith(object, '[0][1]', 'a', (value) => Array.isArray(value) ? value : []);\n * // => { '0': ['a'] }\n */\nexport function setWith<T extends object, R>(\n  object: T,\n  path: PropertyPath,\n  value: any,\n  customizer?: (nsValue: any, key: string, nsObject: T) => any\n): R;\n\n/**\n * Sets the value at the specified path of the given object using a customizer function.\n * If any part of the path does not exist, it will be created based on the customizer's result.\n *\n * The customizer is invoked to produce the objects of the path. If the customizer returns\n * a value, that value is used for the current path segment. If the customizer returns\n * `undefined`, the method will create an appropriate object based on the path - an array\n * if the next path segment is a valid array index, or an object otherwise.\n *\n * @template T - The type of the object.\n * @template R - The type of the return value.\n * @param {T} obj - The object to modify.\n * @param {PropertyPath} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @param {(value: any, key: string, object: T) => any} [customizer] - The function to customize assigned values.\n * @returns {T | R} - The modified object.\n *\n * @example\n * // Set a value with a customizer that creates arrays for numeric path segments\n * const object = {};\n * setWith(object, '[0][1]', 'a', (value) => Array.isArray(value) ? value : []);\n * // => { '0': ['a'] }\n */\nexport function setWith<T extends object, R>(\n  obj: T,\n  path: PropertyPath,\n  value: any,\n  customizer?: (value: any, key: string, object: T) => any\n): T | R {\n  let customizerFn: (value: any, key: string, object: T) => any;\n\n  if (typeof customizer === 'function') {\n    customizerFn = customizer;\n  } else {\n    customizerFn = () => undefined;\n  }\n\n  return updateWith(obj, path, () => value, customizerFn);\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { defaults } from './defaults.ts';\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @param {T} object - The target object.\n * @returns {T} The cloned object.\n */\nexport function toDefaulted<T extends object>(object: T): T;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S} source - The object that specifies the default values to apply.\n * @returns {NonNullable<T & S>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<T extends object, S extends object>(object: T, source: S): NonNullable<T & S>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<T extends object, S1 extends object, S2 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2\n): NonNullable<T & S1 & S2>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<T extends object, S1 extends object, S2 extends object, S3 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3\n): NonNullable<T & S1 & S2 & S3>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @template S4 - The type of the fourth object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @param {S4} source4 - The fourth object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3 & S4>} A new object that combines the target and default values, ensuring no properties are left undefined.\n */\nexport function toDefaulted<\n  T extends object,\n  S1 extends object,\n  S2 extends object,\n  S3 extends object,\n  S4 extends object,\n>(object: T, source1: S1, source2: S2, source3: S3, source4: S4): NonNullable<T & S1 & S2 & S3 & S4>;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} sources - The objects that specifies the default values to apply.\n * @returns {object} A new object that combines the target and default values, ensuring no properties are left undefined.\n *\n * @example\n * toDefaulted({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: null }, { a: 1 }); // { a: null }\n * toDefaulted({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function toDefaulted<T extends object, S extends object>(object: T, ...sources: S[]): object;\n\n/**\n * Creates a new object based on the provided `object`, applying default values from the `sources` to ensure that no properties are left `undefined`.\n * It assigns default values to properties that are either `undefined` or come from `Object.prototype`.\n *\n * You can provide multiple source objects to set these default values,\n * and they will be applied in the order they are given, from left to right.\n * Once a property has been set, any later values for that property will be ignored.\n *\n * Note: This function creates a new object. If you want to modify the `object`, use the `defaults` function instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} sources - The objects that specifies the default values to apply.\n * @returns {object} A new object that combines the target and default values, ensuring no properties are left undefined.\n *\n * @example\n * toDefaulted({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * toDefaulted({ a: null }, { a: 1 }); // { a: null }\n * toDefaulted({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function toDefaulted<T extends object, S extends object>(object: T, ...sources: S[]): object {\n  const cloned = cloneDeep(object);\n\n  return defaults(cloned, ...sources);\n}\n","export function mapToEntries(map: Map<any, any>) {\n  const arr = new Array(map.size);\n  const keys = map.keys();\n  const values = map.values();\n\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = [keys.next().value, values.next().value];\n  }\n  return arr;\n}\n","export function setToEntries(set: Set<any>) {\n  const arr = new Array(set.size);\n  const values = set.values();\n\n  for (let i = 0; i < arr.length; i++) {\n    const value = values.next().value;\n    arr[i] = [value, value];\n  }\n  return arr;\n}\n","import { keys as keysToolkit } from './keys.ts';\nimport { mapToEntries } from '../_internal/mapToEntries.ts';\nimport { setToEntries } from '../_internal/setToEntries.ts';\n\n/**\n * Creates an array of key-value pairs from an object.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T>} object - The object to query.\n * @returns {Array<[string, T]>} Returns the array of key-value pairs.\n *\n * @example\n * const object = { a: 1, b: 2 };\n * toPairs(object); // [['a', 1], ['b', 2]]\n */\nexport function toPairs<T>(object?: Record<string, T> | Record<number, T>): Array<[string, T]>;\n\n/**\n * Creates an array of key-value pairs from an object.\n *\n * @param {object} object - The object to query.\n * @returns {Array<[string, any]>} Returns the array of key-value pairs.\n *\n * @example\n * const object = { a: 1, b: 2 };\n * toPairs(object); // [['a', 1], ['b', 2]]\n */\nexport function toPairs(object?: object): Array<[string, any]>;\n\n/**\n * Creates an array of key-value pairs from an object, set, or map.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T> | object} object - The object, set, or map to query.\n * @returns {Array<[string, T]> | Array<[string, any]>} Returns the array of key-value pairs.\n *\n * @example\n * const object = { a: 1, b: 2 };\n * toPairs(object); // [['a', 1], ['b', 2]]\n *\n * const set = new Set([1, 2]);\n * toPairs(set); // [[1, 1], [2, 2]]\n *\n * const map = new Map();\n * map.set('a', 1);\n * map.set('b', 2);\n * toPairs(map); // [['a', 1], ['b', 2]]\n */\nexport function toPairs<T>(\n  object?: Record<string, T> | Record<number, T> | object\n): Array<[string, T]> | Array<[string, any]> {\n  if (object == null) {\n    return [];\n  }\n\n  if (object instanceof Set) {\n    return setToEntries(object);\n  }\n\n  if (object instanceof Map) {\n    return mapToEntries(object);\n  }\n\n  const keys = keysToolkit(object);\n  const result: Array<[key: string, value: any]> = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = object[key as keyof typeof object];\n\n    result[i] = [key, value];\n  }\n\n  return result;\n}\n","import { keysIn as keysInToolkit } from './keysIn.ts';\nimport { mapToEntries } from '../_internal/mapToEntries.ts';\nimport { setToEntries } from '../_internal/setToEntries.ts';\n\n/**\n * Creates an array of key-value pairs from an object, including inherited properties.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T>} object - The object to query.\n * @returns {Array<[string, T]>} Returns the array of key-value pairs.\n *\n * @example\n * const object = { a: 1, b: 2 };\n * toPairsIn(object); // [['a', 1], ['b', 2]]\n */\nexport function toPairsIn<T>(object?: Record<string, T> | Record<number, T>): Array<[string, T]>;\n\n/**\n * Creates an array of key-value pairs from an object, including inherited properties.\n *\n * @param {object} object - The object to query.\n * @returns {Array<[string, any]>} Returns the array of key-value pairs.\n *\n * @example\n * const object = { a: 1, b: 2 };\n * toPairsIn(object); // [['a', 1], ['b', 2]]\n */\nexport function toPairsIn(object?: object): Array<[string, any]>;\n\n/**\n * Creates an array of key-value pairs from an object, set, or map, including inherited properties.\n *\n * @param {Record<string, T> | Record<number, T> | object} object The object, set, or map to query.\n * @returns {Array<[string, T]> | Array<[string, any]>} Returns the array of key-value pairs.\n * @example\n * const object = { a: 1, b: 2 };\n * toPairsIn(object); // [['a', 1], ['b', 2]]\n *\n * const set = new Set([1, 2]);\n * toPairsIn(set); // [[1, 1], [2, 2]]\n *\n * const map = new Map();\n * map.set('a', 1);\n * map.set('b', 2);\n * toPairsIn(map); // [['a', 1], ['b', 2]]\n */\nexport function toPairsIn<T>(\n  object?: Record<string, T> | Record<number, T> | object\n): Array<[string, T]> | Array<[string, any]> {\n  if (object == null) {\n    return [];\n  }\n\n  if (object instanceof Set) {\n    return setToEntries(object);\n  }\n\n  if (object instanceof Map) {\n    return mapToEntries(object);\n  }\n\n  const keys = keysInToolkit(object);\n  const result: Array<[key: string, value: any]> = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = object[key as keyof typeof object];\n\n    result[i] = [key, value];\n  }\n\n  return result;\n}\n","import { isBuffer as isBufferToolkit } from '../../predicate/isBuffer.ts';\n\n/**\n * Checks if the given value is a Buffer instance.\n *\n * This function tests whether the provided value is an instance of Buffer.\n * It returns `true` if the value is a Buffer, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Buffer`.\n *\n * @param {any} x - The value to check if it is a Buffer.\n * @returns {boolean} Returns `true` if `x` is a Buffer, else `false`.\n *\n * @example\n * const buffer = Buffer.from(\"test\");\n * console.log(isBuffer(buffer)); // true\n *\n * const notBuffer = \"not a buffer\";\n * console.log(isBuffer(notBuffer)); // false\n */\nexport function isBuffer(x?: any): boolean {\n  return isBufferToolkit(x);\n}\n","import { identity } from '../../function/identity.ts';\nimport { isFunction } from '../../predicate/isFunction.ts';\nimport { forEach } from '../array/forEach.ts';\nimport { isBuffer } from '../predicate/isBuffer.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { iteratee as createIteratee } from '../util/iteratee.ts';\n\n/**\n * Traverses object values and creates a new object by accumulating them in the desired form.\n *\n * @template T - The type of object.\n * @template R - The type of accumulator.\n * @param {readonly T[]} object - The array to iterate over.\n * @param {(acc: R, curr: T, index: number, arr: T[]) => void} iteratee - The function invoked per iteration.\n * @param {R} [accumulator] - The initial value.\n * @returns {R} Returns the accumulated value.\n *\n * @example\n * const array = [2, 3, 4];\n * transform(array, (acc, value) => { acc.push(value * 2); }, []);\n * // => [4, 6, 8]\n */\nexport function transform<T, R>(\n  object: readonly T[],\n  iteratee: (acc: R, curr: T, index: number, arr: T[]) => void,\n  accumulator?: R\n): R;\n\n/**\n * Traverses object values and creates a new object by accumulating them in the desired form.\n *\n * @template T - The type of object.\n * @template R - The type of accumulator.\n * @param {Record<string, T>} object - The object to iterate over.\n * @param {(acc: R, curr: T, key: string, dict: Record<string, T>) => void} iteratee - The function invoked per iteration.\n * @param {R} [accumulator] - The initial value.\n * @returns {R} Returns the accumulated value.\n *\n * @example\n * const obj = { 'a': 1, 'b': 2, 'c': 1 };\n * transform(obj, (result, value, key) => { (result[value] || (result[value] = [])).push(key) }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] }\n */\nexport function transform<T, R>(\n  object: Record<string, T>,\n  iteratee: (acc: R, curr: T, key: string, dict: Record<string, T>) => void,\n  accumulator?: R\n): R;\n\n/**\n * Traverses object values and creates a new object by accumulating them in the desired form.\n *\n * @template T - The type of object.\n * @template R - The type of accumulator.\n * @param {T} object - The object to iterate over.\n * @param {(acc: R, curr: T[keyof T], key: keyof T, dict: Record<keyof T, T[keyof T]>) => void} iteratee - The function invoked per iteration.\n * @param {R} [accumulator] - The initial value.\n * @returns {R} Returns the accumulated value.\n *\n * @example\n * const obj = { x: 1, y: 2, z: 3 };\n * transform(obj, (acc, value, key) => { acc[key] = value * 2; }, {});\n * // => { x: 2, y: 4, z: 6 }\n */\nexport function transform<T extends object, R>(\n  object: T,\n  iteratee: (acc: R, curr: T[keyof T], key: keyof T, dict: Record<keyof T, T[keyof T]>) => void,\n  accumulator?: R\n): R;\n\n/**\n * Traverses object values and creates a new object by accumulating them in the desired form.\n *\n * @param {any[]} object - The array to iterate over.\n * @returns {any[]} Returns the accumulated value.\n *\n * @example\n * const array = [1, 2, 3];\n * transform(array);\n * // => [1, 2, 3]\n */\nexport function transform(object: any[]): any[];\n\n/**\n * Traverses object values and creates a new object by accumulating them in the desired form.\n *\n * @param {object} object - The object to iterate over.\n * @returns {Record<string, any>} Returns the accumulated value.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * transform(obj);\n * // => { a: 1, b: 2 }\n */\nexport function transform(object: object): Record<string, any>;\n\n/**\n * Traverses object values and creates a new object by accumulating them in the desired form.\n *\n * If no initial value is provided for `accumulator`, it creates a new array or object with the same prototype.\n *\nThe traversal is interrupted when the `iteratee` function returns `false`.\n *\n * @template T - The type of object.\n * @template U - The type of accumulator.\n * @param {readonly T[] | T} object - The object to iterate over.\n * @param {(accumulator: U, value: T | T[keyof T], key: any, object: T[] | T) => unknown} [iteratee] - The function invoked per iteration.\n * @param {U} [accumulator] - The initial value.\n * @returns {U} Returns the accumulated value.\n *\n * @example\n * // Transform an array\n * const array = [2, 3, 4];\n * transform(array, (acc, value) => { acc += value; return value % 2 === 0; }, 0) // => 5\n *\n * @example\n * // Transform an object\n * const obj = { 'a': 1, 'b': 2, 'c': 1 };\n * transform(obj, (result, value, key) => { (result[value] || (result[value] = [])).push(key) }, {}) // => { '1': ['a', 'c'], '2': ['b'] }\n */\nexport function transform<T, U>(\n  object?: readonly T[] | T,\n  iteratee: (accumulator: U, value: T | T[keyof T], key: any, object: readonly T[] | T) => unknown = identity,\n  accumulator?: U\n): U | any[] | Record<string, any> {\n  const isArrayOrBufferOrTypedArray = Array.isArray(object) || isBuffer(object) || isTypedArray(object);\n\n  iteratee = createIteratee(iteratee);\n\n  if (accumulator == null) {\n    if (isArrayOrBufferOrTypedArray) {\n      accumulator = [] as U;\n    } else if (isObject(object) && isFunction(object.constructor)) {\n      accumulator = Object.create(Object.getPrototypeOf(object));\n    } else {\n      accumulator = {} as U;\n    }\n  }\n\n  if (object == null) {\n    return accumulator as U;\n  }\n\n  forEach(object, (value, key, object) => iteratee(accumulator as U, value as T, key, object));\n\n  return accumulator as U;\n}\n","import { updateWith } from './updateWith.ts';\nimport { PropertyPath } from '../_internal/PropertyPath.ts';\n\n/**\n * Updates the value at the specified path of the given object using an updater function.\n * If any part of the path does not exist, it will be created.\n *\n * @param {object} obj - The object to modify.\n * @param {PropertyPath} path - The path of the property to update.\n * @param {(value: any) => any} updater - The function to produce the updated value.\n * @returns {any} - The modified object.\n */\nexport function update(obj: object, path: PropertyPath, updater: (value: any) => any): any {\n  return updateWith(obj, path, updater, () => undefined);\n}\n","import { keysIn } from './keysIn.ts';\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * @template T\n * @param {Record<string, T> | Record<number, T> | ArrayLike<T> | null | undefined} object - The object to query.\n * @returns {T[]} Returns an array of property values.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * valuesIn(obj); // => [1, 2, 3]\n */\nexport function valuesIn<T>(object: Record<string, T> | Record<number, T> | ArrayLike<T> | null | undefined): T[];\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * @template T\n * @param {T | null | undefined} object - The object to query.\n * @returns {Array<T[keyof T]>} Returns an array of property values.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * valuesIn(obj); // => [1, 2, 3]\n */\nexport function valuesIn<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n\n/**\n * Retrieves the values from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {any} object The object to query.\n * @returns {any[]} Returns an array of property values.\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * valuesIn(obj); // => [1, 2, 3]\n */\nexport function valuesIn(object: any): any[] {\n  const keys = keysIn(object);\n  const result: any[] = new Array(keys.length);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    result[i] = object[key];\n  }\n\n  return result;\n}\n","/**\n * Checks if `value` is a function.\n *\n * @param {any} value The value to check.\n * @returns {value is (...args: any[]) => any} Returns `true` if `value` is a function, else `false`.\n *\n * @example\n * isFunction(Array.prototype.slice); // true\n * isFunction(async function () {}); // true\n * isFunction(function* () {}); // true\n * isFunction(Proxy); // true\n * isFunction(Int8Array); // true\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Checks if a given value is a valid length.\n *\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\n * It returns `true` if the value is a valid length, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\n * argument to a valid length (`number`).\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n *\n * @example\n * isLength(0); // true\n * isLength(42); // true\n * isLength(-1); // false\n * isLength(1.5); // false\n * isLength(Number.MAX_SAFE_INTEGER); // true\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\n */\nexport function isLength(value?: any): boolean {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n","const functionToString = Function.prototype.toString;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nconst REGEXP_SYNTAX_CHARS = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect if a method is native. */\nconst IS_NATIVE_FUNCTION_REGEXP = RegExp(\n  `^${functionToString\n    .call(Object.prototype.hasOwnProperty)\n    .replace(REGEXP_SYNTAX_CHARS, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?')}$`\n);\n\n/**\n * Checks if a given value is a native function.\n *\n * This function tests whether the provided value is a native function implemented by the JavaScript engine.\n * It returns `true` if the value is a native function, and `false` otherwise.\n *\n * @param {any} value - The value to test for native function.\n * @returns {value is (...args: any[]) => any} `true` if the value is a native function, `false` otherwise.\n *\n * @example\n * const value1 = Array.prototype.push;\n * const value2 = () => {};\n * const result1 = isNative(value1); // true\n * const result2 = isNative(value2); // false\n */\nexport function isNative(value: any): value is (...args: any[]) => any {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  if ((globalThis as any)?.['__core-js_shared__'] != null) {\n    throw new Error('Unsupported core-js use. Try https://npms.io/search?q=ponyfill.');\n  }\n\n  return IS_NATIVE_FUNCTION_REGEXP.test(functionToString.call(value));\n}\n","/**\n * Checks if `value` is `null`.\n *\n * @param {any} value - The value to check.\n * @returns {value is null} Returns `true` if `value` is `null`, else `false`.\n *\n * @example\n * isNull(null); // true\n * isNull(undefined); // false\n * isNull(0); // false\n */\nexport function isNull(value: any): value is null {\n  return value === null;\n}\n","import { isUndefined as isUndefinedToolkit } from '../../predicate/isUndefined.ts';\n\n/**\n * Checks if the given value is undefined.\n *\n * This function tests whether the provided value is strictly equal to `undefined`.\n * It returns `true` if the value is `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\n *\n * @param {any} x - The value to test if it is undefined.\n * @returns {x is undefined} true if the value is undefined, false otherwise.\n *\n * @example\n * const value1 = undefined;\n * const value2 = null;\n * const value3 = 42;\n *\n * console.log(isUndefined(value1)); // true\n * console.log(isUndefined(value2)); // false\n * console.log(isUndefined(value3)); // false\n */\nexport function isUndefined(x: any): x is undefined {\n  return isUndefinedToolkit(x);\n}\n","import { ConformsPredicateObject } from '../_internal/ConformsPredicateObject.ts';\n\n/**\n * Checks if `object` conforms to `source` by invoking the predicate properties of `source` with the corresponding property values of `object`.\n *\n * Note: This method is equivalent to `conforms` when source is partially applied.\n *\n * @template T - The type of the target object.\n * @param {T} target The object to inspect.\n * @param {ConformsPredicateObject<T>} source The object of property predicates to conform to.\n * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n *\n * @example\n *\n * const object = { 'a': 1, 'b': 2 };\n * const source = {\n *   'a': (n) => n > 0,\n *   'b': (n) => n > 1\n * };\n *\n * console.log(conformsTo(object, source)); // => true\n *\n * const source2 = {\n *   'a': (n) => n > 1,\n *   'b': (n) => n > 1\n * };\n *\n * console.log(conformsTo(object, source2)); // => false\n */\nexport function conformsTo<T>(target: T, source: ConformsPredicateObject<T>): boolean {\n  if (source == null) {\n    return true;\n  }\n\n  if (target == null) {\n    return Object.keys(source).length === 0;\n  }\n\n  const keys = Object.keys(source) as Array<keyof T>;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const predicate = source[key];\n    const value = target[key];\n\n    if (value === undefined && !(key in (target as any))) {\n      return false;\n    }\n\n    if (typeof predicate === 'function' && !predicate(value)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { conformsTo } from './conformsTo.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\nimport { ConformsPredicateObject } from '../_internal/ConformsPredicateObject.ts';\n\n/**\n * Creates a function that invokes the predicate properties of `source` with the corresponding property values of a given object, returning `true` if all predicates return truthy, else `false`.\n *\n * Note: The created function is equivalent to `conformsTo` with source partially applied.\n *\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\n * @returns {(object: Record<PropertyKey, any>) => boolean} Returns the new spec function.\n *\n * @example\n * const isPositive = (n) => n > 0;\n * const isEven = (n) => n % 2 === 0;\n * const predicates = { a: isPositive, b: isEven };\n * const conform = conforms(predicates);\n *\n * console.log(conform({ a: 2, b: 4 })); // true\n * console.log(conform({ a: -1, b: 4 })); // false\n * console.log(conform({ a: 2, b: 3 })); // false\n * console.log(conform({ a: 0, b: 2 })); // false\n */\nexport function conforms<T>(source: ConformsPredicateObject<T>): (value: T) => boolean {\n  source = cloneDeep(source);\n\n  return function (object: T) {\n    return conformsTo(object, source);\n  };\n}\n","import { isArrayBuffer as isArrayBufferToolkit } from '../../predicate/isArrayBuffer.ts';\n\n/**\n * Checks if a given value is `ArrayBuffer`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `ArrayBuffer`.\n *\n * @param {any} value The value to check if it is a `ArrayBuffer`.\n * @returns {value is ArrayBuffer} Returns `true` if `value` is a `ArrayBuffer`, else `false`.\n *\n * @example\n * const value1 = new ArrayBuffer();\n * const value2 = new Array();\n * const value3 = new Map();\n *\n * console.log(isArrayBuffer(value1)); // true\n * console.log(isArrayBuffer(value2)); // false\n * console.log(isArrayBuffer(value3)); // false\n */\n\nexport function isArrayBuffer(value?: any): value is ArrayBuffer {\n  return isArrayBufferToolkit(value);\n}\n","/**\n * Checks if a given value is `ArrayBuffer`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `ArrayBuffer`.\n *\n * @param {unknown} value The value to check if it is a `ArrayBuffer`.\n * @returns {value is ArrayBuffer} Returns `true` if `value` is a `ArrayBuffer`, else `false`.\n *\n * @example\n * const value1 = new ArrayBuffer();\n * const value2 = new Array();\n * const value3 = new Map();\n *\n * console.log(isArrayBuffer(value1)); // true\n * console.log(isArrayBuffer(value2)); // false\n * console.log(isArrayBuffer(value3)); // false\n */\n\nexport function isArrayBuffer(value: unknown): value is ArrayBuffer {\n  return value instanceof ArrayBuffer;\n}\n","/**\n * Checks if the given value is boolean.\n *\n * This function tests whether the provided value is strictly `boolean`.\n * It returns `true` if the value is `boolean`, and `false` otherwise.\n *\n *  This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `boolean`.\n *\n * @param {any} value - The Value to test if it is boolean.\n * @returns {value is boolean} True if the value is boolean, false otherwise.\n *\n * @example\n *\n * const value1 = true;\n * const value2 = 0;\n * const value3 = 'abc';\n *\n * console.log(isBoolean(value1)); // true\n * console.log(isBoolean(value2)); // false\n * console.log(isBoolean(value3)); // false\n *\n */\nexport function isBoolean(value?: any): value is boolean {\n  return typeof value === 'boolean' || value instanceof Boolean;\n}\n","import { isDate as isDateToolkit } from '../../predicate/isDate.ts';\n\n/**\n * Checks if `value` is a Date object.\n *\n * @param {any} value The value to check.\n * @returns {value is Date} Returns `true` if `value` is a Date object, `false` otherwise.\n *\n * @example\n * const value1 = new Date();\n * const value2 = '2024-01-01';\n *\n * console.log(isDate(value1)); // true\n * console.log(isDate(value2)); // false\n */\nexport function isDate(value?: any): value is Date {\n  return isDateToolkit(value);\n}\n","/**\n * Checks if `value` is a Date object.\n *\n * @param {unknown} value The value to check.\n * @returns {value is Date} Returns `true` if `value` is a Date object, `false` otherwise.\n *\n * @example\n * const value1 = new Date();\n * const value2 = '2024-01-01';\n *\n * console.log(isDate(value1)); // true\n * console.log(isDate(value2)); // false\n */\nexport function isDate(value: unknown): value is Date {\n  return value instanceof Date;\n}\n","import { isObjectLike } from './isObjectLike.ts';\nimport { isPlainObject } from './isPlainObject.ts';\n\n/**\n * Checks if `value` is likely a DOM element.\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n *\n * @example\n * console.log(isElement(document.body)); // true\n * console.log(isElement('<body>')); // false\n */\nexport function isElement(value?: any): boolean {\n  return isObjectLike(value) && (value as any).nodeType === 1 && !isPlainObject(value);\n}\n","import { isArguments } from './isArguments.ts';\nimport { isArrayLike } from './isArrayLike.ts';\nimport { isTypedArray } from './isTypedArray.ts';\nimport type { EmptyObjectOf } from '../_internal/EmptyObjectOf.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\nexport function isEmpty<T extends { __trapAny: any }>(value?: T): boolean;\nexport function isEmpty(value: string): value is '';\nexport function isEmpty(value: Map<any, any> | Set<any> | ArrayLike<any> | null | undefined): boolean;\nexport function isEmpty(value: object): boolean;\nexport function isEmpty<T extends object>(value: T | null | undefined): value is EmptyObjectOf<T> | null | undefined;\nexport function isEmpty(value?: any): boolean;\n\n/**\n * Checks if a given value is empty.\n *\n * - If the given value is a string, checks if it is an empty string.\n * - If the given value is an array, `Map`, or `Set`, checks if its size is 0.\n * - If the given value is an [array-like object](../predicate/isArrayLike.md), checks if its length is 0.\n * - If the given value is an object, checks if it is an empty object with no properties.\n * - Primitive values (strings, booleans, numbers, or bigints) are considered empty.\n *\n * @param {unknown} [value] - The value to check.\n * @returns {boolean} `true` if the value is empty, `false` otherwise.\n *\n * @example\n * isEmpty(); // true\n * isEmpty(null); // true\n * isEmpty(\"\"); // true\n * isEmpty([]); // true\n * isEmpty({}); // true\n * isEmpty(new Map()); // true\n * isEmpty(new Set()); // true\n * isEmpty(\"hello\"); // false\n * isEmpty([1, 2, 3]); // false\n * isEmpty({ a: 1 }); // false\n * isEmpty(new Map([[\"key\", \"value\"]])); // false\n * isEmpty(new Set([1, 2, 3])); // false\n */\nexport function isEmpty(value?: unknown): boolean {\n  if (value == null) {\n    return true;\n  }\n\n  // Objects like { \"length\": 0 } are not empty in lodash\n  if (isArrayLike(value)) {\n    if (\n      typeof (value as any).splice !== 'function' &&\n      typeof value !== 'string' &&\n      (typeof Buffer === 'undefined' || !Buffer.isBuffer(value)) &&\n      !isTypedArray(value) &&\n      !isArguments(value)\n    ) {\n      return false;\n    }\n\n    return value.length === 0;\n  }\n\n  if (typeof value === 'object') {\n    if (value instanceof Map || value instanceof Set) {\n      return value.size === 0;\n    }\n\n    const keys = Object.keys(value);\n\n    if (isPrototype(value)) {\n      return keys.filter(x => x !== 'constructor').length === 0;\n    }\n\n    return keys.length === 0;\n  }\n\n  return true;\n}\n","/**\n * Creates a function that only executes starting from the `n`-th call.\n * The provided function will be invoked starting from the `n`-th call.\n *\n * This is particularly useful for scenarios involving events or asynchronous operations\n * where an action should occur only after a certain number of invocations.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of calls required for `func` to execute.\n * @param {F} func - The function to be invoked.\n * @returns {(...args: Parameters<F>) => ReturnType<F> | undefined} - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` starting from the `n`-th call.\n * - Returns `undefined` if fewer than `n` calls have been made.\n * @throws {Error} - Throws an error if `n` is negative.\n * @example\n *\n * const afterFn = after(3, () => {\n *  console.log(\"called\")\n * });\n *\n * // Will not log anything.\n * afterFn()\n * // Will not log anything.\n * afterFn()\n * // Will log 'called'.\n * afterFn()\n */\n\nexport function after<F extends (...args: any[]) => any>(\n  n: number,\n  func: F\n): (...args: Parameters<F>) => ReturnType<F> | undefined {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new Error(`n must be a non-negative integer.`);\n  }\n\n  let counter = 0;\n  return (...args: Parameters<F>) => {\n    if (++counter >= n) {\n      return func(...args);\n    }\n    return undefined;\n  };\n}\n","import { after } from '../../function/after.ts';\nimport { isEqualWith as isEqualWithToolkit } from '../../predicate/isEqualWith.ts';\nimport type { IsEqualCustomizer } from '../_internal/IsEqualCustomizer.ts';\n\n/**\n * Compares two values for equality using a custom comparison function.\n *\n * The custom function allows for fine-tuned control over the comparison process. If it returns a boolean, that result determines the equality. If it returns undefined, the function falls back to the default equality comparison.\n *\n * This function also uses the custom equality function to compare values inside objects,\n * arrays, maps, sets, and other complex structures, ensuring a deep comparison.\n *\n * This approach provides flexibility in handling complex comparisons while maintaining efficient default behavior for simpler cases.\n *\n * The custom comparison function can take up to six parameters:\n * - `x`: The value from the first object `a`.\n * - `y`: The value from the second object `b`.\n * - `property`: The property key used to get `x` and `y`.\n * - `xParent`: The parent of the first value `x`.\n * - `yParent`: The parent of the second value `y`.\n * - `stack`: An internal stack (Map) to handle circular references.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @param {(x: any, y: any, property?: PropertyKey, xParent?: any, yParent?: any, stack?: Map<any, any>) => boolean | void} [areValuesEqual=noop] - A function to customize the comparison.\n *   If it returns a boolean, that result will be used. If it returns undefined,\n *   the default equality comparison will be used.\n * @returns {boolean} `true` if the values are equal according to the customizer, otherwise `false`.\n *\n * @example\n * const customizer = (a, b) => {\n *   if (typeof a === 'string' && typeof b === 'string') {\n *     return a.toLowerCase() === b.toLowerCase();\n *   }\n * };\n * isEqualWith('Hello', 'hello', customizer); // true\n * isEqualWith({ a: 'Hello' }, { a: 'hello' }, customizer); // true\n * isEqualWith([1, 2, 3], [1, 2, 3], customizer); // true\n */\nexport function isEqualWith(a: any, b: any, areValuesEqual?: IsEqualCustomizer): boolean {\n  if (typeof areValuesEqual !== 'function') {\n    areValuesEqual = () => undefined;\n  }\n\n  return isEqualWithToolkit(a, b, (...args): boolean | void => {\n    const result = areValuesEqual(...args);\n\n    if (result !== undefined) {\n      return Boolean(result);\n    }\n\n    if (a instanceof Map && b instanceof Map) {\n      return isEqualWith(\n        Array.from(a),\n        Array.from(b),\n        // areValuesEqual should not be called for converted values\n        after(2, areValuesEqual)\n      );\n    }\n\n    if (a instanceof Set && b instanceof Set) {\n      return isEqualWith(\n        Array.from(a),\n        Array.from(b),\n        // areValuesEqual should not be called for converted values\n        after(2, areValuesEqual)\n      );\n    }\n  });\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if `value` is an Error object.\n *\n * @param {any} value The value to check.\n * @returns {value is Error} Returns `true` if `value` is an Error object, `false` otherwise.\n *\n * @example\n * ```typescript\n * console.log(isError(new Error())); // true\n * console.log(isError('Error')); // false\n * console.log(isError({ name: 'Error', message: '' })); // false\n * ```\n */\nexport function isError(value: any): value is Error {\n  return getTag(value) === '[object Error]';\n}\n","/**\n * Checks if `value` is a finite number.\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a finite number, `false` otherwise.\n *\n * @example\n * ```typescript\n * const value1 = 100;\n * const value2 = Infinity;\n * const value3 = '100';\n *\n * console.log(isFinite(value1)); // true\n * console.log(isFinite(value2)); // false\n * console.log(isFinite(value3)); // false\n * ```\n */\nexport function isFinite(value?: any): boolean {\n  return Number.isFinite(value);\n}\n","/**\n * Checks if `value` is an integer.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {any} value - The value to check\n * @returns {boolean} `true` if `value` is integer, otherwise `false`.\n *\n * @example\n * isInteger(3); // Returns: true\n * isInteger(Infinity); // Returns: false\n * isInteger('3'); // Returns: false\n * isInteger([]); // Returns: false\n */\nexport function isInteger(value?: any): boolean {\n  return Number.isInteger(value);\n}\n","import { isRegExp as isRegExpToolkit } from '../../predicate/isRegExp.ts';\n\n/**\n * Checks if `value` is a RegExp.\n *\n * @param {any} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a RegExp, `false` otherwise.\n *\n * @example\n * const value1 = /abc/;\n * const value2 = '/abc/';\n *\n * console.log(isRegExp(value1)); // true\n * console.log(isRegExp(value2)); // false\n */\nexport function isRegExp(value?: any): value is RegExp {\n  return isRegExpToolkit(value);\n}\n","/**\n * Checks if `value` is a RegExp.\n *\n * @param {unknown} value The value to check.\n * @returns {value is RegExp} Returns `true` if `value` is a RegExp, `false` otherwise.\n *\n * @example\n * const value1 = /abc/;\n * const value2 = '/abc/';\n *\n * console.log(isRegExp(value1)); // true\n * console.log(isRegExp(value2)); // false\n */\nexport function isRegExp(value: unknown): value is RegExp {\n  return value instanceof RegExp;\n}\n","/**\n * Checks if `value` is a safe integer (between -(2^53  1) and (2^53  1), inclusive).\n *\n * A safe integer is an integer that can be precisely represented as a `number` in JavaScript,\n * without any other integer being rounded to it.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {unknown} value - The value to check\n * @returns {boolean} `true` if `value` is an integer and between the safe values, otherwise `false`\n *\n * @example\n * isSafeInteger(3); // Returns: true\n * isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // Returns: false\n * isSafeInteger(1n); // Returns: false\n * isSafeInteger('1'); // Returns: false\n */\nexport function isSafeInteger(value: any): boolean {\n  return Number.isSafeInteger(value);\n}\n","import { isSet as isSetToolkit } from '../../predicate/isSet.ts';\n\n/**\n * Checks if a given value is `Set`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Set`.\n *\n * @param {unknown} value The value to check if it is a `Set`.\n * @returns {value is Set<any>} Returns `true` if `value` is a `Set`, else `false`.\n *\n * @example\n * const value1 = new Set();\n * const value2 = new Map();\n * const value3 = new WeakSet();\n *\n * console.log(isSet(value1)); // true\n * console.log(isSet(value2)); // false\n * console.log(isSet(value3)); // false\n */\n\nexport function isSet(value?: any): value is Set<any> {\n  return isSetToolkit(value);\n}\n","/**\n * Checks if a given value is `Set`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Set`.\n *\n * @param {unknown} value The value to check if it is a `Set`.\n * @returns {value is Set<any>} Returns `true` if `value` is a `Set`, else `false`.\n *\n * @example\n * const value1 = new Set();\n * const value2 = new Map();\n * const value3 = new WeakSet();\n *\n * console.log(isSet(value1)); // true\n * console.log(isSet(value2)); // false\n * console.log(isSet(value3)); // false\n */\n\nexport function isSet(value: unknown): value is Set<any> {\n  return value instanceof Set;\n}\n","import { isWeakMap as isWeakMapToolkit } from '../../predicate/isWeakMap.ts';\n\n/**\n * Checks if the given value is a `WeakMap`.\n *\n * This function tests whether the provided value is an instance of `WeakMap`.\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\n *\n * @param {unknown} value - The value to test if it is a `WeakMap`.\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\n *\n * @example\n * const value1 = new WeakMap();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakMap(value1)); // true\n * console.log(isWeakMap(value2)); // false\n * console.log(isWeakMap(value3)); // false\n */\nexport function isWeakMap(value?: any): value is WeakMap<object, any> {\n  return isWeakMapToolkit(value);\n}\n","/**\n * Checks if the given value is a `WeakMap`.\n *\n * This function tests whether the provided value is an instance of `WeakMap`.\n * It returns `true` if the value is a `WeakMap`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakMap`.\n *\n * @param {unknown} value - The value to test if it is a `WeakMap`.\n * @returns {value is WeakMap<WeakKey, any>} true if the value is a `WeakMap`, false otherwise.\n *\n * @example\n * const value1 = new WeakMap();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakMap(value1)); // true\n * console.log(isWeakMap(value2)); // false\n * console.log(isWeakMap(value3)); // false\n */\nexport function isWeakMap(value: unknown): value is WeakMap<WeakKey, any> {\n  return value instanceof WeakMap;\n}\n","import { isWeakSet as isWeakSetToolkit } from '../../predicate/isWeakSet.ts';\n\n/**\n * Checks if the given value is a `WeakSet`.\n *\n * This function tests whether the provided value is an instance of `WeakSet`.\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\n *\n * @param {unknown} value - The value to test if it is a `WeakSet`.\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\n *\n * @example\n * const value1 = new WeakSet();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakSet(value1)); // true\n * console.log(isWeakSet(value2)); // false\n * console.log(isWeakSet(value3)); // false\n */\nexport function isWeakSet(value?: any): value is WeakSet<object> {\n  return isWeakSetToolkit(value);\n}\n","/**\n * Checks if the given value is a `WeakSet`.\n *\n * This function tests whether the provided value is an instance of `WeakSet`.\n * It returns `true` if the value is a `WeakSet`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `WeakSet`.\n *\n * @param {unknown} value - The value to test if it is a `WeakSet`.\n * @returns {value is WeakSet<WeakKey>} true if the value is a `WeakSet`, false otherwise.\n *\n * @example\n * const value1 = new WeakSet();\n * const value2 = new Map();\n * const value3 = new Set();\n *\n * console.log(isWeakSet(value1)); // true\n * console.log(isWeakSet(value2)); // false\n * console.log(isWeakSet(value3)); // false\n */\nexport function isWeakSet(value: unknown): value is WeakSet<WeakKey> {\n  return value instanceof WeakSet;\n}\n","/**\n * Converts the first character of string to upper case and the remaining to lower case.\n *\n * @template T - Literal type of the string.\n * @param {T} str - The string to be converted to uppercase.\n * @returns {Capitalize<T>} - The capitalized string.\n *\n * @example\n * const result = capitalize('fred') // returns 'Fred'\n * const result2 = capitalize('FRED') // returns 'Fred'\n */\n\nexport function capitalize<T extends string>(str: T): Capitalize<T> {\n  return (str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()) as Capitalize<T>;\n}\n\ntype Capitalize<T extends string> = T extends `${infer F}${infer R}` ? `${Uppercase<F>}${Lowercase<R>}` : T;\n","import { capitalize as capitalizeToolkit } from '../../string/capitalize.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the first character of string to upper case and the remaining to lower case.\n *\n * @param {string} string - The string to capitalize.\n * @returns {string} - The capitalized string.\n *\n * @example\n * const convertedStr1 = capitalize('fred') // returns 'Fred'\n * const convertedStr2 = capitalize('FRED') // returns 'Fred'\n * const convertedStr3 = capitalize('') // returns ''\n */\nexport function capitalize<T extends string>(str?: T): string extends T ? string : Capitalize<Lowercase<T>> {\n  return capitalizeToolkit(toString(str)) as string extends T ? string : Capitalize<Lowercase<T>>;\n}\n","import { isFunction } from '../../predicate/isFunction.ts';\nimport { Many } from '../_internal/Many.ts';\nimport { isArray } from '../predicate/isArray.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Binds methods of an object to the object itself, overwriting the existing method.\n * Method names may be specified as individual arguments or as arrays of method names.\n *\n * @template T - The type of the object.\n * @param {T} object - The object to bind methods to.\n * @param {Array<Many<string>>} [methodNames] - The method names to bind, specified individually or in arrays.\n * @returns {T} - Returns the object.\n *\n * @example\n * const view = {\n *   'label': 'docs',\n *   'click': function() {\n *     console.log('clicked ' + this.label);\n *   }\n * };\n *\n * bindAll(view, ['click']);\n * jQuery(element).on('click', view.click);\n * // => Logs 'clicked docs' when clicked.\n *\n * @example\n * // Using individual method names\n * bindAll(view, 'click');\n * // => Same as above\n */\nexport function bindAll<T>(object: T, ...methodNames: Array<Many<string>>): T {\n  if (object == null) {\n    return object;\n  }\n\n  if (!isObject(object)) {\n    return object;\n  }\n\n  if (isArray(object) && methodNames.length === 0) {\n    return object;\n  }\n\n  const methods: any[] = [];\n  for (let i = 0; i < methodNames.length; i++) {\n    const name = methodNames[i];\n    if (isArray(name)) {\n      methods.push(...name);\n    } else if (name && typeof name === 'object' && 'length' in name) {\n      methods.push(...Array.from(name));\n    } else {\n      methods.push(name);\n    }\n  }\n\n  if (methods.length === 0) {\n    return object;\n  }\n\n  for (let i = 0; i < methods.length; i++) {\n    const key = methods[i];\n    const stringKey = toString(key) as keyof typeof object;\n    const func = object[stringKey];\n\n    if (isFunction(func)) {\n      object[stringKey] = func.bind(object) as any;\n    }\n  }\n\n  return object;\n}\n","/**\n * Regular expression pattern to split strings into words for various case conversions\n *\n * This pattern matches sequences of characters in a string, considering the following cases:\n * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)\n * - Sequences of one uppercase letter optionally followed by lowercase letters and digits\n * - Single uppercase letters\n * - Sequences of digits\n * - Emojis and other Unicode characters\n *\n * The resulting match can be used to convert camelCase, snake_case, kebab-case, and other mixed formats into\n * a consistent format like snake case. It also supports emojis and other Unicode characters.\n *\n * @example\n * const matches = 'camelCaseHTTPRequest'.match(CASE_SPLIT_PATTERN);\n * // matches: ['camel', 'Case', 'HTTP', 'Request', '']\n */\nexport const CASE_SPLIT_PATTERN =\n  /\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+/gu;\n\n/**\n * Splits `string` into an array of its words, treating spaces and punctuation marks as separators.\n *\n * @param {string} str The string to inspect.\n * @param {RegExp | string} [pattern] The pattern to match words.\n * @returns {string[]} Returns the words of `string`.\n *\n * @example\n * words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * words('camelCaseHTTPRequest');\n * // => ['camel', 'Case', 'HTTP', 'Request', '']\n *\n * words('Luned 18 Set')\n * // => ['Luned', '18', 'Set']\n */\nexport function words(str: string): string[] {\n  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\n}\n","import { toString } from '../util/toString.ts';\n\nexport function normalizeForCase(str: unknown): string {\n  // Coerce to string\n  if (typeof str !== 'string') {\n    str = toString(str);\n  }\n\n  // Remove contraction apostrophes\n  return (str as string).replace(/['\\u2019]/g, '');\n}\n","import { camelCase as camelCaseToolkit } from '../../string/camelCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to camel case.\n *\n * Camel case is the naming convention in which the first word is written in lowercase and\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\n *\n * @param {string | object} str - The string that is to be changed to camel case.\n * @returns {string} - The converted string to camel case.\n *\n * @example\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\n */\n\nexport function camelCase(str?: string): string {\n  return camelCaseToolkit(normalizeForCase(str));\n}\n","import { capitalize } from './capitalize.ts';\nimport { words as getWords } from './words.ts';\n\n/**\n * Converts a string to camel case.\n *\n * Camel case is the naming convention in which the first word is written in lowercase and\n * each subsequent word begins with a capital letter, concatenated without any separator characters.\n *\n * @param {string} str - The string that is to be changed to camel case.\n * @returns {string} - The converted string to camel case.\n *\n * @example\n * const convertedStr1 = camelCase('camelCase') // returns 'camelCase'\n * const convertedStr2 = camelCase('some whitespace') // returns 'someWhitespace'\n * const convertedStr3 = camelCase('hyphen-text') // returns 'hyphenText'\n * const convertedStr4 = camelCase('HTTPRequest') // returns 'httpRequest'\n * const convertedStr5 = camelCase('Keep unicode ') // returns 'keepUnicode'\n */\nexport function camelCase(str: string): string {\n  const words = getWords(str);\n\n  if (words.length === 0) {\n    return '';\n  }\n\n  const [first, ...rest] = words;\n\n  return `${first.toLowerCase()}${rest.map(word => capitalize(word)).join('')}`;\n}\n","const deburrMap = new Map<string, string>(\n  // eslint-disable-next-line no-restricted-syntax\n  Object.entries({\n    : 'Ae',\n    : 'D',\n    : 'O',\n    : 'Th',\n    : 'ss',\n    : 'ae',\n    : 'd',\n    : 'o',\n    : 'th',\n    : 'D',\n    : 'd',\n    : 'H',\n    : 'h',\n    : 'i',\n    : 'IJ',\n    : 'ij',\n    : 'k',\n    : 'L',\n    : 'l',\n    : 'L',\n    : 'l',\n    : \"'n\",\n    : 'N',\n    : 'n',\n    : 'Oe',\n    : 'oe',\n    : 'T',\n    : 't',\n    : 's',\n  })\n);\n\n/**\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\n * For example, \"Crme brle\" becomes \"Creme brulee\".\n *\n * @param {string} str - The input string to be deburred.\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\n *\n * @example\n * // Basic usage:\n * deburr('thelred') // returns 'Aethelred'\n *\n * @example\n * // Handling diacritical marks:\n * deburr('Mnchen') // returns 'Munchen'\n *\n * @example\n * // Special characters:\n * deburr('Crme brle') // returns 'Creme brulee'\n */\nexport function deburr(str: string): string {\n  str = str.normalize('NFD');\n\n  let result = '';\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n\n    if ((char >= '\\u0300' && char <= '\\u036f') || (char >= '\\ufe20' && char <= '\\ufe23')) {\n      continue;\n    }\n\n    result += deburrMap.get(char) ?? char;\n  }\n\n  return result;\n}\n","import { deburr as deburrToolkit } from '../../string/deburr.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\n * For example, \"Crme brle\" becomes \"Creme brulee\".\n *\n * @param {string} str - The input string to be deburred.\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\n *\n * @example\n * // Basic usage:\n * deburr('thelred') // returns 'Aethelred'\n *\n * @example\n * // Handling diacritical marks:\n * deburr('Mnchen') // returns 'Munchen'\n *\n * @example\n * // Special characters:\n * deburr('Crme brle') // returns 'Creme brulee'\n */\nexport function deburr(str?: string): string {\n  return deburrToolkit(toString(str));\n}\n","/**\n * Checks if a string contains another string at the end of the string.\n *\n * Checks if one string endsWith another string. Optional position parameter to offset searching before a certain index.\n *\n * @param {string} str - The string that might contain the target string.\n * @param {string} target - The string to search for.\n * @param {number} position - An optional position from the start to search up to this index\n * @returns {boolean} - True if the str string ends with the target string.\n *\n * @example\n * const isPrefix = endsWith('fooBar', 'foo') // returns true\n * const isPrefix = endsWith('fooBar', 'bar') // returns false\n * const isPrefix = endsWith('fooBar', 'abc') // returns false\n * const isPrefix = endsWith('fooBar', 'foo', 3) // returns true\n * const isPrefix = endsWith('fooBar', 'abc', 5) // returns false\n */\nexport function endsWith(str?: string, target?: string, position?: number): boolean {\n  if (str == null || target == null) {\n    return false;\n  }\n\n  if (position == null) {\n    position = str.length;\n  }\n\n  return str.endsWith(target, position);\n}\n","const htmlEscapes: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\n * For example, \"<\" becomes \"&lt;\".\n *\n * @param {string} str  The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\n */\nexport function escape(str: string): string {\n  return str.replace(/[&<>\"']/g, match => htmlEscapes[match]);\n}\n","import { escape as escapeToolkit } from '../../string/escape.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\n * For example, \"<\" becomes \"&lt;\".\n *\n * @param {string} str  The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\n */\nexport function escape(string?: string): string {\n  return escapeToolkit(toString(string));\n}\n","import { escapeRegExp as escapeRegExpToolkit } from '../../string/escapeRegExp.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Escapes the RegExp special characters \"^\", \"$\", \"\\\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `str`.\n *\n * @param {string} str The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * import { escapeRegExp } from 'es-toolkit/string';\n *\n * escapeRegExp('[es-toolkit](https://es-toolkit.slash.page/)'); // returns '\\[es-toolkit\\]\\(https://es-toolkit\\.slash\\.page/\\)'\n */\nexport function escapeRegExp(str?: string): string {\n  return escapeRegExpToolkit(toString(str));\n}\n","/**\n * Escapes the RegExp special characters \"^\", \"$\", \"\\\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `str`.\n *\n * @param {string} str The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * import { escapeRegExp } from 'es-toolkit/string';\n *\n * escapeRegExp('[es-toolkit](https://es-toolkit.slash.page/)'); // returns '\\[es-toolkit\\]\\(https://es-toolkit\\.slash\\.page/\\)'\n */\nexport function escapeRegExp(str: string): string {\n  return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n}\n","import { kebabCase as kebabCaseToolkit } from '../../string/kebabCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to kebab case.\n *\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\n *\n * @param {string | object} str - The string that is to be changed to kebab case.\n * @returns {string} - The converted string to kebab case.\n *\n * @example\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\n */\nexport function kebabCase(str?: string): string {\n  return kebabCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to kebab case.\n *\n * Kebab case is the naming convention in which each word is written in lowercase and separated by a dash (-) character.\n *\n * @param {string} str - The string that is to be changed to kebab case.\n * @returns {string} - The converted string to kebab case.\n *\n * @example\n * const convertedStr1 = kebabCase('camelCase') // returns 'camel-case'\n * const convertedStr2 = kebabCase('some whitespace') // returns 'some-whitespace'\n * const convertedStr3 = kebabCase('hyphen-text') // returns 'hyphen-text'\n * const convertedStr4 = kebabCase('HTTPRequest') // returns 'http-request'\n */\n\nexport function kebabCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join('-');\n}\n","import { lowerCase as lowerCaseToolkit } from '../../string/lowerCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to lower case.\n *\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\n *\n * @param {string | object} str - The string that is to be changed to lower case.\n * @returns {string} - The converted string to lower case.\n *\n * @example\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\n */\nexport function lowerCase(str?: string): string {\n  return lowerCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to lower case.\n *\n * Lower case is the naming convention in which each word is written in lowercase and separated by an space ( ) character.\n *\n * @param {string} str - The string that is to be changed to lower case.\n * @returns {string} - The converted string to lower case.\n *\n * @example\n * const convertedStr1 = lowerCase('camelCase') // returns 'camel case'\n * const convertedStr2 = lowerCase('some whitespace') // returns 'some whitespace'\n * const convertedStr3 = lowerCase('hyphen-text') // returns 'hyphen text'\n * const convertedStr4 = lowerCase('HTTPRequest') // returns 'http request'\n */\nexport function lowerCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join(' ');\n}\n","import { lowerFirst as lowerFirstToolkit } from '../../string/lowerFirst.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the first character of string to lower case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = lowerCase('fred') // returns 'fred'\n * const convertedStr2 = lowerCase('Fred') // returns 'fred'\n * const convertedStr3 = lowerCase('FRED') // returns 'fRED'\n */\nexport function lowerFirst<T extends string = string>(str?: T): Uncapitalize<T> {\n  return lowerFirstToolkit(toString(str)) as Uncapitalize<T>;\n}\n","/**\n * Converts the first character of string to lower case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = lowerCase('fred') // returns 'fred'\n * const convertedStr2 = lowerCase('Fred') // returns 'fred'\n * const convertedStr3 = lowerCase('FRED') // returns 'fRED'\n */\nexport function lowerFirst(str: string): string {\n  return str.substring(0, 1).toLowerCase() + str.substring(1);\n}\n","import { pad as padToolkit } from '../../string/pad.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = pad('abc', 8);         // result will be '  abc   '\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\n * const result3 = pad('abc', 3);         // result will be 'abc'\n * const result4 = pad('abc', 2);         // result will be 'abc'\n *\n */\nexport function pad(str?: string, length?: number, chars?: string): string;\n\n/**\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = pad('abc', 8);         // result will be '  abc   '\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\n * const result3 = pad('abc', 3);         // result will be 'abc'\n * const result4 = pad('abc', 2);         // result will be 'abc'\n *\n */\nexport function pad(str: any, length?: any, chars?: any): string {\n  return padToolkit(toString(str), length, chars);\n}\n","/**\n * Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string, the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = pad('abc', 8);         // result will be '  abc   '\n * const result2 = pad('abc', 8, '_-');   // result will be '_-abc_-_'\n * const result3 = pad('abc', 3);         // result will be 'abc'\n * const result4 = pad('abc', 2);         // result will be 'abc'\n *\n */\nexport function pad(str: string, length: number, chars = ' '): string {\n  return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Pads the end of a string with a given character until it reaches the specified length.\n *\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = padEnd('abc', 6);          // result will be 'abc   '\n * const result2 = padEnd('abc', 6, '_-');    // result will be 'abc_-_'\n * const result3 = padEnd('abc', 3);          // result will be 'abc'\n * const result4 = padEnd('abc', 2);          // result will be 'abc'\n */\n\nexport function padEnd(str?: string, length = 0, chars = ' '): string {\n  return toString(str).padEnd(length, chars);\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Pads the start of a string with a given character until it reaches the specified length.\n *\n * If the length is less than or equal to the original string's length, or if the padding character is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to pad.\n * @param {number} [length] - The length of the resulting string once padded.\n * @param {string} [chars] - The character(s) to use for padding.\n * @returns {string} - The padded string, or the original string if padding is not required.\n *\n * @example\n * const result1 = padStart('abc', 6);          // result will be '   abc'\n * const result2 = padStart('abc', 6, '_-');    // result will be '_-_abc'\n * const result3 = padStart('abc', 3);          // result will be 'abc'\n * const result4 = padStart('abc', 2);          // result will be 'abc'\n */\nexport function padStart(str?: string, length = 0, chars = ' '): string {\n  return toString(str).padStart(length, chars);\n}\n","import { isIterateeCall } from '../_internal/isIterateeCall.ts';\nimport { toInteger } from '../util/toInteger.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Repeats the given string n times.\n *\n * If n is less than 1, an empty string is returned, or if the string is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to repeat.\n * @param {number} n - The number of times to repeat the string.\n * @returns {string} - The repeated string, or an empty string if n is less than 1.\n *\n * @example\n * repeat('abc', 0); // ''\n * repeat('abc', 2); // 'abcabc'\n */\nexport function repeat(str?: string, n?: number): string;\n\n/**\n * Repeats the given string n times.\n *\n * If n is less than 1, an empty string is returned, or if the string is an empty string,\n * the original string is returned unchanged.\n *\n * @param {string} str - The string to repeat.\n * @param {number} n - The number of times to repeat the string.\n * @returns {string} - The repeated string, or an empty string if n is less than 1.\n *\n * @example\n * repeat('abc', 0); // ''\n * repeat('abc', 2); // 'abcabc'\n */\nexport function repeat(str: any, n?: any, guard?: any): string {\n  if (guard ? isIterateeCall(str, n, guard) : n === undefined) {\n    n = 1;\n  } else {\n    n = toInteger(n);\n  }\n  return toString(str).repeat(n);\n}\n","import { toString } from '../util/toString.ts';\n\ntype ReplaceFunction = (match: string, ...args: any[]) => string;\n\nexport function replace(string: string, pattern: RegExp | string, replacement: ReplaceFunction | string): string;\nexport function replace(pattern: RegExp | string, replacement: ReplaceFunction | string): string;\n\n/**\n * Replaces the matched pattern with the replacement string.\n *\n * @param {} target - The target string.\n * @param {} pattern - The pattern to match.\n * @param {} replacement - The replacement string or a function that returns the replacement string.\n * @returns {string} The new string with the matched pattern replaced.\n *\n * @example\n * replace('abcde', 'de', '123'); // 'abc123'\n * replace('abcde', /[bd]/g, '-'); // 'a-c-e'\n * replace('abcde', 'de', substring => substring.toUpperCase()); // 'abcDE'\n * replace('abcde', /[bd]/g, substring => substring.toUpperCase()); // 'aBcDe'\n */\nexport function replace(\n  target: string | RegExp,\n  pattern: RegExp | string | ReplaceFunction,\n  replacement?: ReplaceFunction | string\n): string {\n  if (arguments.length < 3) {\n    return toString(target);\n  }\n\n  return toString(target).replace(pattern as any, replacement as any);\n}\n","import { snakeCase as snakeCaseToolkit } from '../../string/snakeCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to snake case.\n *\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\n *\n * @param {string | object} str - The string that is to be changed to snake case.\n * @returns {string} - The converted string to snake case.\n *\n * @example\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\n */\nexport function snakeCase(str?: string): string {\n  return snakeCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to snake case.\n *\n * Snake case is the naming convention in which each word is written in lowercase and separated by an underscore (_) character.\n *\n * @param {string} str - The string that is to be changed to snake case.\n * @returns {string} - The converted string to snake case.\n *\n * @example\n * const convertedStr1 = snakeCase('camelCase') // returns 'camel_case'\n * const convertedStr2 = snakeCase('some whitespace') // returns 'some_whitespace'\n * const convertedStr3 = snakeCase('hyphen-text') // returns 'hyphen_text'\n * const convertedStr4 = snakeCase('HTTPRequest') // returns 'http_request'\n */\n\nexport function snakeCase(str: string): string {\n  const words = getWords(str);\n  return words.map(word => word.toLowerCase()).join('_');\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Splits the input string by the specified `separator`\n * and returns a new array containing the split segments.\n *\n * @param {string | null | undefined} [string=''] The string to split.\n * @param {RegExp|string} [separator] The separator pattern to split by.\n * @param {number} [limit] The length to truncate results to.\n * @returns {Array} Returns the string segments.\n *\n * @example\n * split('a-b-c', '-');\n * // => ['a', 'b', 'c']\n *\n * split('a-b-c', '-', 2);\n * // => ['a', 'b']\n */\nexport function split(string: string | null | undefined, separator?: RegExp | string, limit?: number): string[];\n\n/**\n * Splits the input string by the specified `separator`\n * and returns a new array containing the split segments.\n *\n * @param {string | null | undefined} [string=''] The string to split.\n * @param {RegExp|string} [separator] The separator pattern to split by.\n * @param {number} [limit] The length to truncate results to.\n * @returns {Array} Returns the string segments.\n *\n * @example\n * split('a-b-c', '-');\n * // => ['a', 'b', 'c']\n *\n * split('a-b-c', '-', 2);\n * // => ['a', 'b']\n */\nexport function split(string: string | null | undefined, index: string | number, guard: object): string[];\n\nexport function split(string: any, separator?: any, limit?: any): string[] {\n  return toString(string).split(separator as string, limit);\n}\n","import { words as getWords } from '../../string/words.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts the first character of each word in a string to uppercase and the remaining characters to lowercase.\n *\n * Start case is the naming convention in which each word is written with an initial capital letter.\n * @param {string | object} str - The string to convert.\n * @returns {string} The converted string.\n *\n * @example\n * const result1 = startCase('hello world');  // result will be 'Hello World'\n * const result2 = startCase('HELLO WORLD');  // result will be 'HELLO WORLD'\n * const result3 = startCase('hello-world');  // result will be 'Hello World'\n * const result4 = startCase('hello_world');  // result will be 'Hello World'\n */\nexport function startCase(str?: string): string {\n  const words = getWords(normalizeForCase(str).trim());\n\n  let result = '';\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n\n    if (result) {\n      result += ' ';\n    }\n\n    if (word === word.toUpperCase()) {\n      result += word;\n    } else {\n      result += word[0].toUpperCase() + word.slice(1).toLowerCase();\n    }\n  }\n\n  return result;\n}\n","/**\n * Checks if a string contains another string at the beginning of the string.\n *\n * Checks if one string startsWith another string. Optional position parameter to start searching from a certain index.\n *\n * @param {string} str - The string that might contain the target string.\n * @param {string} target - The string to search for.\n * @param {number} position - An optional offset to start searching in the str string\n * @returns {boolean} - True if the str string starts with the target string.\n *\n * @example\n * const isPrefix = startsWith('fooBar', 'foo') // returns true\n * const isPrefix = startsWith('fooBar', 'bar') // returns false\n * const isPrefix = startsWith('fooBar', 'abc') // returns false\n * const isPrefix = startsWith('fooBar', 'Bar', 2) // returns true\n * const isPrefix = startsWith('fooBar', 'Bar', 5) // returns false\n */\nexport function startsWith(str?: string, target?: string, position?: number): boolean {\n  if (str == null || target == null) {\n    return false;\n  }\n\n  if (position == null) {\n    position = 0;\n  }\n\n  return str.startsWith(target, position);\n}\n","import { escape } from './escape.ts';\nimport { attempt } from '../function/attempt.ts';\nimport { defaults } from '../object/defaults.ts';\nimport { toString } from '../util/toString.ts';\n\n// A regular expression for matching literal string in ES template string.\nconst esTemplateRegExp = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n// A regular expression for matching unescaped characters in string.\nconst unEscapedRegExp = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n// A regular expression for matching no match.\nconst noMatchExp = /($^)/;\n\nconst escapeMap = new Map([\n  ['\\\\', '\\\\'],\n  [\"'\", \"'\"],\n  ['\\n', 'n'],\n  ['\\r', 'r'],\n  ['\\u2028', 'u2028'],\n  ['\\u2029', 'u2029'],\n]);\n\nfunction escapeString(match: string): string {\n  return `\\\\${escapeMap.get(match)}`;\n}\n\n// Only import the necessary functions for preventing circular dependencies.(lodash-es also does this)\nexport const templateSettings = {\n  escape: /<%-([\\s\\S]+?)%>/g,\n  evaluate: /<%([\\s\\S]+?)%>/g,\n  interpolate: /<%=([\\s\\S]+?)%>/g,\n  variable: '',\n  imports: {\n    _: {\n      escape,\n      template,\n    },\n  },\n};\n\ninterface TemplateOptions {\n  escape?: RegExp | null | undefined;\n  evaluate?: RegExp | null | undefined;\n  interpolate?: RegExp | null | undefined;\n  variable?: string | undefined;\n  imports?: Record<string, any> | undefined;\n  sourceURL?: string;\n}\n\ninterface TemplateExecutor {\n  (data?: object): string;\n  source: string;\n}\n\nexport function template(string?: string, options?: TemplateOptions): TemplateExecutor;\n\n/**\n * Compiles a template string into a function that can interpolate data properties.\n *\n * This function allows you to create a template with custom delimiters for escaping,\n * evaluating, and interpolating values. It can also handle custom variable names and\n * imported functions.\n *\n * @param {string} string - The template string.\n * @param {TemplateOptions} [options] - The options object.\n * @param {RegExp | null | undefined} [options.escape] - The regular expression for \"escape\" delimiter.\n * @param {RegExp | null | undefined} [options.evaluate] - The regular expression for \"evaluate\" delimiter.\n * @param {RegExp | null | undefined} [options.interpolate] - The regular expression for \"interpolate\" delimiter.\n * @param {string | undefined} [options.variable] - The data object variable name.\n * @param {Record<string, any> | undefined} [options.imports] - The object of imported functions.\n * @param {string | undefined} [options.sourceURL] - The source URL of the template.\n * @param {object} [guard] - The guard to detect if the function is called with `options`.\n * @returns {TemplateExecutor} Returns the compiled template function.\n *\n * @example\n * // Use the \"escape\" delimiter to escape data properties.\n * const compiled = template('<%- value %>');\n * compiled({ value: '<div>' }); // returns '&lt;div&gt;'\n *\n * @example\n * // Use the \"interpolate\" delimiter to interpolate data properties.\n * const compiled = template('<%= value %>');\n * compiled({ value: 'Hello, World!' }); // returns 'Hello, World!'\n *\n * @example\n * // Use the \"evaluate\" delimiter to evaluate JavaScript code.\n * const compiled = template('<% if (value) { %>Yes<% } else { %>No<% } %>');\n * compiled({ value: true }); // returns 'Yes'\n *\n * @example\n * // Use the \"variable\" option to specify the data object variable name.\n * const compiled = template('<%= data.value %>', { variable: 'data' });\n * compiled({ value: 'Hello, World!' }); // returns 'Hello, World!'\n *\n * @example\n * // Use the \"imports\" option to import functions.\n * const compiled = template('<%= _.toUpper(value) %>', { imports: { _: { toUpper } } });\n * compiled({ value: 'hello, world!' }); // returns 'HELLO, WORLD!'\n *\n * @example\n * // Use the custom \"escape\" delimiter.\n * const compiled = template('<@ value @>', { escape: /<@([\\s\\S]+?)@>/g });\n * compiled({ value: '<div>' }); // returns '&lt;div&gt;'\n *\n * @example\n * // Use the custom \"evaluate\" delimiter.\n * const compiled = template('<# if (value) { #>Yes<# } else { #>No<# } #>', { evaluate: /<#([\\s\\S]+?)#>/g });\n * compiled({ value: true }); // returns 'Yes'\n *\n * @example\n * // Use the custom \"interpolate\" delimiter.\n * const compiled = template('<$ value $>', { interpolate: /<\\$([\\s\\S]+?)\\$>/g });\n * compiled({ value: 'Hello, World!' }); // returns 'Hello, World!'\n *\n * @example\n * // Use the \"sourceURL\" option to specify the source URL of the template.\n * const compiled = template('hello <%= user %>!', { sourceURL: 'template.js' });\n */\nexport function template(string?: string, options?: TemplateOptions, guard?: object): TemplateExecutor {\n  string = toString(string);\n\n  if (guard) {\n    options = templateSettings;\n  }\n\n  options = defaults({ ...options }, templateSettings);\n\n  const delimitersRegExp = new RegExp(\n    [\n      options.escape?.source ?? noMatchExp.source,\n      options.interpolate?.source ?? noMatchExp.source,\n      options.interpolate ? esTemplateRegExp.source : noMatchExp.source,\n      options.evaluate?.source ?? noMatchExp.source,\n      '$',\n    ].join('|'),\n    'g'\n  );\n\n  let lastIndex = 0;\n  let isEvaluated = false;\n  let source = `__p += ''`;\n\n  for (const match of string.matchAll(delimitersRegExp)) {\n    const [fullMatch, escapeValue, interpolateValue, esTemplateValue, evaluateValue] = match;\n    const { index } = match;\n\n    source += ` + '${string.slice(lastIndex, index).replace(unEscapedRegExp, escapeString)}'`;\n\n    if (escapeValue) {\n      source += ` + _.escape(${escapeValue})`;\n    }\n\n    if (interpolateValue) {\n      source += ` + ((${interpolateValue}) == null ? '' : ${interpolateValue})`;\n    } else if (esTemplateValue) {\n      source += ` + ((${esTemplateValue}) == null ? '' : ${esTemplateValue})`;\n    }\n\n    if (evaluateValue) {\n      source += `;\\n${evaluateValue};\\n __p += ''`;\n      isEvaluated = true;\n    }\n\n    lastIndex = index + fullMatch.length;\n  }\n\n  const imports = defaults({ ...options.imports }, templateSettings.imports);\n  const importsKeys = Object.keys(imports);\n  const importValues = Object.values(imports);\n\n  const sourceURL = `//# sourceURL=${\n    options.sourceURL ? String(options.sourceURL).replace(/[\\r\\n]/g, ' ') : `es-toolkit.templateSource[${Date.now()}]`\n  }\\n`;\n\n  const compiledFunction = `function(${options.variable || 'obj'}) {\n    let __p = '';\n    ${options.variable ? '' : 'if (obj == null) { obj = {}; }'}\n    ${isEvaluated ? `function print() { __p += Array.prototype.join.call(arguments, ''); }` : ''}\n    ${options.variable ? source : `with(obj) {\\n${source}\\n}`}\n    return __p;\n  }`;\n\n  const result = attempt(() => new Function(...importsKeys, `${sourceURL}return ${compiledFunction}`)(...importValues));\n\n  result.source = compiledFunction;\n\n  if (result instanceof Error) {\n    throw result;\n  }\n\n  return result;\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Converts the given value to a string and transforms it to lower case.\n * The function can handle various input types by first converting them to strings.\n *\n * @param {unknown} [value=''] The value to convert.\n * @returns {string} Returns the lower cased string.\n * @example\n *\n * toLower('--FOO-BAR--');\n * // => '--foo-bar--'\n *\n * toLower(null);\n * // => ''\n *\n * toLower([1, 2, 3]);\n * // => '1,2,3'\n */\nexport function toLower<T extends string = string>(value?: T): Lowercase<T> {\n  return toString(value).toLowerCase() as Lowercase<T>;\n}\n","import { toString } from '../util/toString.ts';\n\n/**\n * Converts `string`, as a whole, to upper case just like\n * [String#toUpperCase](https://mdn.io/toUpperCase).\n *\n * @param {unknown} [value=''] The value to convert.\n * @returns {string} Returns the upper cased string.\n * @example\n *\n * toUpper('--foo-bar--');\n * // => '--FOO-BAR--'\n *\n * toUpper(null);\n * // => ''\n *\n * toUpper([1, 2, 3]);\n * // => '1,2,3'\n */\nexport function toUpper<T extends string = string>(value?: T): Uppercase<T> {\n  return toString(value).toUpperCase() as Uppercase<T>;\n}\n","/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * If `chars` is a string, it should be a single character. To trim a string with multiple characters,\n * provide an array instead.\n *\n * @param {string} str - The string from which trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string.\n * @returns {string} - The resulting string after the specified trailing character has been removed.\n *\n * @example\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\n */\nexport function trimEnd(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trimEnd();\n  }\n\n  let endIndex = str.length;\n\n  switch (typeof chars) {\n    case 'string': {\n      if (chars.length !== 1) {\n        throw new Error(`The 'chars' parameter should be a single character string.`);\n      }\n\n      while (endIndex > 0 && str[endIndex - 1] === chars) {\n        endIndex--;\n      }\n      break;\n    }\n    case 'object': {\n      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {\n        endIndex--;\n      }\n    }\n  }\n\n  return str.substring(0, endIndex);\n}\n","/**\n * Removes leading whitespace or specified characters from a string.\n *\n * If `chars` is a string, it should be a single character. To trim a string with multiple characters,\n * provide an array instead.\n *\n * @param {string} str - The string from which leading characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the start of the string.\n * @returns {string} - The resulting string after the specified leading character has been removed.\n *\n * @example\n * const trimmedStr1 = trimStart('---hello', '-') // returns 'hello'\n * const trimmedStr2 = trimStart('000123', '0') // returns '123'\n * const trimmedStr3 = trimStart('abcabcabc', 'a') // returns 'bcabcabc'\n * const trimmedStr4 = trimStart('xxxtrimmed', 'x') // returns 'trimmed'\n */\nexport function trimStart(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trimStart();\n  }\n\n  let startIndex = 0;\n\n  switch (typeof chars) {\n    case 'string': {\n      while (startIndex < str.length && str[startIndex] === chars) {\n        startIndex++;\n      }\n      break;\n    }\n    case 'object': {\n      while (startIndex < str.length && chars.includes(str[startIndex])) {\n        startIndex++;\n      }\n    }\n  }\n\n  return str.substring(startIndex);\n}\n","import { trimEnd } from './trimEnd.ts';\nimport { trimStart } from './trimStart.ts';\n\n/**\n * Removes leading and trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the string. Can be a single character or an array of characters.\n * @returns {string} - The resulting string after the specified characters have been removed.\n *\n * @example\n * trim(\"  hello  \"); // \"hello\"\n * trim(\"--hello--\", \"-\"); // \"hello\"\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\n */\nexport function trim(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trim();\n  }\n\n  return trimStart(trimEnd(str, chars), chars);\n}\n","import { trim as trimToolkit } from '../../string/trim.ts';\n\n/**\n * Removes leading and trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading and trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\n * @returns {string} - The resulting string after the specified leading and trailing characters have been removed.\n *\n * @example\n * trim(\"  hello  \"); // \"hello\"\n * trim(\"--hello--\", \"-\"); // \"hello\"\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\n */\nexport function trim(string?: string, chars?: string): string;\n\n/**\n * Removes leading and trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading and trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string. Defaults to `\" \"`.\n * @returns {string} - The resulting string after the specified leading and trailing characters have been removed.\n *\n * @example\n * trim(\"  hello  \"); // \"hello\"\n * trim(\"--hello--\", \"-\"); // \"hello\"\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\n */\nexport function trim(string: string, index: string | number, guard: object): string;\n\nexport function trim(str: any, chars?: any, guard?: any): string {\n  if (str == null) {\n    return '';\n  }\n\n  if (guard != null || chars == null) {\n    return str.toString().trim();\n  }\n\n  switch (typeof chars) {\n    case 'object': {\n      if (Array.isArray(chars)) {\n        return trimToolkit(\n          str,\n          chars.flatMap(x => x.toString().split(''))\n        );\n      } else {\n        return trimToolkit(str, (chars as any).toString().split(''));\n      }\n    }\n    default: {\n      return trimToolkit(str, chars.toString().split(''));\n    }\n  }\n}\n","import { trimEnd as trimEndToolkit } from '../../string/trimEnd.ts';\n\n/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * @param {string} string - The string to trim.\n * @param {string} chars - The characters to trim from the end of the string.\n * @returns {string} Returns the trimmed string.\n *\n * @example\n * trimEnd('  abc  ');\n * // => '  abc'\n *\n * trimEnd('-_-abc-_-', '_-');\n * // => '-_-abc'\n */\nexport function trimEnd(string?: string, chars?: string): string;\n\n/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * @param {string} string - The string to trim.\n * @param {string | number} index - The index parameter (used with guard).\n * @param {object} guard - Enables use as an iteratee for methods like `map`.\n * @returns {string} Returns the trimmed string.\n *\n * @example\n * trimEnd('  abc  ', 0, {});\n * // => '  abc'\n */\nexport function trimEnd(string: string, index: string | number, guard: object): string;\n\n/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which trailing characters will be trimmed.\n * @param {string | number} chars - The character(s) to remove from the end of the string.\n * @param {object} guard - Enables use as an iteratee for methods like `map`.\n * @returns {string} Returns the trimmed string.\n *\n * @example\n * trimEnd('  abc  ');\n * // => '  abc'\n *\n * trimEnd('-_-abc-_-', '_-');\n * // => '-_-abc'\n */\nexport function trimEnd(str?: string, chars?: string | number, guard?: object): string {\n  if (str == null) {\n    return '';\n  }\n\n  if (guard != null || chars == null) {\n    return str.toString().trimEnd();\n  }\n\n  return trimEndToolkit(str, chars.toString().split(''));\n}\n","import { trimStart as trimStartToolkit } from '../../string/trimStart.ts';\n\n/**\n * Removes leading whitespace or specified characters from a string.\n *\n * @param {string} string - The string to trim.\n * @param {string} chars - The characters to trim from the start of the string.\n * @returns {string} Returns the trimmed string.\n *\n * @example\n * trimStart('  abc  ');\n * // => 'abc  '\n *\n * trimStart('-_-abc-_-', '_-');\n * // => 'abc-_-'\n */\nexport function trimStart(string?: string, chars?: string): string;\n\n/**\n * Removes leading whitespace or specified characters from a string.\n *\n * @param {string} string - The string to trim.\n * @param {string | number} index - The index parameter (used with guard).\n * @param {object} guard - Enables use as an iteratee for methods like `map`.\n * @returns {string} Returns the trimmed string.\n *\n * @example\n * trimStart('  abc  ', 0, {});\n * // => 'abc  '\n */\nexport function trimStart(string: string, index: string | number, guard: object): string;\n\n/**\n * Removes leading whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading characters will be trimmed.\n * @param {string | number} chars - The character(s) to remove from the start of the string.\n * @param {object} guard - Enables use as an iteratee for methods like `map`.\n * @returns {string} Returns the trimmed string.\n *\n * @example\n * trimStart('  abc  ');\n * // => 'abc  '\n *\n * trimStart('-_-abc-_-', '_-');\n * // => 'abc-_-'\n */\nexport function trimStart(str?: string, chars?: string | number, guard?: object): string {\n  if (str == null) {\n    return '';\n  }\n\n  if (guard != null || chars == null) {\n    return str.toString().trimStart();\n  }\n\n  return trimStartToolkit(str, chars.toString().split(''));\n}\n","import { isObject } from '../predicate/isObject.ts';\n\ntype TruncateOptions = {\n  length?: number;\n  separator?: string | RegExp;\n  omission?: string;\n};\n\n/**\n * Used to compose unicode character classes.\n * @link https://github.com/lodash/lodash/blob/4.17.21-es/_hasUnicode.js\n *\n * Used to detect strings with zero-width joiners or code points from the astral planes.\n * @link http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/\n */\n// eslint-disable-next-line no-misleading-character-class\nconst regexMultiByte = /[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]/;\n\n/**\n * This regex might more completely detect unicode, but it is slower and this project\n * desires to mimic the behavior of lodash.\n */\n// const regexMultiByte = /[^\\x00-\\x7F]/;\n\n/**\n * Truncates `string` if it's longer than the given maximum string length.\n * The last characters of the truncated string are replaced with the omission\n * string which defaults to \"...\".\n *\n * @param {string} [string=''] The string to truncate.\n * @param {Object} [options={}] The options object.\n * @param {number} [options.length=30] The maximum string length.\n * @param {string} [options.omission='...'] The string to indicate text is omitted.\n * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n *\n * @example\n * const test = 'hi-diddly-ho there, neighborino';\n * const truncatedStr1 = truncate(test) // returns 'hi-diddly-ho there, neighbo...'\n * const truncatedStr2 = truncate(test, { length: 24, separator: ' ' }) // returns 'hi-diddly-ho there,...'\n * const truncatedStr3 = truncate(test, { length: 24, separator: /,? +/ }) // returns 'hi-diddly-ho there...'\n * const truncatedStr4 = truncate(test, { omission: ' [...]' }) // returns 'hi-diddly-ho there, neig [...]'\n * const truncatedStr5 = truncate('ABC', { length: 3 }) // returns 'ABC'\n * const truncatedStr6 = truncate('ABC', { length: 2 }) // returns '...'\n * const truncatedStr7 = truncate('', { length: 5 }) // returns ''\n * const truncatedStr8 = truncate('', { length: 4, omission: '' }) // returns ''\n */\nexport function truncate(string?: string, options?: TruncateOptions): string {\n  string = string != null ? `${string}` : '';\n\n  let length = 30;\n  let omission = '...';\n\n  if (isObject(options)) {\n    length = parseLength(options.length);\n    omission = 'omission' in options ? `${options.omission}` : '...';\n  }\n\n  let i = string.length;\n\n  // Unicode length of omission string\n  const lengthOmission = Array.from(omission).length;\n  // Unicode length of the string if it is truncated\n  const lengthBase = Math.max(length - lengthOmission, 0);\n\n  let strArray: string[] | undefined = undefined;\n  const unicode = regexMultiByte.test(string);\n  if (unicode) {\n    strArray = Array.from(string);\n    i = strArray.length;\n  }\n\n  // Return input string as it satisfies truncation length\n  if (length >= i) {\n    return string;\n  }\n\n  // Return omission string since the input string will be truncated and is shorter than the omission string\n  if (i <= lengthOmission) {\n    return omission;\n  }\n\n  // Use string.slice for non-unicode strings for performance\n  let base = strArray === undefined ? string.slice(0, lengthBase) : strArray?.slice(0, lengthBase).join('');\n\n  // Return truncated string with omission appended when there is no separator to check for\n  const separator = options?.separator;\n  if (!separator) {\n    base += omission;\n    return base;\n  }\n\n  // Further truncate the string to the last separator using unicode regex\n  const search = separator instanceof RegExp ? separator.source : separator;\n  const flags = 'u' + (separator instanceof RegExp ? separator.flags.replace('u', '') : '');\n  const withoutSeparator = new RegExp(`(?<result>.*(?:(?!${search}).))(?:${search})`, flags).exec(base);\n\n  // Return the final truncated string with the omission string appended\n  return (!withoutSeparator?.groups ? base : withoutSeparator.groups.result) + omission;\n}\n\nfunction parseLength(length: number | undefined) {\n  if (length == null) {\n    return 30;\n  }\n\n  if (length <= 0) {\n    return 0;\n  }\n\n  return length;\n}\n","const htmlUnescapes: Record<string, string> = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&#39;': \"'\",\n};\n\n/**\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\n * It is the inverse of `escape`.\n *\n * @param {string} str The string to unescape.\n * @returns {string} Returns the unescaped string.\n *\n * @example\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\n */\nexport function unescape(str: string): string {\n  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, match => htmlUnescapes[match] || \"'\");\n}\n","import { unescape as unescapeToolkit } from '../../string/unescape.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\n * It is the inverse of `escape`.\n *\n * @param {string} str The string to unescape.\n * @returns {string} Returns the unescaped string.\n *\n * @example\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\n */\nexport function unescape(str?: string): string {\n  return unescapeToolkit(toString(str));\n}\n","import { upperCase as upperCaseToolkit } from '../../string/upperCase.ts';\nimport { normalizeForCase } from '../_internal/normalizeForCase.ts';\n\n/**\n * Converts a string to upper case.\n *\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\n *\n * @param {string | object} str - The string that is to be changed to upper case.\n * @returns {string} - The converted string to upper case.\n *\n * @example\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\n */\nexport function upperCase(str?: string): string {\n  return upperCaseToolkit(normalizeForCase(str));\n}\n","import { words as getWords } from './words.ts';\n\n/**\n * Converts a string to upper case.\n *\n * Upper case is the naming convention in which each word is written in uppercase and separated by an space ( ) character.\n *\n * @param {string} str - The string that is to be changed to upper case.\n * @returns {string} - The converted string to upper case.\n *\n * @example\n * const convertedStr1 = upperCase('camelCase') // returns 'CAMEL CASE'\n * const convertedStr2 = upperCase('some whitespace') // returns 'SOME WHITESPACE'\n * const convertedStr3 = upperCase('hyphen-text') // returns 'HYPHEN TEXT'\n * const convertedStr4 = upperCase('HTTPRequest') // returns 'HTTP REQUEST'\n */\nexport function upperCase(str: string): string {\n  const words = getWords(str);\n\n  let result = '';\n\n  for (let i = 0; i < words.length; i++) {\n    result += words[i].toUpperCase();\n    if (i < words.length - 1) {\n      result += ' ';\n    }\n  }\n\n  return result;\n}\n","import { upperFirst as upperFirstToolkit } from '../../string/upperFirst.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the first character of string to upper case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = upperFirst('fred') // returns 'Fred'\n * const convertedStr2 = upperFirst('Fred') // returns 'Fred'\n * const convertedStr3 = upperFirst('FRED') // returns 'FRED'\n */\nexport function upperFirst<T extends string = string>(str?: T): Capitalize<T> {\n  return upperFirstToolkit(toString(str)) as Capitalize<T>;\n}\n","/**\n * Converts the first character of string to upper case.\n *\n * @param {string} str - The string that is to be changed\n * @returns {string} - The converted string.\n *\n * @example\n * const convertedStr1 = upperFirst('fred') // returns 'Fred'\n * const convertedStr2 = upperFirst('Fred') // returns 'Fred'\n * const convertedStr3 = upperFirst('FRED') // returns 'FRED'\n */\nexport function upperFirst(str: string): string {\n  return str.substring(0, 1).toUpperCase() + str.substring(1);\n}\n","import { toString } from '../util/toString.ts';\n\nconst rNonCharLatin = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\xd7\\\\xf7';\n\nconst rUnicodeUpper = '\\\\p{Lu}';\nconst rUnicodeLower = '\\\\p{Ll}';\n\nconst rMisc = '(?:[\\\\p{Lm}\\\\p{Lo}]\\\\p{M}*)';\nconst rNumber = '\\\\d';\nconst rUnicodeOptContrLower = \"(?:['\\u2019](?:d|ll|m|re|s|t|ve))?\";\nconst rUnicodeOptContrUpper = \"(?:['\\u2019](?:D|LL|M|RE|S|T|VE))?\";\nconst rUnicodeBreak = `[\\\\p{Z}\\\\p{P}${rNonCharLatin}]`;\n\nconst rUnicodeMiscUpper = `(?:${rUnicodeUpper}|${rMisc})`;\nconst rUnicodeMiscLower = `(?:${rUnicodeLower}|${rMisc})`;\n\nconst rUnicodeWord = RegExp(\n  [\n    `${rUnicodeUpper}?${rUnicodeLower}+${rUnicodeOptContrLower}(?=${rUnicodeBreak}|${rUnicodeUpper}|$)`,\n\n    `${rUnicodeMiscUpper}+${rUnicodeOptContrUpper}(?=${rUnicodeBreak}|${rUnicodeUpper}${rUnicodeMiscLower}|$)`,\n\n    `${rUnicodeUpper}?${rUnicodeMiscLower}+${rUnicodeOptContrLower}`,\n\n    `${rUnicodeUpper}+${rUnicodeOptContrUpper}`,\n\n    `${rNumber}*(?:1ST|2ND|3RD|(?![123])${rNumber}TH)(?=\\\\b|[a-z_])`,\n\n    `${rNumber}*(?:1st|2nd|3rd|(?![123])${rNumber}th)(?=\\\\b|[A-Z_])`,\n\n    `${rNumber}+`,\n\n    '\\\\p{Emoji_Presentation}',\n\n    '\\\\p{Extended_Pictographic}',\n  ].join('|'),\n  'gu'\n);\n\n/**\n * Splits `string` into an array of its words.\n *\n * @param {string | object} str - The string or object that is to be split into words.\n * @param {RegExp | string} [pattern] - The pattern to match words.\n * @returns {string[]} - Returns the words of `string`.\n *\n * @example\n * const wordsArray1 = words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n */\nexport function words(string?: string, pattern?: string | RegExp): string[];\n\n/**\n * Splits `string` into an array of its words.\n *\n * @param {string | object} str - The string or object that is to be split into words.\n * @param {RegExp | string} [pattern] - The pattern to match words.\n * @returns {string[]} - Returns the words of `string`.\n *\n * @example\n * const wordsArray1 = words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n */\nexport function words(string: string, index: string | number, guard: object): string[];\n\n/**\n * Splits `string` into an array of its words.\n *\n * @param {string | object} str - The string or object that is to be split into words.\n * @param {RegExp | string} [pattern] - The pattern to match words.\n * @returns {string[]} - Returns the words of `string`.\n *\n * @example\n * const wordsArray1 = words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n */\nexport function words(str?: string, pattern: string | number | RegExp = rUnicodeWord, guard?: object): string[] {\n  const input = toString(str);\n\n  if (guard) {\n    pattern = rUnicodeWord;\n  }\n\n  if (typeof pattern === 'number') {\n    pattern = pattern.toString();\n  }\n\n  const words = Array.from(input.match(pattern) ?? []);\n\n  return words.filter(x => x !== '');\n}\n","import { iteratee } from './iteratee.ts';\nimport { isFunction } from '../../predicate/isFunction.ts';\n\n/**\n * Creates a function that checks conditions one by one and runs the matching function.\n *\n * Each pair consists of a condition (predicate) and a function to run.\n * The function goes through each condition in order until it finds one that's true.\n * When it finds a true condition, it runs the corresponding function and returns its result.\n * If none of the conditions are true, it returns undefined.\n *\n * @param {Array<Array>} pairs - Array of pairs. Each pair consists of a predicate function and a function to run.\n * @returns {(...args: any[]) => unknown} A new composite function that checks conditions and runs the matching function.\n * @example\n *\n * const func = cond([\n *   [matches({ a: 1 }), constant('matches A')],\n *   [conforms({ b: isNumber }), constant('matches B')],\n *   [stubTrue, constant('no match')]\n * ]);\n *\n * func({ a: 1, b: 2 });\n * // => 'matches A'\n *\n * func({ a: 0, b: 1 });\n * // => 'matches B'\n *\n * func({ a: '1', b: '2' });\n * // => 'no match'\n */\nexport function cond<R>(pairs: Array<[truthy: () => boolean, falsey: () => R]>): () => R;\n\n/**\n * Creates a function that checks conditions one by one and runs the matching function.\n *\n * Each pair consists of a condition (predicate) and a function to run.\n * The function goes through each condition in order until it finds one that's true.\n * When it finds a true condition, it runs the corresponding function and returns its result.\n * If none of the conditions are true, it returns undefined.\n *\n * @param {Array<Array>} pairs - Array of pairs. Each pair consists of a predicate function and a function to run.\n * @returns {(...args: any[]) => unknown} A new composite function that checks conditions and runs the matching function.\n * @example\n *\n * const func = cond([\n *   [matches({ a: 1 }), constant('matches A')],\n *   [conforms({ b: isNumber }), constant('matches B')],\n *   [stubTrue, constant('no match')]\n * ]);\n *\n * func({ a: 1, b: 2 });\n * // => 'matches A'\n *\n * func({ a: 0, b: 1 });\n * // => 'matches B'\n *\n * func({ a: '1', b: '2' });\n * // => 'no match'\n */\nexport function cond<T, R>(pairs: Array<[truthy: (val: T) => boolean, falsey: (val: T) => R]>): (val: T) => R;\n\nexport function cond(pairs: any[][]): (...args: any[]) => unknown {\n  const length = pairs.length;\n\n  const processedPairs = pairs.map(pair => {\n    const predicate = pair[0];\n    const func = pair[1];\n\n    if (!isFunction(func)) {\n      throw new TypeError('Expected a function');\n    }\n\n    return [iteratee(predicate), func] as const;\n  });\n\n  return function (this: unknown, ...args: any[]): unknown {\n    for (let i = 0; i < length; i++) {\n      const pair = processedPairs[i];\n      const predicate = pair[0] as (this: unknown, ...args: any[]) => boolean;\n      const func = pair[1] as (this: unknown, ...args: any[]) => unknown;\n\n      if (predicate.apply(this, args)) {\n        return func.apply(this, args);\n      }\n    }\n  };\n}\n","/**\n * Creates a new function that always returns `value`.\n *\n * @template T - The type of the value to return.\n * @param {T} value - The value to return from the new function.\n * @returns {() => T} Returns the new constant function.\n */\nexport function constant<T>(value: T): () => T;\n\n/**\n * Creates a new function that always returns `value`.\n *\n * @template T - The type of the value to return.\n * @param {T} value - The value to return from the new function.\n * @returns {() => T | undefined} Returns the new constant function.\n *\n * @example\n * const object = { a: 1 };\n * const returnsObject = constant(object);\n *\n * returnsObject(); // => { a: 1 }\n * returnsObject() === object; // => true\n */\nexport function constant<T>(value?: T): () => T | undefined {\n  return () => value;\n}\n","/**\n * Returns the default value for `null`, `undefined`, and `NaN`.\n *\n * @template T - The type of the value parameter\n * @param {T | null | undefined} value - The value to check.\n * @param {T} defaultValue - The default value to return if the first value is null, undefined, or NaN.\n * @returns {T} Returns either the first value or the default value.\n */\nexport function defaultTo<T>(value: T | null | undefined, defaultValue: T): T;\n\n/**\n * Returns the default value for `null`, `undefined`, and `NaN`.\n *\n * @template T - The type of the value parameter\n * @template D - The type of the defaultValue parameter\n * @param {T | null | undefined} value - The value to check.\n * @param {D} defaultValue - The default value to return if the first value is null, undefined, or NaN.\n * @returns {T | D} Returns either the first value or the default value.\n */\nexport function defaultTo<T, D>(value: T | null | undefined, defaultValue: D): T | D;\n\n/**\n * Returns the default value for `null`, `undefined`, and `NaN`.\n *\n * @template T - The type of the value parameter\n * @template D - The type of the defaultValue parameter\n * @param {T | null | undefined} value - The value to check.\n * @param {T | D} defaultValue - The default value to return if the first value is null, undefined, or NaN.\n * @returns {T | D} Returns either the first value or the default value.\n *\n * @example\n * defaultTo(null, 'default') // returns 'default'\n * defaultTo(undefined, 42) // returns 42\n * defaultTo(NaN, 0) // returns 0\n * defaultTo('actual', 'default') // returns 'actual'\n * defaultTo(123, 0) // returns 123\n */\nexport function defaultTo<T, D>(value: T | null | undefined, defaultValue: D): T | D {\n  if (value == null || Number.isNaN(value)) {\n    return defaultValue;\n  }\n\n  return value;\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is greater than other.\n *\n * @param {any} value The value to compare.\n * @param {any} other The other value to compare.\n * @returns {boolean} Returns `true` if value is greater than other, else `false`.\n *\n * @example\n * gt(3, 1); // true\n * gt(3, 3); // false\n * gt(1, 3); // false\n */\nexport function gt(value: any, other: any): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value > other;\n  }\n\n  return toNumber(value) > toNumber(other);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is greater than or equal to other.\n *\n * @param {any} value The value to compare.\n * @param {any} other The other value to compare.\n * @returns {boolean} Returns `true` if value is greater than or equal to other, else `false`.\n *\n * @example\n * gte(3, 1); // => true\n * gte(3, 3); // => true\n * gte(1, 3); // => false\n */\nexport function gte(value: any, other: any): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value >= other;\n  }\n\n  return toNumber(value) >= toNumber(other);\n}\n","import { toPath } from './toPath.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { last } from '../array/last.ts';\nimport { get } from '../object/get.ts';\n\n/**\n * Invokes the method at `path` of `object` with the given arguments.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path of the method to invoke.\n * @param {any[]} args - The arguments to invoke the method with.\n * @returns {any} - Returns the result of the invoked method.\n *\n * @example\n * const object = {\n *   a: {\n *     b: function (x, y) {\n *       return x + y;\n *     }\n *   }\n * };\n *\n * invoke(object, 'a.b', [1, 2]); // => 3\n * invoke(object, ['a', 'b'], [1, 2]); // => 3\n */\nexport function invoke(object: any, path: PropertyKey | readonly PropertyKey[], ...args: any[]): any {\n  args = args.flat(1);\n\n  if (object == null) {\n    return;\n  }\n\n  switch (typeof path) {\n    case 'string': {\n      if (typeof object === 'object' && Object.hasOwn(object, path)) {\n        return invokeImpl(object, [path], args);\n      }\n      return invokeImpl(object, toPath(path), args);\n    }\n    case 'number':\n    case 'symbol': {\n      return invokeImpl(object, [path], args);\n    }\n    default: {\n      if (Array.isArray(path)) {\n        return invokeImpl(object, path, args);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        return invokeImpl(object, [path], args);\n      }\n    }\n  }\n}\n\nfunction invokeImpl(object: unknown, path: PropertyKey[], args: any[]) {\n  const parent = get(object, path.slice(0, -1), object);\n\n  if (parent == null) {\n    return undefined;\n  }\n\n  let lastKey = last(path);\n  const lastValue = lastKey?.valueOf();\n\n  if (typeof lastValue === 'number') {\n    lastKey = toKey(lastValue);\n  } else {\n    lastKey = String(lastKey);\n  }\n\n  const func = get(parent, lastKey as PropertyKey);\n\n  return func?.apply(parent, args);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is less than other.\n *\n * @param {any} value The value to compare.\n * @param {any} other The other value to compare.\n * @returns {boolean} Returns `true` if value is less than other, else `false`.\n *\n * @example\n * lt(1, 3); // true\n * lt(3, 3); // false\n * lt(3, 1); // false\n */\nexport function lt(value: any, other: any): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value < other;\n  }\n\n  return toNumber(value) < toNumber(other);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Checks if value is less than or equal to other.\n *\n * @param {any} value The value to compare.\n * @param {any} other The other value to compare.\n * @returns {boolean} Returns `true` if value is less than or equal to other, else `false`.\n *\n * @example\n * lte(1, 3); // => true\n * lte(3, 3); // => true\n * lte(3, 1); // => false\n */\nexport function lte(value: any, other: any): boolean {\n  if (typeof value === 'string' && typeof other === 'string') {\n    return value <= other;\n  }\n\n  return toNumber(value) <= toNumber(other);\n}\n","import { invoke } from './invoke.ts';\n\n/**\n * Creates a function that invokes the method at `path` of a given object with the provided arguments.\n *\n * @param {PropertyKey | PropertyKey[]} path - The path of the method to invoke.\n * @param {...any} args - The arguments to invoke the method with.\n * @returns {(object?: unknown) => any} - Returns a new function that takes an object and invokes the method at `path` with `args`.\n *\n * @example\n * const object = {\n *   a: {\n *     b: function (x, y) {\n *       return x + y;\n *     }\n *   }\n * };\n *\n * const add = method('a.b', 1, 2);\n * console.log(add(object)); // => 3\n */\nexport function method(path: PropertyKey | readonly PropertyKey[], ...args: any[]): (object: any) => any {\n  return function (object?: unknown) {\n    return invoke(object, path, args);\n  };\n}\n","import { invoke } from './invoke.ts';\n\n/**\n * Creates a function that invokes the method at a given path of `object` with the provided arguments.\n *\n * @param {object} object - The object to query.\n * @param {...any} args - The arguments to invoke the method with.\n * @returns {(path: PropertyKey | PropertyKey[]) => any} - Returns a new function that takes a path and invokes the method at `path` with `args`.\n *\n * @example\n * const object = {\n *  a: {\n *   b: function (x, y) {\n *    return x + y;\n *    }\n *   }\n * };\n *\n * const add = methodOf(object, 1, 2);\n * console.log(add('a.b')); // => 3\n */\nexport function methodOf(object: object, ...args: any[]): (path: PropertyKey | readonly PropertyKey[]) => any {\n  return function (path: PropertyKey | readonly PropertyKey[]) {\n    return invoke(object, path, args);\n  };\n}\n","/**\n * Returns the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC.\n *\n * @returns {number} The current time in milliseconds.\n *\n * @example\n * const currentTime = now();\n * console.log(currentTime); // Outputs the current time in milliseconds\n *\n * @example\n * const startTime = now();\n * // Some time-consuming operation\n * const endTime = now();\n * console.log(`Operation took ${endTime - startTime} milliseconds`);\n */\nexport function now(): number {\n  return Date.now();\n}\n","import { iteratee } from '../util/iteratee.ts';\n\n/**\n * Creates a function that invokes given functions and returns their results as an array.\n *\n * @param {Array<Iteratee | Iteratee[]>} iteratees - The iteratees to invoke.\n * @returns {(...args: any[]) => unknown[]} Returns the new function.\n *\n * @example\n * const func = over([Math.max, Math.min]);\n * const func2 = over(Math.max, Math.min); // same as above\n * func(1, 2, 3, 4);\n * // => [4, 1]\n * func2(1, 2, 3, 4);\n * // => [4, 1]\n *\n * const func = over(['a', 'b']);\n * func({ a: 1, b: 2 });\n * // => [1, 2]\n *\n * const func = over([{ a: 1 }, { b: 2 }]);\n * func({ a: 1, b: 2 });\n * // => [true, false]\n *\n * const func = over([['a', 1], ['b', 2]]);\n * func({ a: 1, b: 2 });\n * // => [true, true]\n */\nexport function over<T>(\n  ...iteratees: Array<((...args: any[]) => T) | ReadonlyArray<(...args: any[]) => T>>\n): (...args: any[]) => T[] {\n  if (iteratees.length === 1 && Array.isArray(iteratees[0])) {\n    iteratees = iteratees[0];\n  }\n\n  const funcs = iteratees.map(item => iteratee(item as Iteratee));\n\n  return function (this: unknown, ...args: unknown[]) {\n    return funcs.map(func => func.apply(this, args));\n  };\n}\n\ntype Iteratee = Parameters<typeof iteratee>[0];\n","import { iteratee as createIteratee } from './iteratee.ts';\n\n/**\n * Creates a predicate function that checks if a value satisfies all of the given predicates.\n *\n * @template T - The type of the value to be checked.\n * @template U - The first possible type that the value could match.\n * @template V - The second possible type that the value could match.\n *\n * @param {(value: T) => value is U} predicate1 - A function that checks if the value matches type `U`.\n * @param {(value: T) => value is V} predicate2 - A function that checks if the value matches type `V`.\n *\n * @returns {(value: T) => value is U & V} A function that takes a value and returns `true` if all predicates return truthy.\n *\n * @example\n * const func = overEvery(\n *   (value) => typeof value === 'string',\n *   (value) => value === 'hello'\n * );\n *\n * func(\"hello\"); // true\n * func(\"world\"); // false\n * func(42); // false\n */\nexport function overEvery<T, U extends T, V extends T>(\n  predicate1: (value: T) => value is U,\n  predicate2: (value: T) => value is V\n): (value: T) => value is U & V;\n\n/**\n * Creates a function that checks if all of the given predicates return truthy for the provided values.\n *\n * @template T - The type of the values to be checked.\n *\n * @param {...Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>} predicates -\n *   A list of predicates or arrays of predicates. Each predicate is a function that takes one or more values of\n *   type `T` and returns a boolean indicating whether the condition is satisfied for those values.\n *\n * @returns {(...values: T[]) => boolean} A function that takes a list of values and returns `true` if all of the\n *   predicates return truthy for the provided values, and `false` otherwise.\n *\n * @example\n * const func = overEvery(\n *   (value) => typeof value === 'string',\n *   (value) => value.length > 3\n * );\n *\n * func(\"hello\"); // true\n * func(\"hi\"); // false\n * func(42); // false\n *\n * @example\n * const func = overEvery([\n *   (value) => value.a > 0,\n *   (value) => value.b > 0\n * ]);\n *\n * func({ a: 1, b: 2 }); // true\n * func({ a: 0, b: 2 }); // false\n *\n * @example\n * const func = overEvery(\n *   (a, b) => typeof a === 'string' && typeof b === 'string',\n *   (a, b) => a.length > 3 && b.length > 3\n * );\n *\n * func(\"hello\", \"world\"); // true\n * func(\"hi\", \"world\"); // false\n * func(1, 10); // false\n */\nexport function overEvery<T>(\n  ...predicates: Array<((...args: T[]) => boolean) | ReadonlyArray<(...args: T[]) => boolean>>\n): (...args: T[]) => boolean;\n\n/**\n * Creates a function that checks if all of the given predicates return truthy for the provided values.\n *\n * This function takes multiple predicates, which can either be individual predicate functions or arrays of predicates,\n * and returns a new function that checks if all of the predicates return truthy when called with the provided values.\n *\n * @template T - The type of the values to be checked.\n *\n * @param {...Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>} predicates -\n *   A list of predicates or arrays of predicates. Each predicate is a function that takes one or more values of\n *   type `T` and returns a boolean indicating whether the condition is satisfied for those values.\n *\n * @returns {(...values: T[]) => boolean} A function that takes a list of values and returns `true` if all of the\n *   predicates return truthy for the provided values, and `false` otherwise.\n *\n * @example\n * const func = overEvery(\n *   (value) => typeof value === 'string',\n *   (value) => value.length > 3\n * );\n *\n * func(\"hello\"); // true\n * func(\"hi\"); // false\n * func(42); // false\n *\n * @example\n * const func = overEvery([\n *   (value) => value.a > 0,\n *   (value) => value.b > 0\n * ]);\n *\n * func({ a: 1, b: 2 }); // true\n * func({ a: 0, b: 2 }); // false\n *\n * @example\n * const func = overEvery(\n *   (a, b) => typeof a === 'string' && typeof b === 'string',\n *   (a, b) => a.length > 3 && b.length > 3\n * );\n *\n * func(\"hello\", \"world\"); // true\n * func(\"hi\", \"world\"); // false\n * func(1, 10); // false\n */\nexport function overEvery<T>(\n  ...predicates: Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>\n): (...values: T[]) => boolean {\n  return function (this: any, ...values: T[]) {\n    for (let i = 0; i < predicates.length; ++i) {\n      const predicate = predicates[i];\n\n      if (!Array.isArray(predicate)) {\n        if (!createIteratee(predicate).apply(this, values)) {\n          return false;\n        }\n        continue;\n      }\n\n      for (let j = 0; j < predicate.length; ++j) {\n        if (!createIteratee(predicate[j]).apply(this, values)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n}\n","import { iteratee as createIteratee } from './iteratee.ts';\n\n/**\n * Creates a predicate function that checks if a value satisfies at least one of the given predicates.\n *\n * @template T - The type of the value to be checked.\n * @template U - The first possible type that the value could match.\n * @template V - The second possible type that the value could match.\n *\n * @param {(value: T) => value is U} predicate1 - A function that checks if the value matches type `U`.\n * @param {(value: T) => value is V} predicate2 - A function that checks if the value matches type `V`.\n *\n * @returns {(value: T) => value is U | V} A function that takes a value and returns `true` if any predicates return truthy.\n *\n * @example\n * const func = overSome(\n *   (value) => typeof value === 'string',\n *   (value) => typeof value === 'number'\n * );\n *\n * func(\"hello\"); // true\n * func(42); // true\n * func([]); // false\n */\nexport function overSome<T, U extends T, V extends T>(\n  predicate1: (value: T) => value is U,\n  predicate2: (value: T) => value is V\n): (value: T) => value is U | V;\n\n/**\n * Creates a function that checks if any of the given predicates return truthy for the provided values.\n *\n * @template T - The type of the values to be checked.\n *\n * @param {...Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>} predicates -\n *   A list of predicates or arrays of predicates. Each predicate is a function that takes one or more values of\n *   type `T` and returns a boolean indicating whether the condition is satisfied for those values.\n *\n * @returns {(...values: T[]) => boolean} A function that takes a list of values and returns `true` if any of the\n *   predicates return truthy for the provided values, and `false` otherwise.\n *\n * @example\n * const func = overSome(\n *   (value) => typeof value === 'string',\n *   (value) => typeof value === 'number',\n *   (value) => typeof value === 'symbol'\n * );\n *\n * func(\"hello\"); // true\n * func(42); // true\n * func(Symbol()); // true\n * func([]); // false\n *\n * @example\n * const func = overSome([\n *   (value) => value.a > 0,\n *   (value) => value.b > 0\n * ]);\n *\n * func({ a: 0, b: 2 }); // true\n * func({ a: 0, b: 0 }); // false\n *\n * @example\n * const func = overSome(\n *   (a, b) => typeof a === 'string' && typeof b === 'string',\n *   (a, b) => a > 0 && b > 0\n * );\n *\n * func(\"hello\", \"world\"); // true\n * func(1, 10); // true\n * func(0, 2); // false\n */\nexport function overSome<T>(\n  ...predicates: Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>\n): (...values: T[]) => boolean;\n\n/**\n * Creates a function that checks if any of the given predicates return truthy for the provided values.\n *\n * This function takes multiple predicates, which can either be individual predicate functions or arrays of predicates,\n * and returns a new function that checks if any of the predicates return truthy when called with the provided values.\n *\n * @template T - The type of the values to be checked.\n *\n * @param {...Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>} predicates -\n *   A list of predicates or arrays of predicates. Each predicate is a function that takes one or more values of\n *   type `T` and returns a boolean indicating whether the condition is satisfied for those values.\n *\n * @returns {(...values: T[]) => boolean} A function that takes a list of values and returns `true` if any of the\n *   predicates return truthy for the provided values, and `false` otherwise.\n *\n * @example\n * const func = overSome(\n *   (value) => typeof value === 'string',\n *   (value) => typeof value === 'number',\n *   (value) => typeof value === 'symbol'\n * );\n *\n * func(\"hello\"); // true\n * func(42); // true\n * func(Symbol()); // true\n * func([]); // false\n *\n * @example\n * const func = overSome([\n *   (value) => value.a > 0,\n *   (value) => value.b > 0\n * ]);\n *\n * func({ a: 0, b: 2 }); // true\n * func({ a: 0, b: 0 }); // false\n *\n * @example\n * const func = overSome(\n *   (a, b) => typeof a === 'string' && typeof b === 'string',\n *   (a, b) => a > 0 && b > 0\n * );\n *\n * func(\"hello\", \"world\"); // true\n * func(1, 10); // true\n * func(0, 2); // false\n */\nexport function overSome<T>(\n  ...predicates: Array<((...values: T[]) => boolean) | ReadonlyArray<(...values: T[]) => boolean>>\n): (...values: T[]) => boolean {\n  return function (this: any, ...values: T[]) {\n    for (let i = 0; i < predicates.length; ++i) {\n      const predicate = predicates[i];\n\n      if (!Array.isArray(predicate)) {\n        if (createIteratee(predicate).apply(this, values)) {\n          return true;\n        }\n        continue;\n      }\n\n      for (let j = 0; j < predicate.length; ++j) {\n        if (createIteratee(predicate[j]).apply(this, values)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n}\n","/**\n * Returns a new empty array.\n *\n * @returns {Array} A new empty array.\n * @example\n * stubArray() // Returns []\n */\nexport function stubArray(): any[];\n\nexport function stubArray(): any[] {\n  return [];\n}\n","/**\n * Returns false.\n *\n * @returns {boolean} false.\n * @example\n * stubFalse() // Returns false\n */\nexport function stubFalse(): false;\n\n/**\n * Returns false.\n *\n * @returns {boolean} false.\n * @example\n * stubFalse() // Returns false\n */\nexport function stubFalse(): false;\n\nexport function stubFalse(): false {\n  return false;\n}\n","/**\n * Returns an empty object.\n *\n * @returns {Object} An empty object.\n * @example\n * stubObject() // Returns {}\n */\nexport function stubObject(): any {\n  return {};\n}\n","/**\n * Returns an empty string.\n *\n * @returns {string} An empty string.\n * @example\n * stubString() // Returns ''\n */\nexport function stubString(): string;\n\nexport function stubString(): string {\n  return '';\n}\n","/**\n * Returns true.\n *\n * @returns {boolean} true.\n * @example\n * stubTrue() // Returns true\n */\nexport function stubTrue(): true;\n\n/**\n * Returns true.\n *\n * @returns {boolean} true.\n * @example\n * stubTrue() // Returns true\n */\nexport function stubTrue(): true;\n\nexport function stubTrue(): true {\n  return true;\n}\n","import { MAX_ARRAY_LENGTH } from '../_internal/MAX_ARRAY_LENGTH.ts';\nimport { clamp } from '../math/clamp.ts';\n\n/**\n * Converts the value to a valid index. A valid index is an integer that is greater than or equal to `0` and less than or equal to `2^32 - 1`.\n *\n * It converts the given value to a number and floors it to an integer. If the value is less than `0`, it returns `0`. If the value exceeds `2^32 - 1`, it returns `2^32 - 1`.\n *\n * @param {unknown} value - The value to convert to a valid index.\n * @returns {number} The converted value.\n *\n * @example\n * toLength(3.2)  // => 3\n * toLength(-1)   // => 0\n * toLength(1.9)  // => 1\n * toLength('42') // => 42\n * toLength(null) // => 0\n */\nexport function toLength(value: any): number {\n  if (value == null) {\n    return 0;\n  }\n\n  const length = Math.floor(Number(value));\n\n  return clamp(length, 0, MAX_ARRAY_LENGTH);\n}\n","export const MAX_ARRAY_LENGTH = 4_294_967_295;\n","import { keysIn } from '../object/keysIn.ts';\n\n/**\n * Converts value to a plain object flattening inherited enumerable string keyed properties of value to own properties of the plain object.\n *\n * @param {any} value The value to convert.\n * @returns {any} Returns the converted plain object.\n *\n * @example\n * function Foo() {\n *   this.b = 2;\n * }\n * Foo.prototype.c = 3;\n * toPlainObject(new Foo()); // { b: 2, c: 3 }\n */\nexport function toPlainObject(value?: any): any {\n  const plainObject: Record<string, any> = {};\n  const valueKeys = keysIn(value);\n\n  for (let i = 0; i < valueKeys.length; i++) {\n    const key = valueKeys[i];\n    const objValue = (value as any)[key];\n    if (key === '__proto__') {\n      Object.defineProperty(plainObject, key, {\n        configurable: true,\n        enumerable: true,\n        value: objValue,\n        writable: true,\n      });\n    } else {\n      plainObject[key] = objValue;\n    }\n  }\n  return plainObject;\n}\n","export const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n","import { toInteger } from './toInteger.ts';\nimport { MAX_SAFE_INTEGER } from '../_internal/MAX_SAFE_INTEGER.ts';\nimport { clamp } from '../math/clamp.ts';\n\n/**\n * Converts `value` to a safe integer.\n *\n * A safe integer can be compared and represented correctly.\n *\n * @param {any} value - The value to convert.\n * @returns {number} Returns the value converted to a safe integer.\n *\n * @example\n * toSafeInteger(3.2); // => 3\n * toSafeInteger(Number.MAX_VALUE); // => 9007199254740991\n * toSafeInteger(Infinity); // => 9007199254740991\n * toSafeInteger('3.2'); // => 3\n * toSafeInteger(NaN); // => 0\n * toSafeInteger(null); // => 0\n * toSafeInteger(-Infinity); // => -9007199254740991\n */\nexport function toSafeInteger(value: any): number {\n  if (value == null) {\n    return 0;\n  }\n\n  return clamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n}\n","/** Counter used to generate unique numeric identifiers. */\nlet idCounter = 0;\n\n/**\n * Generates a unique identifier, optionally prefixed with a given string.\n *\n * @param {string} [prefix] - An optional string to prefix the unique identifier.\n *                            If not provided or not a string, only the unique\n *                            numeric identifier is returned.\n * @returns {string} A string containing the unique identifier, with the optional\n *                   prefix if provided.\n *\n * @example\n * // Generate a unique ID with a prefix\n * uniqueId('user_');  // => 'user_1'\n *\n * @example\n * // Generate a unique ID without a prefix\n * uniqueId();  // => '2'\n *\n * @example\n * // Subsequent calls increment the internal counter\n * uniqueId('item_');  // => 'item_3'\n * uniqueId();         // => '4'\n */\nexport function uniqueId(prefix = ''): string {\n  const id = ++idCounter;\n\n  return `${prefix}${id}`;\n}\n","import * as compat from './compat.ts';\n\ntype ToolkitFn = (value: any) => any;\n\ntype Compat = typeof compat;\n\nexport interface Toolkit extends ToolkitFn, Compat {}\n\n// Cast the initial function to the combined Toolkit type\nexport const toolkit: Toolkit = ((value: any) => {\n  return value;\n}) as Toolkit;\n\n// Assign properties from compat module\nObject.assign(toolkit, compat);\n\n// Set the placeholder for partial and partialRight\ntoolkit.partial.placeholder = toolkit;\ntoolkit.partialRight.placeholder = toolkit;\n"],"names":["castArray","value","arguments","length","Array","isArray","toArray","from","isArrayLike","isLength","Number","isSafeInteger","chunk","arr","size","Math","max","floor","isInteger","Error","chunkLength","ceil","result","index","start","end","slice","chunkToolkit","compact","i","item","push","compactToolkit","flatten","depth","flooredDepth","recursive","currentDepth","concat","values","identity","x","isUnsafeProperty","key","isDeepKey","includes","toKey","Object","is","valueOf","String","toPath","deepKey","quoteChar","bracket","charCodeAt","char","get","object","path","defaultValue","undefined","getWithPath","current","property","isObject","isPrimitive","eq","other","isNaN","isMatchWith","target","source","compare","isMatch","isMatchWithInternal","doesMatch","objValue","srcValue","stack","isEqual","Boolean","Map","isObjectMatch","isArrayMatch","isMapMatch","sourceValue","entries","Set","isSetMatch","keys","has","set","delete","countedIndex","sourceItem","found","j","matches","add","getSymbols","getOwnPropertySymbols","filter","symbol","prototype","propertyIsEnumerable","call","getTag","toString","regexpTag","stringTag","numberTag","booleanTag","argumentsTag","symbolTag","dateTag","mapTag","setTag","arrayTag","functionTag","arrayBufferTag","objectTag","errorTag","dataViewTag","uint8ArrayTag","uint8ClampedArrayTag","uint16ArrayTag","uint32ArrayTag","bigUint64ArrayTag","int8ArrayTag","int16ArrayTag","int32ArrayTag","bigInt64ArrayTag","float32ArrayTag","float64ArrayTag","isTypedArray","ArrayBuffer","isView","DataView","cloneDeepWithImpl","valueToClone","keyToClone","objectToClone","cloneValue","cloned","hasOwn","input","Date","getTime","RegExp","flags","lastIndex","Buffer","isBuffer","subarray","getPrototypeOf","SharedArrayBuffer","buffer","byteOffset","byteLength","copyProperties","File","name","type","Blob","constructor","message","cause","isCloneableObject","create","descriptor","getOwnPropertyDescriptor","writable","cloneDeep","obj","cloneDeepWith","customizer","cloneDeepWithToolkit","Symbol","iterator","IS_UNSIGNED_INTEGER","isIndex","MAX_SAFE_INTEGER","test","isArguments","resolvedPath","matchesProperty","iteratee","countBy","collection","array","mapper","iterateeToolkit","difference","firstArr","secondArr","secondSet","isObjectLike","isArrayLikeObject","arr1","arr2","differenceToolkit","last","lastToolkit","flattenArrayLike","arrayLike","differenceBy","_values","mappedSecondSet","map","differenceByToolkit","createIteratee","differenceWith","comparator","flattenedValues","areItemsEqual","firstItem","every","secondItem","differenceWithToolkit","isSymbol","toNumber","NaN","toFinite","Infinity","MAX_VALUE","toInteger","finite","remainder","drop","itemsCount","guard","dropToolkit","dropRight","min","dropRightToolkit","dropRightWhile","canContinueDropping","predicate","dropRightWhileImpl","dropRightWhileToolkit","dropWhile","dropEndIndex","findIndex","dropWhileImpl","dropWhileToolkit","range","step","forEach","callback","forEachRight","isIterateeCall","isString","fill","finalStart","finalEnd","fillToolkit","find","_doesMatch","fromIndex","subArray","findLast","findLastIndex","head","headToolkit","isConcatSpreadable","flattenDepth","_iteratee","isNil","flatMap","flatMapDepth","flatMapDeep","flattenDeep","groupBy","_getKeyFromItem","getKeyFromItem","groupByToolkit","Reflect","indexOf","searchElement","initial","initialToolkit","intersection","uniq","arrays","intersectionToolkit","intersectionBy","lastValue","count","intersectionByToolkit","intersectionWith","some","uniqToolkit","otherArrs","_comparator","uniqPreserve0","pop","otherArr","intersectionWithToolkit","added","isPlainObject","proto","isEqualWith","a","b","areValuesEqual","isEqualWithImpl","aParent","bParent","areObjectsEqual","aTag","bTag","aStack","bStack","aValues","bValues","aValue","bValue","splice","Uint8Array","aKeys","bKeys","propKey","aProp","noop","isFunction","isNull","isUndefined","invokeMap","args","apply","method","thisContext","pathExceptLast","split","join","separator","reduce","accumulator","startIndex","keyBy","keyFn","lastIndexOf","nth","n","getPriority","compareValues","order","aPriority","bPriority","regexIsDeepProp","regexIsPlainProp","isKey","orderBy","criteria","orders","getValueByNestedPath","preparedCriteria","criterion","original","getValueByCriterion","sort","comparedResult","partition","matched","unmatched","pull","valuesToRemove","valuesSet","resultIndex","pullToolkit","pullAll","pullAllBy","_getValue","getValue","pullAllWith","copyArray","resultLength","valuesArray","hasUndefined","at","paths","allPaths","unset","unsetWithPath","parent","lastKey","pullAt","_indices","indices","indicesToPull","reduceRight","reverse","negate","func","TypeError","this","reject","remove","shouldRemoveElement","originalArr","removed","removeToolkit","sample","random","sampleToolkit","minimum","maximum","randomInt","clamp","bound1","bound2","clampToolkit","isMap","isMapToolKit","sampleSize","arrayCollection","selected","sampleSizeToolkit","shuffle","shuffleToolkit","matchFunc","propFunc","sortBy","MAX_ARRAY_INDEX","MAX_ARRAY_LENGTH","sortedIndexBy","retHighest","low","high","iterateeFunction","transformedValue","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","setLow","mid","computed","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","isNumber","HALF_MAX_ARRAY_LENGTH","sortedIndex","compute","sortedIndexOf","sortedLastIndexBy","sortedLastIndex","sortedLastIndexOf","tail","tailToolkit","take","takeToolkit","takeRight","takeRightToolkit","takeRightWhile","_array","takeWhile","union","uniqBy","unionBy","flattened","uniqWith","v","unionWith","uniqByToolkit","uniqWithToolkit","unzip","zipped","maxLen","unzipToolkit","unzipWith","unziped","without","withoutToolkit","xor","itemCounts","itemSet","windowed","partialWindows","xorBy","xorWith","zip","arrs","rowCount","columnCount","row","zipToolkit","group","assignValue","zipObject","updateWith","updater","newValue","customizerResult","zipObjectDeep","zipWith","combine","after","ary","aryToolkit","attempt","e","before","bind","thisObj","partialArgs","bound","providedArgs","arg","placeholder","bindPlaceholder","bindKey","bindKeyPlaceholder","curry","arity","parseInt","wrapper","holders","makeCurry","curryPlaceholder","composeArgs","curryRight","makeCurryRight","curryRightPlaceholder","placeholderLength","rangeLength","providedIndex","debounce","debounceMs","signal","edges","pendingThis","pendingArgs","leading","trailing","invoke","timeoutId","schedule","clearTimeout","setTimeout","cancel","onTimerEnd","cancelTimer","debounced","aborted","isFirstCall","flush","addEventListener","once","options","maxWait","pendingAt","_debounced","debounceToolkit","now","defer","delay","wait","flip","flow","funcs","flattenFuncs","flowToolkit","flowRight","flowRightToolkit","memoize","resolver","memoized","cache","CacheConstructor","Cache","nthArg","called","onceToolkit","overArgs","_transforms","transforms","flat","transformedArgs","transform","partial","partialImpl","partialed","providedArgsIndex","substitutedArgs","remainingArgs","partialRight","partialRightImpl","partialedRight","rearg","flattenIndices","reorderedArgs","rest","params","restToolkit","spread","argsIndex","throttle","throttleMs","unary","wrap","decimalAdjust","number","precision","magnitude","exponent","adjustedValue","newMagnitude","newExponent","divide","inRange","inRangeToolkit","items","maxResult","maxBy","maxElement","element","maxByToolkit","sumBy","sum","mean","nums","meanBy","meanByToolkit","minResult","minBy","minElement","minByToolkit","multiply","string","radix","floating","randomToolkit","randomIntToolkit","rangeRight","round","subtract","_","isPrototype","isTypedArrayToolkit","times","arrayLikeKeys","filteredKeys","assign","sources","assignImpl","keysToolkit","keysIn","arrayLikeKeysIn","keysInImpl","prototypeKeysIn","assignIn","assignInImpl","assignInWith","getValueToAssign","assignInWithImpl","assignWith","assignWithImpl","clone","tag","typedArray","Ctor","dataView","clonedBuffer","srcView","cloneStringObjectProperties","stringLength","copyOwnProperties","regExp","copyPrototype","setPrototypeOf","copySymbolProperties","symbols","cloneWith","properties","propsKeys","propsValue","defaults","objectProto","toStringTag","defaultsDeep","defaultsDeepRecursive","WeakMap","targetValue","inStack","newObj","findKey","findKeyToolkit","findLastKey","forIn","forInRight","forOwn","iterable","forOwnRight","fromPairs","pairs","functions","functionsIn","hasIn","invert","invertToolkit","invertBy","getString","valueStr","mapKeys","getNewKey","mapKeysToolkit","mapValues","getNewValue","mapValuesToolkit","mergeWith","otherArgs","merge","mergeWithDeep","Constructor","newRegExp","newError","lastModified","newObject","sourceKeys","targetKeys","ownKeys","targetKey","merged","omit","keysArr","getSymbolsIn","omitBy","shouldOmit","pick","pickBy","shouldPick","propertyOf","pathLength","setWith","customizerFn","toDefaulted","mapToEntries","next","setToEntries","toPairs","toPairsIn","keysInToolkit","isBufferToolkit","isArrayOrBufferOrTypedArray","update","valuesIn","functionToString","Function","IS_NATIVE_FUNCTION_REGEXP","hasOwnProperty","replace","isNative","globalThis","isUndefinedToolkit","conformsTo","conforms","isArrayBuffer","isArrayBufferToolkit","isBoolean","isDate","isDateToolkit","isElement","nodeType","isEmpty","counter","isEqualWithToolkit","isError","isFinite","isRegExp","isRegExpToolkit","isSet","isSetToolkit","isWeakMap","isWeakMapToolkit","isWeakSet","WeakSet","isWeakSetToolkit","capitalize","str","charAt","toUpperCase","toLowerCase","capitalizeToolkit","bindAll","methodNames","methods","stringKey","CASE_SPLIT_PATTERN","words","match","normalizeForCase","camelCase","getWords","first","word","camelCaseToolkit","deburrMap","deburr","normalize","deburrToolkit","endsWith","position","htmlEscapes","escape","escapeToolkit","escapeRegExp","escapeRegExpToolkit","kebabCase","kebabCaseToolkit","lowerCase","lowerCaseToolkit","lowerFirst","substring","lowerFirstToolkit","pad","chars","padStart","padEnd","padToolkit","repeat","pattern","replacement","snakeCase","snakeCaseToolkit","limit","startCase","trim","startsWith","esTemplateRegExp","unEscapedRegExp","noMatchExp","escapeMap","escapeString","templateSettings","evaluate","interpolate","variable","imports","template","delimitersRegExp","isEvaluated","matchAll","fullMatch","escapeValue","interpolateValue","esTemplateValue","evaluateValue","importsKeys","importValues","sourceURL","compiledFunction","toLower","toUpper","trimEnd","endIndex","trimStart","trimToolkit","trimEndToolkit","trimStartToolkit","regexMultiByte","truncate","omission","parseLength","lengthOmission","lengthBase","strArray","base","search","withoutSeparator","exec","groups","htmlUnescapes","unescape","unescapeToolkit","upperCase","upperCaseToolkit","upperFirst","upperFirstToolkit","rUnicodeUpper","rUnicodeLower","rMisc","rNumber","rUnicodeOptContrLower","rUnicodeOptContrUpper","rUnicodeBreak","rUnicodeMiscLower","rUnicodeWord","cond","processedPairs","pair","constant","defaultTo","gt","gte","invokeImpl","lt","lte","methodOf","over","iteratees","overEvery","predicates","overSome","stubArray","stubFalse","stubObject","stubString","stubTrue","toLength","toPlainObject","plainObject","valueKeys","defineProperty","configurable","enumerable","toSafeInteger","idCounter","uniqueId","prefix","toolkit","compat"],"mappings":"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"}