{"version":3,"file":"index.umd.cjs","sources":["../src/lifecycle/LifeCycleElementSemaphore.ts","../src/context/setCKEditorReactContextMetadata.ts","../src/hooks/useIsMountedRef.ts","../src/hooks/useRefSafeCallback.ts","../src/context/useInitializedCKEditorsMap.ts","../src/context/ckeditorcontext.tsx","../src/plugins/ReactIntegrationUsageDataPlugin.ts","../src/plugins/appendAllIntegrationPluginsToConfig.ts","../src/ckeditor.tsx","../src/lifecycle/useLifeCycleSemaphoreSyncRef.tsx","../src/utils/mergeRefs.ts","../src/hooks/useInstantEffect.ts","../src/hooks/useInstantEditorEffect.ts","../src/useMultiRootEditor.tsx","../src/hooks/useIsUnmountedRef.ts","../src/hooks/useAsyncCallback.ts","../src/hooks/useAsyncValue.ts","../src/cloud/useCKEditorCloud.tsx","../src/cloud/withCKEditorCloud.tsx"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { createDefer, once, type Defer } from '@ckeditor/ckeditor5-integrations-common';\n\n/**\n * This class is utilized to pause the initialization of an editor when another instance is already present on a specified element.\n * It is engineered to address the following issues:\n *\n *\t* Rapid changes in component properties often lead to the re-initialization of the editor, which can trigger\n *\t  the `editor-source-element-already-used` exception. This occurs because the editor is still in the process of initializing\n *\t  when the component decides to destroy it. This semaphore waits for the editor to fully initialize before destroying it, thereby\n *\t  allowing a new instance of the editor to be attached to the specified element.\n *\n *\t* Rapid mounting and unmounting in strict mode frequently results in the `editor-source-element-already-used` exception\n *\t  being thrown by the editor. This is due to React reusing the underlying DOM element during the mounting and unmounting of components\n *\t  (especially if the same component is being mounted and unmounted). Consequently, a race condition arises. The first render begins to\n *\t  attach the editor (in async mode), and shortly thereafter, it is destroyed and a new instance of the component is initialized.\n *\t  This semaphore, by utilizing a static semaphores promises map, retains information about whether the element is used by a previous\n *\t  instance of the editor and resumes execution when it is freed.\n *\n *\t* The process involves starting up many editors that are no longer needed and are immediately removed in the following rerenders.\n *\t  This can cause the editorâ€™s initialization performance to slow down. The initialization of the editor is skipped when numerous\n *\t  rerenders occur within a short time-frame while using this semaphore. An example of this could be a situation with 4 rerenders\n *\t  occurring within a 10ms period. This semaphore will likely batch these calls, and instead of initializing 4 editors, only 2 will be\n *\t  initialized (the first and the last one).\n */\nexport class LifeCycleElementSemaphore<R> {\n\t/**\n\t * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n\t * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n\t * editor instances on an element that is already in use by another instance. The process works as follows:\n\t *\n\t * \t1. If an element is being used by an editor, then the initialization of a new editor\n\t * \t   instance is chained using the `.then()` method of the Promise.\n\t *\n\t * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n\t * \t   and the previously assigned `.then()` editor callback is executed.\n\t *\n\t *  @see {@link #lock} for more detailed information on the implementation.\n\t */\n\tprivate static readonly _semaphores = new Map<HTMLElement, Promise<void>>();\n\n\t/**\n\t * This should define async methods for initializing and destroying the editor.\n\t * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n\t *\n\t * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n\t */\n\tprivate readonly _lifecycle: LifeCycleAsyncOperators<R>;\n\n\t/**\n\t * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n\t * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n\t * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n\t * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n\t */\n\tprivate readonly _element: HTMLElement;\n\n\t/**\n\t * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n\t *\n\t * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n\t * \t  occupying the element), then it is null.\n\t *\n\t * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n\t * \t  resolved after the editor is destroyed.\n\t *\n\t * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n\t */\n\tprivate _releaseLock: Defer<void> | null = null;\n\n\t/**\n\t * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n\t * once the semaphore is released. It is utilized to store certain data that must be removed following\n\t * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n\t * or handles for additional window listeners.\n\t */\n\tprivate _value: R | null = null;\n\n\t/**\n\t * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n\t * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n\t * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n\t * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n\t */\n\tprivate _afterMountCallbacks: Array<LifeCycleAfterMountCallback<R>> = [];\n\n\t/**\n\t * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n\t * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n\t * should be destroyed.\n\t *\n\t * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n\t * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n\t * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n\t * \t  and simply release the semaphore.\n\t *\n\t *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n\t \t  the editor must be destroyed before the semaphore is released.\n\t*/\n\tprivate _state: LifeCycleState<R> = {\n\t\tdestroyedBeforeInitialization: false,\n\t\tmountingInProgress: null\n\t};\n\n\tconstructor( element: HTMLElement, lifecycle: LifeCycleAsyncOperators<R> ) {\n\t\tthis._element = element;\n\t\tthis._lifecycle = lifecycle;\n\t\tthis._lock();\n\t}\n\n\t/**\n\t * Getter for {@link #_value}.\n\t */\n\tpublic get value(): R | null {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Resets the semaphore to its initial state.\n\t */\n\tpublic discard(): void {\n\t\tthis._value = null;\n\t\tthis._releaseLock = null;\n\t\tthis._afterMountCallbacks = [];\n\t\tthis._state = {\n\t\t\tdestroyedBeforeInitialization: false,\n\t\t\tmountingInProgress: null\n\t\t};\n\t}\n\n\t/**\n\t * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n\t * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n\t * with a different one.\n\t */\n\tpublic unsafeSetValue( value: R ): void {\n\t\tthis._value = value;\n\n\t\tthis._afterMountCallbacks.forEach( callback => {\n\t\t\t// Check if value is valid before executing callback.\n\t\t\tif ( this._lifecycle.isValueValid && !this._lifecycle.isValueValid( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback( value );\n\t\t} );\n\n\t\tthis._afterMountCallbacks = [];\n\t}\n\n\t/**\n\t * This registers a callback that will be triggered after the editor has been successfully mounted.\n\t *\n\t * \t* If the editor is already mounted, the callback will be executed immediately.\n\t *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n\t* \t* If the editor is never mounted, the passed callback will not be executed.\n\t* \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n\t* \t* If the value is not valid (determined by isValueValid), the callback will not be executed.\n\t*/\n\tpublic runAfterMount( callback: LifeCycleAfterMountCallback<R> ): void {\n\t\tconst { _value, _afterMountCallbacks } = this;\n\n\t\tif ( _value ) {\n\t\t\t// Check if value is valid before executing callback.\n\t\t\tif ( this._lifecycle.isValueValid && !this._lifecycle.isValueValid( _value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback( _value );\n\t\t} else {\n\t\t\t_afterMountCallbacks.push( callback );\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to inform other components that the {@link #_element} will be used by the editor,\n\t * which is initialized by the {@link #_lifecycle} methods.\n\t *\n\t * \t* If an editor is already present on the provided element, the initialization of the current one\n\t * \t  will be postponed until the previous one is destroyed.\n\t *\n\t * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n\t * \t  be mounted immediately.\n\t *\n\t * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n\t * the `onReady` lifecycle method is called.\n\t *\n\t * *Important note:*\n\t *\n\t * Itâ€™s really important to keep this method *sync*. If we make this method *async*, it wonâ€™t work well because\n\t * it will cause problems when weâ€™re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tprivate _lock(): void {\n\t\tconst { _semaphores } = LifeCycleElementSemaphore;\n\t\tconst { _state, _element, _lifecycle } = this;\n\n\t\t// This promise signifies that the previous editor is still attached to the current element.\n\t\t// Upon successful resolution, it will indicate that it is safe to assume that the element has\n\t\t// no assigned editor instance and can be reinitialized.\n\t\tconst prevElementSemaphore = _semaphores.get( _element ) || Promise.resolve( null );\n\n\t\t// This is a lock that will be resolved after the `release` method is called. Due to this lock,\n\t\t// the promise will never be resolved until the editor is destroyed.\n\t\tconst releaseLock = createDefer();\n\t\tthis._releaseLock = releaseLock;\n\n\t\t// This is the initialization of the editor that occurs after the previous editor has been detached from the specified element.\n\t\t//\n\t\t// If the `release` method was called before the initialization of the current editor instance, then it will be skipped.\n\t\t// This situation occurs quite frequently when we have three or more rerenders in a row, and it doesn't make sense to initialize\n\t\t// the second editor because it will be overridden anyway by the third one.\n\t\tconst newElementSemaphore = prevElementSemaphore\n\t\t\t.then( () => {\n\t\t\t\tif ( _state.destroyedBeforeInitialization ) {\n\t\t\t\t\treturn Promise.resolve( undefined );\n\t\t\t\t}\n\n\t\t\t\t// This variable will be used later in the `release` method to determine\n\t\t\t\t// whether the editor is being destroyed prior to initialization.\n\t\t\t\t_state.mountingInProgress = _lifecycle.mount().then( mountResult => {\n\t\t\t\t\tif ( mountResult ) {\n\t\t\t\t\t\tthis.unsafeSetValue( mountResult );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn mountResult;\n\t\t\t\t} );\n\n\t\t\t\treturn _state.mountingInProgress;\n\t\t\t} )\n\t\t\t.then( async mountResult => {\n\t\t\t\t// Everything is fine, all ready callback might be fired here.\n\t\t\t\tif ( mountResult && _lifecycle.afterMount ) {\n\t\t\t\t\tawait _lifecycle.afterMount( {\n\t\t\t\t\t\telement: _element,\n\t\t\t\t\t\tmountResult\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// It will be released after destroying of editor by the {@link #_release method}.\n\t\t\t.then( () => releaseLock.promise )\n\n\t\t\t// Prevent hanging of semaphore during mount, just assume that everything is fine\n\t\t\t.catch( error => {\n\t\t\t\tconsole.error( 'CKEditor mounting error:', error );\n\t\t\t} )\n\n\t\t\t// Remove semaphore from map if released.\n\t\t\t.then( () => {\n\t\t\t\tif ( _semaphores.get( _element ) === newElementSemaphore ) {\n\t\t\t\t\t_semaphores.delete( _element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t_semaphores.set( _element, newElementSemaphore );\n\t}\n\n\t/**\n\t * Inverse of {@link #_lock} method that tries to destroy attached editor.\n\t *\n\t * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n\t * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n\t *\n\t * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n\t * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n\t *\n\t * *Important note:*\n\t *\n\t * Itâ€™s really important to keep this method *sync*. If we make this method *async*, it wonâ€™t work well because\n\t * it will cause problems when weâ€™re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tpublic readonly release = once( () => {\n\t\tconst { _releaseLock, _state, _element, _lifecycle } = this;\n\n\t\tif ( _state.mountingInProgress ) {\n\t\t\t_state.mountingInProgress\n\t\t\t\t.then( () => _lifecycle.unmount( {\n\t\t\t\t\telement: _element,\n\n\t\t\t\t\t// Mount result might be overridden by watchdog during restart so use instance variable.\n\t\t\t\t\tmountResult: this.value!\n\t\t\t\t} ) )\n\n\t\t\t\t// Prevent hanging of semaphore during unmount, just assume that everything is fine\n\t\t\t\t.catch( error => {\n\t\t\t\t\tconsole.error( 'CKEditor unmounting error:', error );\n\t\t\t\t} )\n\n\t\t\t\t.then( _releaseLock!.resolve )\n\t\t\t\t.then( () => {\n\t\t\t\t\tthis._value = null;\n\t\t\t\t} );\n\t\t} else {\n\t\t\t_state.destroyedBeforeInitialization = true;\n\t\t\t_releaseLock!.resolve();\n\t\t}\n\t} );\n}\n\nexport type LifeCycleAfterMountCallback<R> = ( mountResult: R ) => void;\n\ntype LifeCycleState<R> = {\n\tdestroyedBeforeInitialization: boolean;\n\tmountingInProgress: Promise<R> | null;\n};\n\ntype LifeCyclePostMountAttrs<R> = {\n\telement: HTMLElement;\n\tmountResult: R;\n};\n\nexport type LifeCycleAsyncOperators<R> = {\n\tmount: () => Promise<R>;\n\n\t/**\n\t * The optional method is called after the editor is mounted.\n\t * The result of the mount method is passed on as an argument.\n\t */\n\tafterMount?: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void> | void;\n\n\t/**\n\t * The unmount method is called when the editor is destroyed.\n\t * The result of the mount method is passed on as an argument.\n\t */\n\tunmount: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void>;\n\n\t/**\n\t * The optional method is used to check if the editor value is valid.\n\t * If this method returns false, callbacks registered with runAfterMount will not be executed.\n\t * This helps prevent errors in race conditions where the editor was destroyed during initialization.\n\t */\n\tisValueValid?: ( value: R ) => boolean;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { Config, EditorConfig } from 'ckeditor5';\n\n/**\n * The symbol cannot be used as a key because config getters require strings as keys.\n */\nconst ReactContextMetadataKey = '$__CKEditorReactContextMetadata';\n\n/**\n * Sets the metadata in the object.\n *\n * @param metadata The metadata to set.\n * @param object The object to set the metadata in.\n * @returns The object with the metadata set.\n */\nexport function withCKEditorReactContextMetadata(\n\tmetadata: CKEditorConfigContextMetadata,\n\tconfig: EditorConfig\n): EditorConfig & { [ ReactContextMetadataKey ]: CKEditorConfigContextMetadata } {\n\treturn {\n\t\t...config,\n\t\t[ ReactContextMetadataKey ]: metadata\n\t};\n}\n\n/**\n * Tries to extract the metadata from the object.\n *\n * @param object The object to extract the metadata from.\n */\nexport function tryExtractCKEditorReactContextMetadata( object: Config<any> ): CKEditorConfigContextMetadata | null {\n\treturn object.get( ReactContextMetadataKey );\n}\n\n/**\n * The metadata that is stored in the React context.\n */\nexport type CKEditorConfigContextMetadata = {\n\n\t/**\n\t * The name of the editor in the React context. It'll be later used in the `useInitializedCKEditorsMap` hook\n\t * to track the editor initialization and destruction events.\n\t */\n\tname?: string;\n\n\t/**\n\t * Any additional metadata that can be stored in the context.\n\t */\n\t[x: string | number | symbol]: unknown;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useEffect, useRef, type MutableRefObject } from 'react';\n\n/**\n * Custom hook that returns a mutable ref object indicating whether the component is mounted or not.\n *\n * @returns The mutable ref object.\n */\nexport const useIsMountedRef = (): MutableRefObject<boolean> => {\n\tconst mountedRef = useRef<boolean>( false );\n\n\tuseEffect( () => {\n\t\tmountedRef.current = true;\n\n\t\treturn () => {\n\t\t\tmountedRef.current = false;\n\t\t};\n\t}, [] );\n\n\treturn mountedRef;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useCallback, useRef } from 'react';\n\n/**\n * Hook that guarantees that returns constant reference for passed function.\n * Useful for preventing closures from capturing cached scope variables (avoiding the stale closure problem).\n */\nexport const useRefSafeCallback = <A extends Array<unknown>, R>( fn: ( ...args: A ) => R ): typeof fn => {\n\tconst callbackRef = useRef<typeof fn>();\n\tcallbackRef.current = fn;\n\n\treturn useCallback(\n\t\t( ...args: A ): R => ( callbackRef.current as typeof fn )( ...args ),\n\t\t[]\n\t);\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useEffect } from 'react';\nimport { useRefSafeCallback } from '../hooks/useRefSafeCallback.js';\n\nimport type { CollectionAddEvent, Context, ContextWatchdog, Editor, GetCallback } from 'ckeditor5';\nimport type { ContextWatchdogValue } from './ckeditorcontext.js';\n\nimport {\n\ttryExtractCKEditorReactContextMetadata,\n\ttype CKEditorConfigContextMetadata\n} from './setCKEditorReactContextMetadata.js';\n\n/**\n * A hook that listens for the editor initialization and destruction events and updates the editors map.\n *\n * @param config The configuration of the hook.\n * @param config.currentContextWatchdog The current context watchdog value.\n * @param config.onChangeInitializedEditors The function that updates the editors map.\n * @example\n * ```ts\n * useInitializedCKEditorsMap( {\n * \tcurrentContextWatchdog,\n * \tonChangeInitializedEditors: ( editors, context ) => {\n * \t\tconsole.log( 'Editors:', editors );\n * \t}\n * } );\n * ```\n */\nexport const useInitializedCKEditorsMap = <TContext extends Context>(\n\t{\n\t\tcurrentContextWatchdog,\n\t\tonChangeInitializedEditors\n\t}: InitializedContextEditorsConfig<TContext>\n): void => {\n\t// We need to use the safe callback to prevent the stale closure problem.\n\tconst onChangeInitializedEditorsSafe = useRefSafeCallback( onChangeInitializedEditors || ( () => {} ) );\n\n\tuseEffect( () => {\n\t\tif ( currentContextWatchdog.status !== 'initialized' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { watchdog } = currentContextWatchdog;\n\t\tconst editors = watchdog?.context?.editors;\n\n\t\tif ( !editors ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the initialized editors from\n\t\tconst getInitializedContextEditors = () => [ ...editors ].reduce<InitializedEditorsMap>(\n\t\t\t( map, editor ) => {\n\t\t\t\tif ( editor.state !== 'ready' ) {\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\tconst metadata = tryExtractCKEditorReactContextMetadata( editor.config );\n\t\t\t\tconst nameOrId = metadata?.name ?? editor.id;\n\n\t\t\t\tmap[ nameOrId ] = {\n\t\t\t\t\tinstance: editor,\n\t\t\t\t\tmetadata\n\t\t\t\t};\n\n\t\t\t\treturn map;\n\t\t\t},\n\t\t\tObject.create( {} ) // Prevent the prototype pollution.\n\t\t);\n\n\t\t// The function that is called when the editor status changes.\n\t\tconst onEditorStatusChange = () => {\n\t\t\tonChangeInitializedEditorsSafe(\n\t\t\t\tgetInitializedContextEditors(),\n\t\t\t\twatchdog\n\t\t\t);\n\t\t};\n\n\t\t// Add the existing editors to the map.\n\t\tconst trackEditorLifecycle = ( editor: Editor ) => {\n\t\t\teditor.once( 'ready', onEditorStatusChange, { priority: 'lowest' } );\n\t\t\teditor.once( 'destroy', onEditorStatusChange, { priority: 'lowest' } );\n\t\t};\n\n\t\tconst onAddEditorToCollection: GetCallback<CollectionAddEvent<Editor>> = ( _, editor ) => {\n\t\t\ttrackEditorLifecycle( editor );\n\t\t};\n\n\t\teditors.forEach( trackEditorLifecycle );\n\t\teditors.on<CollectionAddEvent<Editor>>( 'add', onAddEditorToCollection );\n\n\t\t// Fire the initial change event if there is at least one editor ready, otherwise wait for the first ready editor.\n\t\tif ( Array.from( editors ).some( editor => editor.state === 'ready' ) ) {\n\t\t\tonEditorStatusChange();\n\t\t}\n\n\t\treturn () => {\n\t\t\teditors.off( 'add', onAddEditorToCollection );\n\t\t};\n\t}, [ currentContextWatchdog ] );\n};\n\n/**\n * A map of initialized editors.\n */\ntype InitializedEditorsMap = Record<string, {\n\tinstance: Editor;\n\tmetadata: CKEditorConfigContextMetadata | null;\n}>;\n\n/**\n * The configuration of the `useInitializedCKEditorsMap` hook.\n */\nexport type InitializedContextEditorsConfig<TContext extends Context> = {\n\n\t/**\n\t * The current context watchdog value.\n\t */\n\tcurrentContextWatchdog: ContextWatchdogValue<TContext>;\n\n\t/**\n\t * The callback called when the editors map changes.\n\t */\n\tonChangeInitializedEditors?: (\n\t\teditors: InitializedEditorsMap,\n\t\twatchdog: ContextWatchdog<TContext>\n\t) => void;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React, {\n\tuseRef, useContext, useState, useEffect,\n\ttype PropsWithChildren,\n\ttype ReactElement\n} from 'react';\n\nimport { uid } from '@ckeditor/ckeditor5-integrations-common';\nimport { useIsMountedRef } from '../hooks/useIsMountedRef.js';\nimport {\n\tuseInitializedCKEditorsMap,\n\ttype InitializedContextEditorsConfig\n} from './useInitializedCKEditorsMap.js';\n\nimport type {\n\tContextWatchdog,\n\tWatchdogConfig,\n\tContext,\n\tContextConfig\n} from 'ckeditor5';\n\nexport const ContextWatchdogContext = React.createContext<ContextWatchdogValue | null>( null );\n\n/**\n * Custom hook that returns the CKEditor Watchdog context value.\n */\nexport const useCKEditorWatchdogContext = (): ContextWatchdogValue | null =>\n\tuseContext( ContextWatchdogContext );\n\n/**\n * A React component that provides a context for CKEditor.\n */\nconst CKEditorContext = <TContext extends Context = Context>( props: Props<TContext> ): ReactElement | null => {\n\tconst {\n\t\tid, context, watchdogConfig,\n\t\tchildren, config, onReady,\n\t\tcontextWatchdog: ContextWatchdogConstructor,\n\t\tisLayoutReady = true,\n\t\tonChangeInitializedEditors,\n\t\tonError = ( error, details ) => console.error( error, details )\n\t} = props;\n\n\tconst isMountedRef = useIsMountedRef();\n\tconst prevWatchdogInitializationIDRef = useRef<string | null>( null );\n\n\t// The currentContextWatchdog state is set to 'initializing' because it is checked later in the CKEditor component\n\t// which is waiting for the full initialization of the context watchdog.\n\tconst [ currentContextWatchdog, setCurrentContextWatchdog ] = useState<ContextWatchdogValue<TContext>>( {\n\t\tstatus: 'initializing'\n\t} );\n\n\t// Lets initialize the context watchdog when the layout is ready.\n\tuseEffect( () => {\n\t\tif ( isLayoutReady ) {\n\t\t\tinitializeContextWatchdog();\n\t\t} else {\n\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\tstatus: 'initializing'\n\t\t\t} );\n\t\t}\n\t}, [ id, isLayoutReady ] );\n\n\t// Cleanup the context watchdog when the component is unmounted. Abort if the watchdog is not initialized.\n\tuseEffect( () => () => {\n\t\tif ( currentContextWatchdog.status === 'initialized' ) {\n\t\t\tcurrentContextWatchdog.watchdog.destroy();\n\t\t}\n\t}, [ currentContextWatchdog ] );\n\n\t// Listen for the editor initialization and destruction events and call the onChangeInitializedEditors function.\n\tuseInitializedCKEditorsMap( {\n\t\tcurrentContextWatchdog,\n\t\tonChangeInitializedEditors\n\t} );\n\n\t/**\n\t * Regenerates the initialization ID by generating a random ID and updating the previous watchdog initialization ID.\n\t * This is necessary to ensure that the state update is performed only if the current initialization ID matches the previous one.\n\t * This helps to avoid race conditions and ensures that the correct context watchdog is associated with the component.\n\t *\n\t * @returns The regenerated initialization ID.\n\t */\n\tfunction regenerateInitializationID() {\n\t\tprevWatchdogInitializationIDRef.current = uid();\n\n\t\treturn prevWatchdogInitializationIDRef.current;\n\t}\n\n\t/**\n\t * Checks if the state can be updated based on the provided initialization ID.\n\t *\n\t * @param initializationID The initialization ID to compare with the previous one.\n\t * @returns A boolean indicating whether the state can be updated.\n\t */\n\tfunction canUpdateState( initializationID: string ) {\n\t\treturn prevWatchdogInitializationIDRef.current === initializationID && isMountedRef.current;\n\t}\n\n\t/**\n\t * Initializes the context watchdog.\n\t *\n\t * @returns Watchdog instance.\n\t */\n\tfunction initializeContextWatchdog() {\n\t\t// The prevWatchdogInitializationID variable is used to keep track of the previous initialization ID.\n\t\t// It is used to ensure that the state update is performed only if the current initialization ID matches the previous one.\n\t\t// This helps to avoid race conditions and ensures that the correct context watchdog is associated with the component.\n\t\tconst watchdogInitializationID = regenerateInitializationID()!;\n\t\tconst contextWatchdog = new ContextWatchdogConstructor( context!, watchdogConfig );\n\n\t\t// Handle error event from context watchdog.\n\t\tcontextWatchdog.on( 'error', ( _, errorEvent ) => {\n\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\tonError( errorEvent.error, {\n\t\t\t\t\tphase: 'runtime',\n\t\t\t\t\twillContextRestart: errorEvent.causesRestart\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\t// Handle state change event from context watchdog.\n\t\tcontextWatchdog.on( 'stateChange', () => {\n\t\t\tif ( onReady && contextWatchdog.state === 'ready' && canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\tonReady(\n\t\t\t\t\tcontextWatchdog.context! as TContext,\n\t\t\t\t\tcontextWatchdog\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t\t// Create the context watchdog and initialize it with the provided config.\n\t\tcontextWatchdog\n\t\t\t.create( config )\n\t\t\t.then( () => {\n\t\t\t\t// Check if the state update is still valid and update the current context watchdog.\n\t\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\t\t\tstatus: 'initialized',\n\t\t\t\t\t\twatchdog: contextWatchdog\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\t// Destroy the context watchdog if the state update is no longer valid.\n\t\t\t\t\tcontextWatchdog.destroy();\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\t// Update the current context watchdog with the error status.\n\t\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\t\t// Handle error during context watchdog initialization.\n\t\t\t\t\tonError( error, {\n\t\t\t\t\t\tphase: 'initialization',\n\t\t\t\t\t\twillContextRestart: false\n\t\t\t\t\t} );\n\n\t\t\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\t\t\tstatus: 'error',\n\t\t\t\t\t\terror\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\n\t\treturn contextWatchdog;\n\t}\n\n\treturn (\n\t\t<ContextWatchdogContext.Provider value={currentContextWatchdog}>\n\t\t\t{children}\n\t\t</ContextWatchdogContext.Provider>\n\t);\n};\n\n/**\n * Checks if the given object is of type ContextWatchdogValue.\n *\n * @param obj The object to be checked.\n * @returns True if the object is of type ContextWatchdogValue, false otherwise.\n */\nexport const isContextWatchdogValue = ( obj: any ): obj is ContextWatchdogValue =>\n\t!!obj && typeof obj === 'object' && 'status' in obj && [ 'initializing', 'initialized', 'error' ].includes( obj.status );\n\n/**\n * Checks if the provided object is a context watchdog value with the specified status.\n */\nexport const isContextWatchdogValueWithStatus = <S extends ContextWatchdogValueStatus>( status: S ) =>\n\t( obj: any ): obj is ExtractContextWatchdogValueByStatus<S> =>\n\t\tisContextWatchdogValue( obj ) && obj.status === status;\n\n/**\n * Checks if the context watchdog is currently initializing.\n */\nexport const isContextWatchdogInitializing = isContextWatchdogValueWithStatus( 'initializing' );\n\n/**\n * Checks if the provided object is a fully initialized context watchdog value. It prevents race conditions between\n * watchdog state that is not fully synchronized with the context state. For example, the watchdog state can be 'destroyed'\n * while the context is still being initialized because context setState is pending.\n */\nexport const isContextWatchdogReadyToUse = ( obj: any ): obj is ExtractContextWatchdogValueByStatus<'initialized'> => (\n\tisContextWatchdogValueWithStatus( 'initialized' )( obj ) &&\n\tobj.watchdog.state === 'ready'\n);\n\n/**\n * Represents the value of the ContextWatchdog in the CKEditor context.\n */\nexport type ContextWatchdogValue<TContext extends Context = Context> =\n\t| {\n\t\tstatus: 'initializing';\n\t}\n\t| {\n\t\tstatus: 'initialized';\n\t\twatchdog: ContextWatchdog<TContext>;\n\t}\n\t| {\n\t\tstatus: 'error';\n\t\terror: ErrorDetails;\n\t};\n\n/**\n * Represents the status of the ContextWatchdogValue.\n */\nexport type ContextWatchdogValueStatus = ContextWatchdogValue[ 'status' ];\n\n/**\n * Extracts a specific type of `ContextWatchdogValue` based on its status.\n */\nexport type ExtractContextWatchdogValueByStatus<S extends ContextWatchdogValueStatus> = Extract<\n\tContextWatchdogValue,\n\t{ status: S }\n>;\n\n/**\n * Props for the CKEditorContext component.\n */\nexport type Props<TContext extends Context> =\n\t& PropsWithChildren\n\t& Pick<InitializedContextEditorsConfig<TContext>, 'onChangeInitializedEditors'>\n\t& {\n\t\tid?: string;\n\t\tisLayoutReady?: boolean;\n\t\tcontext?: { create( ...args: any ): Promise<TContext> };\n\t\tcontextWatchdog: typeof ContextWatchdog<TContext>;\n\t\twatchdogConfig?: WatchdogConfig;\n\t\tconfig?: ContextConfig;\n\t\tonReady?: ( context: TContext, watchdog: ContextWatchdog<TContext> ) => void;\n\t\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\t};\n\ntype ErrorDetails = {\n\tphase: 'initialization' | 'runtime';\n\twillContextRestart: boolean;\n};\n\nexport default CKEditorContext;\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React from 'react';\nimport { createIntegrationUsageDataPlugin } from '@ckeditor/ckeditor5-integrations-common';\n\n/**\n * This part of the code is not executed in open-source implementations using a GPL key.\n * It only runs when a specific license key is provided. If you are uncertain whether\n * this applies to your installation, please contact our support team.\n */\nexport const ReactIntegrationUsageDataPlugin = createIntegrationUsageDataPlugin(\n\t'react',\n\t{\n\t\tversion: __REACT_INTEGRATION_VERSION__,\n\t\tframeworkVersion: React.version\n\t}\n);\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { appendExtraPluginsToEditorConfig, isCKEditorFreeLicense } from '@ckeditor/ckeditor5-integrations-common';\nimport type { EditorConfig } from 'ckeditor5';\n\nimport { ReactIntegrationUsageDataPlugin } from './ReactIntegrationUsageDataPlugin.js';\n\n/**\n * Appends all integration plugins to the editor configuration.\n *\n * @param editorConfig The editor configuration.\n * @returns The editor configuration with all integration plugins appended.\n */\nexport function appendAllIntegrationPluginsToConfig( editorConfig: EditorConfig ): EditorConfig {\n\t/**\n\t * Do not modify the editor configuration if the editor is using a free license.\n\t */\n\tif ( isCKEditorFreeLicense( editorConfig.licenseKey ) ) {\n\t\treturn editorConfig;\n\t}\n\n\treturn appendExtraPluginsToEditorConfig( editorConfig, [\n\t\t/**\n\t\t * This part of the code is not executed in open-source implementations using a GPL key.\n\t\t * It only runs when a specific license key is provided. If you are uncertain whether\n\t\t * this applies to your installation, please contact our support team.\n\t\t */\n\t\tReactIntegrationUsageDataPlugin\n\t] );\n}\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React from 'react';\n\nimport type {\n\tEventInfo,\n\tEditor,\n\tEditorConfig,\n\tEditorWatchdog,\n\tContextWatchdog,\n\tWatchdogConfig\n} from 'ckeditor5';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore.js';\n\nimport { uid } from '@ckeditor/ckeditor5-integrations-common';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore.js';\n\nimport {\n\twithCKEditorReactContextMetadata,\n\ttype CKEditorConfigContextMetadata\n} from './context/setCKEditorReactContextMetadata.js';\n\nimport {\n\tContextWatchdogContext,\n\tisContextWatchdogInitializing,\n\tisContextWatchdogReadyToUse\n} from './context/ckeditorcontext.js';\n\nimport { appendAllIntegrationPluginsToConfig } from './plugins/appendAllIntegrationPluginsToConfig.js';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\nexport default class CKEditor<TEditor extends Editor> extends React.Component<Props<TEditor>> {\n\t/**\n\t * After mounting the editor, the variable will contain a reference to the created editor.\n\t * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n\t */\n\tprivate domContainer = React.createRef<HTMLDivElement>();\n\n\t/**\n\t * Unlocks element in editor semaphore after destroy editor instance.\n\t */\n\tprivate editorSemaphore: LifeCycleElementSemaphore<EditorSemaphoreMountResult<TEditor>> | null = null;\n\n\tconstructor( props: Props<TEditor> ) {\n\t\tsuper( props );\n\n\t\tthis._checkVersion();\n\t}\n\n\t/**\n\t * Checks if the CKEditor version used in the application is compatible with the component.\n\t */\n\tprivate _checkVersion(): void {\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\tif ( !CKEDITOR_VERSION ) {\n\t\t\treturn console.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\n\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\tif ( major >= 42 || CKEDITOR_VERSION.startsWith( '0.0.0' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.' );\n\t}\n\n\tprivate get _semaphoreValue(): EditorSemaphoreMountResult<TEditor> | null {\n\t\tconst { editorSemaphore } = this;\n\n\t\treturn editorSemaphore ? editorSemaphore.value : null;\n\t}\n\n\t/**\n\t * An watchdog instance.\n\t */\n\tpublic get watchdog(): EditorWatchdog<TEditor> | EditorWatchdogAdapter<TEditor> | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.watchdog : null;\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): Editor | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.instance : null;\n\t}\n\n\t/**\n\t * The CKEditor component should not be updated by React itself.\n\t * However, if the component identifier changes, the whole structure should be created once again.\n\t */\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\tconst { props, editorSemaphore } = this;\n\n\t\t// Only when the component identifier changes the whole structure should be re-created once again.\n\t\tif ( nextProps.id !== props.id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nextProps.disableWatchdog !== props.disableWatchdog ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( editorSemaphore ) {\n\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\tif ( this._shouldUpdateEditorData( props, nextProps, instance ) ) {\n\t\t\t\t\tinstance.data.set( nextProps.data! );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( 'disabled' in nextProps ) {\n\t\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\t\tif ( nextProps.disabled ) {\n\t\t\t\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Initialize the editor when the component is mounted.\n\t */\n\tpublic override componentDidMount(): void {\n\t\tif ( !isContextWatchdogInitializing( this.context ) ) {\n\t\t\tthis._initLifeCycleSemaphore();\n\t\t}\n\t}\n\n\t/**\n\t * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n\t */\n\tpublic override componentDidUpdate(): void {\n\t\tif ( !isContextWatchdogInitializing( this.context ) ) {\n\t\t\tthis._initLifeCycleSemaphore();\n\t\t}\n\t}\n\n\t/**\n\t * Destroy the editor before unmounting the component.\n\t */\n\tpublic override componentWillUnmount(): void {\n\t\tthis._unlockLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Async destroy attached editor and unlock element semaphore.\n\t */\n\tprivate _unlockLifeCycleSemaphore() {\n\t\tif ( this.editorSemaphore ) {\n\t\t\tthis.editorSemaphore.release();\n\t\t\tthis.editorSemaphore = null;\n\t\t}\n\t}\n\n\t/**\n\t * Unlocks previous editor semaphore and creates new one..\n\t */\n\tprivate _initLifeCycleSemaphore() {\n\t\tthis._unlockLifeCycleSemaphore();\n\t\tthis.editorSemaphore = new LifeCycleElementSemaphore( this.domContainer.current!, {\n\t\t\tisValueValid: value => value && !!value.instance,\n\t\t\tmount: async () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this._initializeEditor();\n\t\t\t\t} catch ( error: any ) {\n\t\t\t\t\tthis.props.onError?.( error, { phase: 'initialization', willEditorRestart: false } );\n\n\t\t\t\t\t// Rethrow, let's semaphore handle it.\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t},\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = this.props;\n\n\t\t\t\tif ( onReady && this.domContainer.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait this._destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Render a <div> element which will be replaced by CKEditor.\n\t */\n\tpublic override render(): React.ReactNode {\n\t\treturn (\n\t\t\t<div ref={ this.domContainer }></div>\n\t\t);\n\t}\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tprivate async _initializeEditor(): Promise<EditorSemaphoreMountResult<TEditor>> {\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\tconst instance = await this._createEditor( this.domContainer.current!, this._getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as TEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\t// There is small delay where React did not update the context yet but watchdog is already destroyed.\n\t\t\t// However editor should be created again in such case, after receiving new context.\n\t\t\tif ( isContextWatchdogReadyToUse( this.context ) ) {\n\t\t\t\treturn new EditorWatchdogAdapter( this.context.watchdog );\n\t\t\t}\n\n\t\t\treturn new this.props.editor.EditorWatchdog( this.props.editor, this.props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<TEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( el, config ) => {\n\t\t\tconst { editorSemaphore } = this;\n\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorSemaphore?.value?.instance ) {\n\t\t\t\tonAfterDestroy( editorSemaphore.value.instance );\n\t\t\t}\n\n\t\t\tconst instance = await this._createEditor( el as any, config );\n\n\t\t\t// The editor semaphore can be unavailable at this stage. There is a small chance that the component\n\t\t\t// was destroyed while watchdog was initializing new instance of editor. In such case, we should not\n\t\t\t// call any callbacks or set any values to the semaphore.\n\t\t\tif ( editorSemaphore && totalRestartsRef.current > 0 ) {\n\t\t\t\teditorSemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( this.props.onReady ) {\n\t\t\t\t\t\tthis.props.onReady( watchdog!.editor as TEditor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = this.props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog.create( this.domContainer.current!, this._getConfig() );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t}\n\n\t/**\n\t * Creates an editor from the element and configuration.\n\t *\n\t * @param element The source element.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tprivate _createEditor( element: HTMLElement | string | Record<string, string>, config: EditorConfig ): Promise<TEditor> {\n\t\tconst { contextItemMetadata } = this.props;\n\n\t\tif ( contextItemMetadata ) {\n\t\t\tconfig = withCKEditorReactContextMetadata( contextItemMetadata, config );\n\t\t}\n\n\t\treturn this.props.editor.create(\n\t\t\telement as HTMLElement,\n\t\t\tappendAllIntegrationPluginsToConfig( config )\n\t\t)\n\t\t\t.then( editor => {\n\t\t\t\tif ( 'disabled' in this.props ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on( 'change:data', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onChange ) {\n\t\t\t\t\t\tthis.props.onChange( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onFocus ) {\n\t\t\t\t\t\tthis.props.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onBlur ) {\n\t\t\t\t\t\tthis.props.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t}\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tprivate async _destroyEditor( initializeResult: EditorSemaphoreMountResult<Editor> ): Promise<void> {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns true when the editor should be updated.\n\t *\n\t * @param prevProps Previous react's properties.\n\t * @param nextProps React's properties.\n\t * @param editor Current editor instance.\n\t */\n\tprivate _shouldUpdateEditorData( prevProps: Readonly<Props<TEditor>>, nextProps: Readonly<Props<TEditor>>, editor: TEditor ): boolean {\n\t\t// Check whether `nextProps.data` is equal to `this.props.data` is required if somebody defined the `#data`\n\t\t// property as a static string and updated a state of component when the editor's content has been changed.\n\t\t// If we avoid checking those properties, the editor's content will back to the initial value because\n\t\t// the state has been changed and React will call this method.\n\t\tif ( prevProps.data === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We should not change data if the editor's content is equal to the `#data` property.\n\t\tif ( editor.data.get() === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tprivate _getConfig(): EditorConfig {\n\t\tconst config = this.props.config || {};\n\n\t\tif ( this.props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `content` property. ' +\n\t\t\t\t'The config value takes precedence over `content` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\t// Merge two possible ways of providing data into the `config.initialData` field.\n\t\treturn {\n\t\t\t...config,\n\t\t\tinitialData: config.initialData || this.props.data || ''\n\t\t};\n\t}\n\n\tpublic static override contextType = ContextWatchdogContext;\n}\n\n/**\n * TODO this is type space definition for props, the CKEditor.propTypes is a run-time props validation that should match.\n */\nexport interface Props<TEditor extends Editor> {\n\teditor: {\n\t\tcreate( ...args: any ): Promise<TEditor>;\n\t\tEditorWatchdog: typeof EditorWatchdog;\n\t\tContextWatchdog: typeof ContextWatchdog;\n\t};\n\tcontextItemMetadata?: CKEditorConfigContextMetadata;\n\tconfig?: EditorConfig;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tonReady?: ( editor: TEditor ) => void;\n\tonAfterDestroy?: ( editor: TEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: TEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: TEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: TEditor ) => void;\n\tdata?: string;\n\tdisabled?: boolean;\n\tid?: any;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\n/**\n * An adapter aligning the context watchdog API to the editor watchdog API for easier usage.\n */\nexport class EditorWatchdogAdapter<TEditor extends Editor> {\n\t/**\n\t * The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tprivate readonly _contextWatchdog: ContextWatchdog;\n\n\t/**\n\t * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n\t */\n\tprivate readonly _id: string;\n\n\t/**\n\t * A watchdog's editor creator function.\n\t */\n\tprivate _creator?: AdapterEditorCreatorFunction;\n\n\t/**\n\t * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tconstructor( contextWatchdog: ContextWatchdog ) {\n\t\tthis._contextWatchdog = contextWatchdog;\n\t\tthis._id = uid();\n\t}\n\n\t/**\n\t *  @param creator A watchdog's editor creator function.\n\t */\n\tpublic setCreator( creator: AdapterEditorCreatorFunction ): void {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n\t *\n\t * @param sourceElementOrData A source element or data for the new editor.\n\t * @param config CKEditor 5 editor config.\n\t */\n\tpublic create( sourceElementOrData: HTMLElement | string, config: EditorConfig ): Promise<unknown> {\n\t\treturn this._contextWatchdog.add( {\n\t\t\tsourceElementOrData,\n\t\t\tconfig,\n\t\t\tcreator: this._creator!,\n\t\t\tid: this._id,\n\t\t\ttype: 'editor'\n\t\t} );\n\t}\n\n\t/**\n\t * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n\t * Currently works only for the `error` event.\n\t */\n\tpublic on( _: string, callback: ( _: null, data: { error: Error; causesRestart?: boolean } ) => void ): void {\n\t\t// Assume that the event name was error.\n\t\tthis._contextWatchdog.on( 'itemError', ( _, { itemId, error } ) => {\n\t\t\tif ( itemId === this._id ) {\n\t\t\t\tcallback( null, { error, causesRestart: undefined } );\n\t\t\t}\n\t\t} );\n\t}\n\n\tpublic destroy(): Promise<unknown> {\n\t\t// Destroying an editor instance after destroying the Context is handled in the `ContextWatchdog` class.\n\t\t// As `EditorWatchdogAdapter` is an adapter, we should not destroy the editor manually.\n\t\t// Otherwise, it causes that the editor is destroyed twice. However, there is a case, when the editor\n\t\t// needs to be removed from the context, without destroying the context itself. We may assume the following\n\t\t// relations with `ContextWatchdog#state`:\n\t\t//\n\t\t// a) `ContextWatchdog#state` === 'ready' - context is not destroyed; it's safe to destroy the editor manually.\n\t\t// b) `ContextWatchdog#state` === 'destroyed' - context is destroyed; let `ContextWatchdog` handle the whole process.\n\t\t//\n\t\t// See #354 for more information.\n\t\tif ( this._contextWatchdog.state === 'ready' ) {\n\t\t\treturn this._contextWatchdog.remove( this._id );\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): TEditor {\n\t\treturn this._contextWatchdog.getItem( this._id ) as TEditor;\n\t}\n}\n\ntype AdapterEditorCreatorFunction<TEditor = Editor> = (\n\telementOrData: HTMLElement | string | Record<string, string> | Record<string, HTMLElement>,\n\tconfig: EditorConfig\n) => Promise<TEditor>;\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useRef, useState, type RefObject } from 'react';\nimport type { LifeCycleElementSemaphore, LifeCycleAfterMountCallback } from './LifeCycleElementSemaphore.js';\n\n/**\n * When using the `useState` approach, a new instance of the semaphore must be set based on the previous\n * one within the `setState` callback, as shown in this example:\n *\n * \t\tsetState( prevSemaphore => ... )\n *\n * The issue arises from the uncertainty of whether React has batched and cancelled some `setState` calls.\n * This means that setting the state with a semaphore three times might result in the collapsing of these three calls into a single one.\n *\n * Although this may not seem like a significant issue in theory, it can lead to a multitude of minor issues in practice that may\n * generate race conditions. This is because semaphores handle batching independently.\n *\n * A solution involving refs is safer in terms of preserving object references. In other words, `semaphoreRef.current` is guaranteed to\n * always point to the most recent instance of the semaphore.\n */\nexport const useLifeCycleSemaphoreSyncRef = <R extends object>(): LifeCycleSemaphoreSyncRefResult<R> => {\n\tconst semaphoreRef = useRef<LifeCycleElementSemaphore<R> | null>( null );\n\tconst [ revision, setRevision ] = useState( () => Date.now() );\n\n\tconst refresh = () => {\n\t\tsetRevision( Date.now() );\n\t};\n\n\tconst release = ( rerender: boolean = true ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.release();\n\t\t\tsemaphoreRef.current = null;\n\t\t}\n\n\t\tif ( rerender ) {\n\t\t\tsetRevision( Date.now() );\n\t\t}\n\t};\n\n\tconst unsafeSetValue = ( value: R ) => {\n\t\tsemaphoreRef.current?.unsafeSetValue( value );\n\t\trefresh();\n\t};\n\n\tconst runAfterMount = ( callback: LifeCycleAfterMountCallback<R> ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.runAfterMount( callback );\n\t\t}\n\t};\n\n\tconst replace = ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => {\n\t\trelease( false );\n\t\tsemaphoreRef.current = newSemaphore();\n\n\t\trefresh();\n\t\trunAfterMount( refresh );\n\t};\n\n\tconst createAttributeRef = <K extends keyof R>( key: K ): RefObject<R[ K ]> => ( {\n\t\tget current() {\n\t\t\tif ( !semaphoreRef.current || !semaphoreRef.current.value ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn semaphoreRef.current.value[ key ];\n\t\t}\n\t} );\n\n\treturn {\n\t\tget current() {\n\t\t\treturn semaphoreRef.current;\n\t\t},\n\t\trevision,\n\t\tcreateAttributeRef,\n\t\tunsafeSetValue,\n\t\trelease,\n\t\treplace,\n\t\trunAfterMount\n\t};\n};\n\nexport type LifeCycleSemaphoreSyncRefResult<R> = RefObject<LifeCycleElementSemaphore<R>> & {\n\trevision: number;\n\tunsafeSetValue: ( value: R ) => void;\n\trunAfterMount: ( callback: LifeCycleAfterMountCallback<R> ) => void;\n\trelease: ( rerender?: boolean ) => void;\n\treplace: ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => void;\n\tcreateAttributeRef: <K extends keyof R>( key: K ) => RefObject<R[ K ]>;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { MutableRefObject } from 'react';\n\ntype CallbackRef<T> = ( element: T ) => void;\n\ntype ReactRef<T> = CallbackRef<T | null> | MutableRefObject<T | null> | null;\n\n/**\n * Combine multiple react refs into one.\n */\nexport function mergeRefs<T>( ...refs: Array<ReactRef<T>> ): CallbackRef<T> {\n\treturn value => {\n\t\trefs.forEach( ref => {\n\t\t\tif ( typeof ref === 'function' ) {\n\t\t\t\tref( value );\n\t\t\t} else if ( ref != null ) {\n\t\t\t\tref.current = value;\n\t\t\t}\n\t\t} );\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useState, type DependencyList } from 'react';\nimport { shallowCompareArrays } from '@ckeditor/ckeditor5-integrations-common';\n\n/**\n * Triggers an effect immediately if the dependencies change (during rendering of component).\n *\n * @param fn The effect function to execute.\n * @param deps The dependency list.\n */\nexport const useInstantEffect = ( fn: VoidFunction, deps: DependencyList ): void => {\n\tconst [ prevDeps, setDeps ] = useState<any>( null );\n\n\tif ( !shallowCompareArrays( prevDeps, deps ) ) {\n\t\tfn();\n\t\tsetDeps( [ ...deps ] );\n\t}\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { DependencyList } from 'react';\nimport type { LifeCycleElementSemaphore } from '../lifecycle/LifeCycleElementSemaphore.js';\n\nimport { useInstantEffect } from './useInstantEffect.js';\n\n/**\n * `useEffect` alternative but executed after mounting of editor.\n */\nexport const useInstantEditorEffect = <R>(\n\tsemaphore: Pick<LifeCycleElementSemaphore<R>, 'runAfterMount'> | null,\n\tfn: ( mountResult: R ) => void,\n\tdeps: DependencyList\n): void => {\n\tuseInstantEffect( () => {\n\t\tif ( semaphore ) {\n\t\t\tsemaphore.runAfterMount( fn );\n\t\t}\n\t}, [ semaphore, ...deps ] );\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React, {\n\tforwardRef, useState, useEffect, useRef, useContext, useCallback, memo,\n\ttype Dispatch, type SetStateAction, type RefObject, type JSX\n} from 'react';\n\nimport { overwriteArray, overwriteObject, uniq } from '@ckeditor/ckeditor5-integrations-common';\n\nimport type {\n\tInlineEditableUIView,\n\tEditorConfig,\n\tModelWriter,\n\tModelRootElement,\n\tWatchdogConfig,\n\tAddRootEvent,\n\tDetachRootEvent,\n\tMultiRootEditor,\n\tEventInfo\n} from 'ckeditor5';\n\nimport { ContextWatchdogContext, isContextWatchdogReadyToUse } from './context/ckeditorcontext.js';\nimport { EditorWatchdogAdapter } from './ckeditor.js';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore.js';\n\nimport { useLifeCycleSemaphoreSyncRef, type LifeCycleSemaphoreSyncRefResult } from './lifecycle/useLifeCycleSemaphoreSyncRef.js';\nimport { mergeRefs } from './utils/mergeRefs.js';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore.js';\nimport { useRefSafeCallback } from './hooks/useRefSafeCallback.js';\nimport { useInstantEditorEffect } from './hooks/useInstantEditorEffect.js';\n\nimport { appendAllIntegrationPluginsToConfig } from './plugins/appendAllIntegrationPluginsToConfig.js';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst useMultiRootEditor = ( props: MultiRootHookProps ): MultiRootHookReturns => {\n\tconst semaphoreElementRef = useRef<HTMLElement>( props.semaphoreElement || null );\n\tconst semaphore = useLifeCycleSemaphoreSyncRef<LifeCycleMountResult>();\n\n\tconst editorRefs: LifeCycleSemaphoreRefs<MultiRootEditor> = {\n\t\twatchdog: semaphore.createAttributeRef( 'watchdog' ),\n\t\tinstance: semaphore.createAttributeRef( 'instance' )\n\t};\n\n\tconst context = useContext( ContextWatchdogContext );\n\n\t// List of editor root elements.\n\tconst [ roots, setRoots ] = useState<Array<string>>( () => Object.keys( props.data ) );\n\n\t// Current editor data. An object where each key is a root name and the value is the root content.\n\tconst [ data, setData ] = useState<Record<string, string>>( { ...props.data } );\n\n\t// Current roots attributes. An object where each key is a root name and the value is an object with root attributes.\n\tconst [ attributes, setAttributes ] = useState<Record<string, Record<string, unknown>>>( { ...props.rootsAttributes } );\n\n\tconst shouldUpdateEditor = useRef<boolean>( true );\n\n\t/**\n\t * It's possible to unmount `useMultiRootEditor` with created editor and `elements` that are not attached to any React node.\n\t * It means that CKEditor will try to destroy editor and all it's roots in destructor. It will throw an error because\n\t * `editables` are not attached to any React node and their elements references are null. To prevent this error we need to\n\t * force assign `editables` to fake elements before destroying editor.\n\t *\n\t * See: https://github.com/ckeditor/ckeditor5/issues/16561\n\t */\n\tconst forceAssignFakeEditableElements = () => {\n\t\tconst editor = editorRefs.instance.current;\n\n\t\tif ( !editor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst initializeEditableWithFakeElement = ( editable: InlineEditableUIView ) => {\n\t\t\tif ( editable.name && !editor.editing.view.getDomRoot( editable.name ) ) {\n\t\t\t\teditor.editing.view.attachDomRoot( document.createElement( 'div' ), editable.name );\n\t\t\t}\n\t\t};\n\n\t\tObject\n\t\t\t.values( editor.ui.view.editables )\n\t\t\t.forEach( initializeEditableWithFakeElement );\n\t};\n\n\tuseEffect( () => {\n\t\tconst semaphoreElement = semaphoreElementRef.current;\n\n\t\t// Check if parent context is ready (only if it is provided).\n\t\tif ( context && !isContextWatchdogReadyToUse( context ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if hook internal state or attributes are not ready yet.\n\t\tif ( !semaphoreElement || props.isLayoutReady === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsemaphore.replace( () => new LifeCycleElementSemaphore( semaphoreElement, {\n\t\t\tmount: _initializeEditor,\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = props;\n\n\t\t\t\tif ( onReady && semaphoreElementRef.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait _destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} ) );\n\n\t\treturn () => {\n\t\t\tforceAssignFakeEditableElements();\n\t\t\tsemaphore.release( false );\n\t\t};\n\t}, [ props.id, props.isLayoutReady, context?.status ] );\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tconst _getConfig = (): EditorConfig => {\n\t\tconst config = props.config || {};\n\n\t\tif ( props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `data` property. ' +\n\t\t\t\t'The config value takes precedence over `data` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\t...config,\n\t\t\trootsAttributes: attributes\n\t\t};\n\t};\n\n\t/**\n\t * Callback function for handling changed data and attributes in the editor.\n\t */\n\tconst onChangeData = useRefSafeCallback( ( editor: MultiRootEditor, event: EventInfo ): void => {\n\t\tconst modelDocument = editor!.model.document;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tconst newData: Record<string, string> = {};\n\t\t\tconst newAttributes: Record<string, Record<string, unknown>> = {};\n\n\t\t\tmodelDocument.differ.getChanges()\n\t\t\t\t.forEach( change => {\n\t\t\t\t\tlet root: ModelRootElement;\n\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( change.type == 'insert' || change.type == 'remove' ) {\n\t\t\t\t\t\troot = change.position.root as ModelRootElement;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Must be `attribute` diff item.\n\t\t\t\t\t\troot = change.range.root as ModelRootElement;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Getting data from a not attached root will trigger a warning.\n\t\t\t\t\t// There is another callback for handling detached roots.\n\t\t\t\t\tif ( !root.isAttached() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { rootName } = root;\n\n\t\t\t\t\tnewData[ rootName ] = editor!.getData( { rootName } );\n\t\t\t\t} );\n\n\t\t\tmodelDocument.differ.getChangedRoots()\n\t\t\t\t.forEach( changedRoot => {\n\t\t\t\t\t// Ignore added and removed roots. They are handled by a different function.\n\t\t\t\t\t// Only register if roots attributes changed.\n\t\t\t\t\tif ( changedRoot.state ) {\n\t\t\t\t\t\tif ( newData[ changedRoot.name ] !== undefined ) {\n\t\t\t\t\t\t\tdelete newData[ changedRoot.name ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rootName = changedRoot.name;\n\n\t\t\t\t\tnewAttributes[ rootName ] = editor!.getRootAttributes( rootName );\n\t\t\t\t} );\n\n\t\t\tif ( Object.keys( newData ).length ) {\n\t\t\t\tsetData( previousData => ( { ...previousData, ...newData } ) );\n\t\t\t}\n\n\t\t\tif ( Object.keys( newAttributes ).length ) {\n\t\t\t\tsetAttributes( previousAttributes => ( { ...previousAttributes, ...newAttributes } ) );\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore else -- @preserve */\n\t\tif ( props.onChange ) {\n\t\t\tprops.onChange( event, editor! );\n\t\t}\n\t} );\n\n\t/**\n\t * Callback function for handling an added root.\n\t */\n\tconst onAddRoot = useRefSafeCallback( ( editor: MultiRootEditor, _evt: EventInfo, root: ModelRootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData =>\n\t\t\t\t( { ...previousData, [ rootName ]: editor!.getData( { rootName } ) } )\n\t\t\t);\n\n\t\t\tsetAttributes( previousAttributes =>\n\t\t\t\t( { ...previousAttributes, [ rootName ]: editor!.getRootAttributes( rootName ) } )\n\t\t\t);\n\t\t}\n\n\t\tsetRoots( prevRoots => uniq( [ ...prevRoots, root.rootName ] ) );\n\t} );\n\n\t/**\n\t * Callback function for handling a detached root.\n\t */\n\tconst onDetachRoot = useRefSafeCallback( ( _editor: MultiRootEditor, _evt: EventInfo, root: ModelRootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData => {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { [ rootName! ]: _, ...newData } = previousData;\n\n\t\t\t\treturn { ...newData };\n\t\t\t} );\n\n\t\t\tsetAttributes( previousAttributes => {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { [ rootName! ]: _, ...newAttributes } = previousAttributes;\n\n\t\t\t\treturn { ...newAttributes };\n\t\t\t} );\n\t\t}\n\n\t\tsetRoots( prevRoots => prevRoots.filter( root => root !== rootName ) );\n\t} );\n\n\t/**\n\t * Creates an editor using initial elements or data, and configuration.\n\t *\n\t * @param initialData The initial data.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tconst _createEditor = useRefSafeCallback( (\n\t\tinitialData: Record<string, string> | Record<string, HTMLElement>,\n\t\tconfig: EditorConfig\n\t): Promise<MultiRootEditor> => {\n\t\toverwriteObject( { ...props.rootsAttributes }, attributes );\n\t\toverwriteObject( { ...props.data }, data );\n\t\toverwriteArray( Object.keys( props.data ), roots );\n\n\t\treturn props.editor.create(\n\t\t\tinitialData,\n\t\t\tappendAllIntegrationPluginsToConfig( config )\n\t\t)\n\t\t\t.then( ( editor: MultiRootEditor ) => {\n\t\t\t\tconst editorData = editor.getFullData();\n\n\t\t\t\t// Rerender will be called anyway.\n\t\t\t\toverwriteObject( { ...editorData }, data );\n\t\t\t\toverwriteObject( { ...editor.getRootsAttributes() }, attributes );\n\t\t\t\toverwriteArray( Object.keys( editorData ), roots );\n\n\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on( 'change:data', evt => onChangeData( editor, evt ) );\n\n\t\t\t\teditor.on<AddRootEvent>( 'addRoot', ( evt, root ) => onAddRoot( editor, evt, root ) );\n\t\t\t\teditor.on<DetachRootEvent>( 'detachRoot', ( evt, root ) => onDetachRoot( editor, evt, root ) );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( props.onFocus ) {\n\t\t\t\t\t\tprops.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( props.onBlur ) {\n\t\t\t\t\t\tprops.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t} );\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tconst _destroyEditor = ( initializeResult: EditorSemaphoreMountResult<MultiRootEditor> ): Promise<void> => {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tconst _initializeEditor = async (): Promise<LifeCycleMountResult> => {\n\t\tif ( props.disableWatchdog ) {\n\t\t\tconst instance = await _createEditor( props.data as any, _getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as MultiRootEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( isContextWatchdogReadyToUse( context ) ) {\n\t\t\t\treturn new EditorWatchdogAdapter( context.watchdog );\n\t\t\t}\n\n\t\t\treturn new props.editor.EditorWatchdog( props.editor, props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<MultiRootEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\t// Keeping using `data` from creator function callback seems to be a good idea in theory,\n\t\t// but in practice, it leads to instability. The `data` object can be changed during the editor\n\t\t// initialization, which can lead to unexpected reset of value in the editor, that do not match\n\t\t// with the current react state. To prevent this, we are using the `data` from the hook state.\n\t\t// It's not super optimal, but it's the most stable solution at this moment.\n\t\t// See more: https://github.com/ckeditor/ckeditor5-react/issues/542\n\t\twatchdog.setCreator( async ( _, config ) => {\n\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current ) {\n\t\t\t\tonAfterDestroy( editorRefs.instance.current );\n\t\t\t}\n\n\t\t\tconst instance = await _createEditor( data as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\tsemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\t\t\tif ( props.onReady ) {\n\t\t\t\t\t\tprops.onReady( watchdog!.editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( data as any, _getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t\tthrow error;\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t};\n\n\tconst _getStateDiff = (\n\t\tpreviousState: Record<string, unknown>,\n\t\tnewState: Record<string, unknown>\n\t): {\n\t\taddedKeys: Array<string>;\n\t\tremovedKeys: Array<string>;\n\t} => {\n\t\tconst previousStateKeys = Object.keys( previousState );\n\t\tconst newStateKeys = Object.keys( newState );\n\n\t\treturn {\n\t\t\taddedKeys: newStateKeys.filter( key => !previousStateKeys.includes( key ) ),\n\t\t\tremovedKeys: previousStateKeys.filter( key => !newStateKeys.includes( key ) )\n\t\t};\n\t};\n\n\tconst _externalSetData: Dispatch<SetStateAction<Record<string, string>>> = useCallback(\n\t\tnewData => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetData( newData );\n\t\t\t} );\n\t\t},\n\t\t[ setData ]\n\t);\n\n\tconst _externalSetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>> = useCallback(\n\t\tnewAttributes => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetAttributes( newAttributes );\n\t\t\t} );\n\t\t},\n\t\t[ setAttributes ]\n\t);\n\n\tconst toolbarElement = (\n\t\t<EditorToolbarWrapper\n\t\t\tref={ semaphoreElementRef }\n\t\t\teditor={editorRefs.instance.current}\n\t\t/>\n\t);\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\tif ( props.disabled ) {\n\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t} else {\n\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t}\n\t}, [ props.disabled ] );\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\t// Editor should be only updated when the changes come from the integrator React application.\n\t\tif ( shouldUpdateEditor.current ) {\n\t\t\tshouldUpdateEditor.current = false;\n\n\t\t\tconst dataKeys = Object.keys( data );\n\t\t\tconst attributesKeys = Object.keys( attributes );\n\n\t\t\t// Check if `data` and `attributes` have the same keys.\n\t\t\t//\n\t\t\t// It prevents the addition of attributes for non-existing roots.\n\t\t\t// If the `data` object has a different set of keys, an error will not be thrown\n\t\t\t// since the attributes will be removed/added during root initialization/destruction.\n\t\t\tif ( !dataKeys.every( key => attributesKeys.includes( key ) ) ) {\n\t\t\t\tconsole.error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t\tthrow new Error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t}\n\n\t\t\tconst editorData = instance.getFullData();\n\t\t\tconst editorAttributes = instance.getRootsAttributes();\n\n\t\t\tconst {\n\t\t\t\taddedKeys: newRoots,\n\t\t\t\tremovedKeys: removedRoots\n\t\t\t} = _getStateDiff(\n\t\t\t\teditorData,\n\t\t\t\tdata || /* istanbul ignore next -- @preserve: It should never happen, data should be always filled. */ {}\n\t\t\t);\n\n\t\t\tconst modifiedRoots = dataKeys.filter( rootName =>\n\t\t\t\teditorData[ rootName ] !== undefined &&\n\t\t\t\tJSON.stringify( editorData[ rootName ] ) !== JSON.stringify( data[ rootName ] )\n\t\t\t);\n\n\t\t\tconst rootsWithChangedAttributes = attributesKeys.filter( rootName =>\n\t\t\t\tJSON.stringify( editorAttributes[ rootName ] ) !== JSON.stringify( attributes[ rootName ] ) );\n\n\t\t\tconst _handleNewRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.addRoot( rootName, {\n\t\t\t\t\t\tdata: data[ rootName ] || '',\n\t\t\t\t\t\tattributes: attributes?.[ rootName ] ||\n\t\t\t\t\t\t/* istanbul ignore next -- @preserve: attributes should be in sync with root keys */ {},\n\t\t\t\t\t\tisUndoable: true\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _handleRemovedRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.detachRoot( rootName, true );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _updateEditorData = ( roots: Array<string> ) => {\n\t\t\t\tconst dataToUpdate = roots.reduce(\n\t\t\t\t\t( result, rootName ) => ( { ...result, [ rootName ]: data[ rootName ] } ),\n\t\t\t\t\tObject.create( null )\n\t\t\t\t);\n\t\t\t\tinstance.data.set( dataToUpdate, { suppressErrorInCollaboration: true } as any );\n\t\t\t};\n\n\t\t\tconst _updateEditorAttributes = ( writer: ModelWriter, roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tObject.keys( attributes![ rootName ] ).forEach( attr => {\n\t\t\t\t\t\tinstance.registerRootAttribute( attr );\n\t\t\t\t\t} );\n\n\t\t\t\t\twriter.clearAttributes( instance.model.document.getRoot( rootName )! );\n\t\t\t\t\twriter.setAttributes( attributes![ rootName ], instance.model.document.getRoot( rootName )! );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\t// React struggles with rerendering during `instance.model.change` callbacks.\n\t\t\tsetTimeout( () => {\n\t\t\t\tinstance.model.change( writer => {\n\t\t\t\t\t_handleNewRoots( newRoots );\n\t\t\t\t\t_handleRemovedRoots( removedRoots );\n\n\t\t\t\t\tif ( modifiedRoots.length ) {\n\t\t\t\t\t\t_updateEditorData( modifiedRoots );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rootsWithChangedAttributes.length ) {\n\t\t\t\t\t\t_updateEditorAttributes( writer, rootsWithChangedAttributes );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}, [ data, attributes ] );\n\n\tconst editableElements = roots.map(\n\t\trootName => (\n\t\t\t<EditorEditable\n\t\t\t\tkey={rootName}\n\t\t\t\tid={rootName}\n\t\t\t\trootName={rootName}\n\t\t\t\tsemaphore={semaphore}\n\t\t\t/>\n\t\t)\n\t);\n\n\treturn {\n\t\teditor: editorRefs.instance.current,\n\t\teditableElements,\n\t\ttoolbarElement,\n\t\tdata, setData: _externalSetData,\n\t\tattributes, setAttributes: _externalSetAttributes\n\t};\n};\n\nexport const EditorEditable = memo( forwardRef( ( { id, semaphore, rootName }: {\n\tid: string;\n\trootName: string;\n\tsemaphore: LifeCycleSemaphoreSyncRefResult<LifeCycleMountResult>;\n}, ref ) => {\n\tconst innerRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tlet editable: InlineEditableUIView | null;\n\t\tlet editor: MultiRootEditor | null;\n\n\t\tsemaphore.runAfterMount( ( { instance } ) => {\n\t\t\tif ( !innerRef.current ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditor = instance;\n\n\t\t\tconst { ui, model } = editor;\n\t\t\tconst root = model.document.getRoot( rootName );\n\n\t\t\tif ( root && editor.ui.getEditableElement( rootName ) ) {\n\t\t\t\teditor.detachEditable( root );\n\t\t\t}\n\n\t\t\teditable = ui.view.createEditable( rootName, innerRef.current );\n\t\t\tui.addEditable( editable );\n\n\t\t\tinstance.editing.view.forceRender();\n\t\t} );\n\n\t\treturn () => {\n\t\t\t/* istanbul ignore next -- @preserve: It depends on the version of the React and may not happen all of the times. */\n\t\t\tif ( editor && editor.state !== 'destroyed' && innerRef.current ) {\n\t\t\t\tconst root = editor.model.document.getRoot( rootName );\n\n\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\tif ( root ) {\n\t\t\t\t\teditor.detachEditable( root );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, [ semaphore.revision ] );\n\n\treturn (\n\t\t<div\n\t\t\tkey={semaphore.revision}\n\t\t\tid={id}\n\t\t\tref={ mergeRefs( ref, innerRef ) }\n\t\t/>\n\t);\n} ) );\n\nEditorEditable.displayName = 'EditorEditable';\n\nexport const EditorToolbarWrapper = forwardRef( ( { editor }: any, ref ) => {\n\tconst toolbarRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tconst toolbarContainer = toolbarRef.current;\n\n\t\tif ( !editor || !toolbarContainer ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst element = editor.ui.view.toolbar.element!;\n\n\t\ttoolbarContainer.appendChild( element! );\n\n\t\treturn () => {\n\t\t\tif ( toolbarContainer.contains( element ) ) {\n\t\t\t\ttoolbarContainer.removeChild( element! );\n\t\t\t}\n\t\t};\n\t}, [ editor && editor.id ] );\n\n\treturn <div ref={mergeRefs( toolbarRef, ref )}></div>;\n} );\n\nEditorToolbarWrapper.displayName = 'EditorToolbarWrapper';\n\nexport default useMultiRootEditor;\n\ntype LifeCycleMountResult = EditorSemaphoreMountResult<MultiRootEditor>;\n\ntype LifeCycleSemaphoreRefs<TEditor extends MultiRootEditor> = {\n\t[ K in keyof EditorSemaphoreMountResult<TEditor> ]: RefObject<EditorSemaphoreMountResult<TEditor>[ K ]>\n};\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\nexport type MultiRootHookProps = {\n\tid?: any;\n\tsemaphoreElement?: HTMLElement;\n\n\tisLayoutReady?: boolean;\n\tdisabled?: boolean;\n\tdata: Record<string, string>;\n\trootsAttributes?: Record<string, Record<string, unknown>>;\n\teditor: typeof MultiRootEditor;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tdisableTwoWayDataBinding?: boolean;\n\n\tonReady?: ( editor: MultiRootEditor ) => void;\n\tonAfterDestroy?: ( editor: MultiRootEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\n\tconfig?: Record<string, unknown>;\n};\n\nexport type MultiRootHookReturns = {\n\teditor: MultiRootEditor | null;\n\teditableElements: Array<JSX.Element>;\n\ttoolbarElement: JSX.Element;\n\tdata: Record<string, string>;\n\tsetData: Dispatch<SetStateAction<Record<string, string>>>;\n\tattributes: Record<string, Record<string, unknown>>;\n\tsetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>>;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useEffect, useRef, type MutableRefObject } from 'react';\n\n/**\n * Custom hook that returns a mutable ref object indicating whether the component is unmounted or not.\n *\n * @returns The mutable ref object.\n */\nexport const useIsUnmountedRef = (): MutableRefObject<boolean> => {\n\tconst mountedRef = useRef<boolean>( false );\n\n\tuseEffect( () => {\n\t\t// Prevent issues in strict mode.\n\t\tmountedRef.current = false;\n\n\t\treturn () => {\n\t\t\tmountedRef.current = true;\n\t\t};\n\t}, [] );\n\n\treturn mountedRef;\n};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport { useState, useRef } from 'react';\nimport { uid, isSSR } from '@ckeditor/ckeditor5-integrations-common';\n\nimport { useIsUnmountedRef } from './useIsUnmountedRef.js';\nimport { useRefSafeCallback } from './useRefSafeCallback.js';\n\n/**\n * A hook that allows to execute an asynchronous function and provides the state of the execution.\n *\n * @param callback The asynchronous function to be executed.\n * @returns A tuple with the function that triggers the execution and the state of the execution.\n *\n * @example\n * ```tsx\n * const [ onFetchData, fetchDataStatus ] = useAsyncCallback( async () => {\n * \tconst response = await fetch( 'https://api.example.com/data' );\n * \tconst data = await response.json();\n * \treturn data;\n * } );\n *\n * return (\n * \t<div>\n * \t\t<button onClick={ onFetchData }>Fetch data</button>\n * \t\t{ fetchDataStatus.status === 'loading' && <p>Loading...</p> }\n * \t\t{ fetchDataStatus.status === 'success' && <pre>{ JSON.stringify( fetchDataStatus.data, null, 2 ) }</pre> }\n * \t\t{ fetchDataStatus.status === 'error' && <p>Error: { fetchDataStatus.error.message }</p> }\n * \t</div>\n * );\n * ```\n */\nexport const useAsyncCallback = <A extends Array<unknown>, R>(\n\tcallback: ( ...args: A ) => Promise<R>\n): AsyncCallbackHookResult<A, R> => {\n\t// The state of the asynchronous callback.\n\tconst [ asyncState, setAsyncState ] = useState<AsyncCallbackState<R>>( {\n\t\tstatus: 'idle'\n\t} );\n\n\t// A reference to the mounted state of the component.\n\tconst unmountedRef = useIsUnmountedRef();\n\n\t// A reference to the previous execution UUID. It is used to prevent race conditions between multiple executions\n\t// of the asynchronous function. If the UUID of the current execution is different than the UUID of the previous\n\t// execution, the state is not updated.\n\tconst prevExecutionUIDRef = useRef<string | null>( null );\n\n\t// The asynchronous executor function, which is a wrapped version of the original callback.\n\tconst asyncExecutor = useRefSafeCallback( async ( ...args: A ) => {\n\t\tif ( unmountedRef.current || isSSR() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentExecutionUUID = uid();\n\t\tprevExecutionUIDRef.current = currentExecutionUUID;\n\n\t\ttry {\n\t\t\t// Prevent unnecessary state updates, keep loading state if the status is already 'loading'.\n\t\t\tif ( asyncState.status !== 'loading' ) {\n\t\t\t\tsetAsyncState( {\n\t\t\t\t\tstatus: 'loading'\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Execute the asynchronous function.\n\t\t\tconst result = await callback( ...args );\n\n\t\t\t// Update the state if the component is still mounted and the execution UUID matches the previous one, otherwise\n\t\t\t// ignore the result and keep the previous state.\n\t\t\tif ( !unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID ) {\n\t\t\t\tsetAsyncState( {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tdata: result\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch ( error: any ) {\n\t\t\tconsole.error( error );\n\n\t\t\t// Update the state if the component is still mounted and the execution UUID matches the previous one, otherwise\n\t\t\tif ( !unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID ) {\n\t\t\t\tsetAsyncState( {\n\t\t\t\t\tstatus: 'error',\n\t\t\t\t\terror\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t} );\n\n\treturn [ asyncExecutor, asyncState ] as AsyncCallbackHookResult<A, R>;\n};\n\n/**\n * Represents the result of the `useAsyncCallback` hook.\n */\nexport type AsyncCallbackHookResult<A extends Array<unknown>, R> = [\n\t( ...args: A ) => Promise<R | null>,\n\tAsyncCallbackState<R>\n];\n\n/**\n * Represents the state of an asynchronous callback.\n */\nexport type AsyncCallbackState<T> =\n\t| {\n\t\tstatus: 'idle';\n\t}\n\t| {\n\t\tstatus: 'loading';\n\t}\n\t| {\n\t\tstatus: 'success';\n\t\tdata: T;\n\t}\n\t| {\n\t\tstatus: 'error';\n\t\terror: any;\n\t};\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport type { DependencyList } from 'react';\n\nimport { useAsyncCallback, type AsyncCallbackState } from './useAsyncCallback.js';\nimport { useInstantEffect } from './useInstantEffect.js';\n\n/**\n * A hook that allows to execute an asynchronous function and provides the state of the execution.\n * The asynchronous function is executed immediately after the component is mounted.\n *\n * @param callback The asynchronous function to be executed.\n * @param deps The dependency list.\n * @returns The state of the execution.\n *\n * @example\n * ```tsx\n * const asyncFetchState = useAsyncValue( async () => {\n * \tconst response = await fetch( 'https://api.example.com/data' );\n * \tconst data = await response.json();\n * \treturn data;\n * }, [] );\n *\n * if ( asyncFetchState.status === 'loading' ) {\n * \treturn <p>Loading...</p>;\n * }\n *\n * if ( asyncFetchState.status === 'success' ) {\n * \treturn <pre>{ JSON.stringify( asyncFetchState.data, null, 2 ) }</pre>;\n * }\n *\n * if ( asyncFetchState.status === 'error' ) {\n * \treturn <p>Error: { asyncFetchState.error.message }</p>;\n * }\n * ```\n */\nexport const useAsyncValue = <R>(\n\tcallback: () => Promise<R>,\n\tdeps: DependencyList\n): AsyncValueHookResult<R> => {\n\tconst [ asyncCallback, asyncState ] = useAsyncCallback( callback );\n\n\tuseInstantEffect( asyncCallback, deps );\n\n\t// There might be short delay between the effect and the state update.\n\t// So it is possible that the status is still 'idle' after the effect.\n\t// In such case, we should return 'loading' status because the effect is already queued to be executed.\n\tif ( asyncState.status === 'idle' ) {\n\t\treturn {\n\t\t\tstatus: 'loading'\n\t\t};\n\t}\n\n\treturn asyncState;\n};\n\n/**\n * The result of the `useAsyncValue` hook.\n */\nexport type AsyncValueHookResult<R> = Exclude<AsyncCallbackState<R>, { status: 'idle' }>;\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport {\n\tloadCKEditorCloud,\n\ttype CKEditorCloudConfig,\n\ttype CKEditorCloudResult\n} from '@ckeditor/ckeditor5-integrations-common';\n\nimport { useAsyncValue, type AsyncValueHookResult } from '../hooks/useAsyncValue.js';\n\n/**\n * Hook that loads CKEditor bundles from CDN.\n *\n * @template Config The type of the CKEditor Cloud configuration.\n * @param config The configuration of the hook.\n * @returns The state of async operation that resolves to the CKEditor bundles.\n * @example\n *\n * ```ts\n * const cloud = useCKEditorCloud( {\n * \tversion: '42.0.0',\n * \ttranslations: [ 'es', 'de' ],\n * \tpremium: true\n * } );\n *\n * if ( cloud.status === 'success' ) {\n * \tconst { ClassicEditor, Bold, Essentials } = cloud.CKEditor;\n * \tconst { SlashCommand } = cloud.CKEditorPremiumFeatures;\n * }\n * ```\n */\nexport default function useCKEditorCloud<Config extends CKEditorCloudConfig>(\n\tconfig: Config\n): CKEditorCloudHookResult<Config> {\n\t// Serialize the config to a string to fast compare if there was a change and re-render is needed.\n\tconst serializedConfigKey = JSON.stringify( config );\n\n\t// Fetch the CKEditor Cloud Services bundles on every modification of config.\n\tconst result = useAsyncValue(\n\t\tasync (): Promise<CKEditorCloudResult<Config>> => loadCKEditorCloud( config ),\n\t\t[ serializedConfigKey ]\n\t);\n\n\t// Expose a bit better API for the hook consumers, so they don't need to access the constructor through the `data` property.\n\tif ( result.status === 'success' ) {\n\t\treturn {\n\t\t\t...result.data,\n\t\t\tstatus: 'success'\n\t\t};\n\t}\n\n\treturn result;\n}\n\n/**\n * The result of the `useCKEditorCloud` hook. It changes success state to be more intuitive.\n */\ntype CKEditorCloudHookResult<Config extends CKEditorCloudConfig> =\n\t| Exclude<AsyncValueHookResult<CKEditorCloudResult<Config>>, { status: 'success' }>\n\t| ( CKEditorCloudResult<Config> & { status: 'success' } );\n","/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\n\nimport React, { type ReactNode, type ComponentType } from 'react';\nimport type {\n\tCKEditorCloudConfig,\n\tCKEditorCloudResult\n} from '@ckeditor/ckeditor5-integrations-common';\n\nimport useCKEditorCloud from './useCKEditorCloud.js';\n\n/**\n * HOC that injects the CKEditor Cloud integration into a component.\n *\n * @template A The type of the additional resources to load.\n * @param config The configuration of the CKEditor Cloud integration.\n * @returns A function that injects the CKEditor Cloud integration into a component.\n * @example\n\n * ```tsx\n * const withCKCloud = withCKEditorCloud( {\n * \tcloud: {\n * \t\tversion: '42.0.0',\n * \t\ttranslations: [ 'es', 'de' ],\n * \t\tpremium: true\n * \t}\n * } );\n *\n * const MyComponent = withCKCloud( ( { cloud } ) => {\n * \tconst { Paragraph } = cloud.CKEditor;\n * \tconst { SlashCommands } = cloud.CKEditorPremiumFeatures;\n * \tconst { YourPlugin } = cloud.CKPlugins;\n *\n * \treturn <div>CKEditor Cloud is loaded!</div>;\n * } );\n * ```\n */\nconst withCKEditorCloud = <Config extends CKEditorCloudConfig>( config: CKEditorCloudHocConfig<Config> ) =>\n\t<P extends object>(\n\t\tWrappedComponent: ComponentType<WithCKEditorCloudHocProps<Config> & P>\n\t): ComponentType<Omit<P, keyof WithCKEditorCloudHocProps<Config>>> => {\n\t\tconst ComponentWithCKEditorCloud = ( props: Omit<P, keyof WithCKEditorCloudHocProps<Config>> ) => {\n\t\t\tconst ckeditorCloudResult = useCKEditorCloud( config.cloud );\n\n\t\t\tswitch ( ckeditorCloudResult.status ) {\n\t\t\t\t// An error occurred while fetching the cloud information.\n\t\t\t\tcase 'error':\n\t\t\t\t\tif ( !config.renderError ) {\n\t\t\t\t\t\treturn 'Unable to load CKEditor Cloud data!';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn config.renderError( ckeditorCloudResult.error );\n\n\t\t\t\t// The cloud information has been fetched successfully.\n\t\t\t\tcase 'success':\n\t\t\t\t\treturn <WrappedComponent {...props as P} cloud={ ckeditorCloudResult } />;\n\n\t\t\t\t// The cloud information is being fetched.\n\t\t\t\tdefault:\n\t\t\t\t\treturn config.renderLoader?.() ?? null;\n\t\t\t}\n\t\t};\n\n\t\tComponentWithCKEditorCloud.displayName = 'ComponentWithCKEditorCloud';\n\n\t\treturn ComponentWithCKEditorCloud;\n\t};\n\nexport default withCKEditorCloud;\n\n/**\n * Props injected by the `withCKEditorCloud` HOC.\n *\n * @template Config The configuration of the CKEditor Cloud integration.\n */\nexport type WithCKEditorCloudHocProps<Config extends CKEditorCloudConfig = CKEditorCloudConfig> = {\n\n\t/**\n\t * The result of the CKEditor Cloud integration.\n\t */\n\tcloud: CKEditorCloudResult<Config>;\n};\n\n/**\n * The configuration of the CKEditor Cloud integration.\n *\n * @template Config The configuration of the CKEditor Cloud integration.\n */\ntype CKEditorCloudHocConfig<Config extends CKEditorCloudConfig> = {\n\n\t/**\n\t * The configuration of the CKEditor Cloud integration.\n\t */\n\tcloud: Config;\n\n\t/**\n\t * Component to render while the cloud information is being fetched.\n\t */\n\trenderLoader?: () => ReactNode;\n\n\t/**\n\t * Component to render when an error occurs while fetching the cloud information.\n\t */\n\trenderError?: ( error: any ) => ReactNode;\n};\n"],"names":["once","createDefer","useRef","useEffect","useCallback","_a","useState","uid","createIntegrationUsageDataPlugin","isCKEditorFreeLicense","appendExtraPluginsToEditorConfig","REACT_INTEGRATION_READ_ONLY_LOCK_ID","_","shallowCompareArrays","useContext","uniq","root","overwriteObject","overwriteArray","roots","memo","forwardRef","isSSR","loadCKEditorCloud"],"mappings":";;;;;;;EAAA;AAAA;AAAA;AAAA;AA6BO,QAAM,6BAAN,MAAM,2BAA6B;AAAA,IA+EzC,YAAa,SAAsB,WAAwC;AAzD1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0CAAmC;AAQnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oCAAmB;AAQnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kDAA8D,CAAA;AAe9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oCAA4B;AAAA,QACnC,+BAA+B;AAAA,QAC/B,oBAAoB;AAAA,MAAA;AA0KL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qCAAUA,4BAAAA,KAAM,MAAM;AACrC,cAAM,EAAE,cAAc,QAAQ,UAAU,eAAe;AAEvD,YAAK,OAAO,oBAAqB;AAChC,iBAAO,mBACL,KAAM,MAAM,WAAW,QAAS;AAAA,YAChC,SAAS;AAAA;AAAA,YAGT,aAAa,KAAK;AAAA,UAAA,CACjB,CAAE,EAGH,MAAO,CAAA,UAAS;AAChB,oBAAQ,MAAO,8BAA8B,KAAM;AAAA,UAAA,CAClD,EAED,KAAM,aAAc,OAAQ,EAC5B,KAAM,MAAM;AACZ,iBAAK,SAAS;AAAA,UAAA,CACb;AAAA,QAAA,OACG;AACN,iBAAO,gCAAgC;AACvC,uBAAc,QAAA;AAAA,QAAQ;AAAA,MACvB,CACC;AA/LD,WAAK,WAAW;AAChB,WAAK,aAAa;AAClB,WAAK,MAAA;AAAA,IAAM;AAAA;AAAA;AAAA;AAAA,IAMZ,IAAW,QAAkB;AAC5B,aAAO,KAAK;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMN,UAAgB;AACtB,WAAK,SAAS;AACd,WAAK,eAAe;AACpB,WAAK,uBAAuB,CAAA;AAC5B,WAAK,SAAS;AAAA,QACb,+BAA+B;AAAA,QAC/B,oBAAoB;AAAA,MAAA;AAAA,IACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQM,eAAgB,OAAiB;AACvC,WAAK,SAAS;AAEd,WAAK,qBAAqB,QAAS,CAAA,aAAY;AAE9C,YAAK,KAAK,WAAW,gBAAgB,CAAC,KAAK,WAAW,aAAc,KAAM,GAAI;AAC7E;AAAA,QAAA;AAGD,iBAAU,KAAM;AAAA,MAAA,CACf;AAEF,WAAK,uBAAuB,CAAA;AAAA,IAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYvB,cAAe,UAAiD;AACtE,YAAM,EAAE,QAAQ,qBAAA,IAAyB;AAEzC,UAAK,QAAS;AAEb,YAAK,KAAK,WAAW,gBAAgB,CAAC,KAAK,WAAW,aAAc,MAAO,GAAI;AAC9E;AAAA,QAAA;AAGD,iBAAU,MAAO;AAAA,MAAA,OACX;AACN,6BAAqB,KAAM,QAAS;AAAA,MAAA;AAAA,IACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAqBO,QAAc;AACrB,YAAM,EAAE,gBAAgB;AACxB,YAAM,EAAE,QAAQ,UAAU,WAAA,IAAe;AAKzC,YAAM,uBAAuB,YAAY,IAAK,QAAS,KAAK,QAAQ,QAAS,IAAK;AAIlF,YAAM,cAAcC,4BAAAA,YAAA;AACpB,WAAK,eAAe;AAOpB,YAAM,sBAAsB,qBAC1B,KAAM,MAAM;AACZ,YAAK,OAAO,+BAAgC;AAC3C,iBAAO,QAAQ,QAAS,MAAU;AAAA,QAAA;AAKnC,eAAO,qBAAqB,WAAW,MAAA,EAAQ,KAAM,CAAA,gBAAe;AACnE,cAAK,aAAc;AAClB,iBAAK,eAAgB,WAAY;AAAA,UAAA;AAGlC,iBAAO;AAAA,QAAA,CACN;AAEF,eAAO,OAAO;AAAA,MAAA,CACb,EACD,KAAM,OAAM,gBAAe;AAE3B,YAAK,eAAe,WAAW,YAAa;AAC3C,gBAAM,WAAW,WAAY;AAAA,YAC5B,SAAS;AAAA,YACT;AAAA,UAAA,CACC;AAAA,QAAA;AAAA,MACH,CACC,EAGD,KAAM,MAAM,YAAY,OAAQ,EAGhC,MAAO,CAAA,UAAS;AAChB,gBAAQ,MAAO,4BAA4B,KAAM;AAAA,MAAA,CAChD,EAGD,KAAM,MAAM;AACZ,YAAK,YAAY,IAAK,QAAS,MAAM,qBAAsB;AAC1D,sBAAY,OAAQ,QAAS;AAAA,QAAA;AAAA,MAC9B,CACC;AAEH,kBAAY,IAAK,UAAU,mBAAoB;AAAA,IAAA;AAAA,EA2CjD;AAlQC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAdY,4BAcY,eAAc,oBAAI,IAAA;AAdpC,MAAM,4BAAN;AAAA,EC7BP;AAAA;AAAA;AAAA;AAUA,QAAM,0BAA0B;AASzB,WAAS,iCACf,UACA,QACgF;AAChF,WAAO;AAAA,MACN,GAAG;AAAA,MACH,CAAE,uBAAwB,GAAG;AAAA,IAAA;AAAA,EAE/B;AAOO,WAAS,uCAAwC,QAA4D;AACnH,WAAO,OAAO,IAAK,uBAAwB;AAAA,EAC5C;AAAA,ECpCA;AAAA;AAAA;AAAA;AAYO,QAAM,kBAAkB,MAAiC;AAC/D,UAAM,aAAaC,MAAAA,OAAiB,KAAM;AAE1CC,UAAAA,UAAW,MAAM;AAChB,iBAAW,UAAU;AAErB,aAAO,MAAM;AACZ,mBAAW,UAAU;AAAA,MAAA;AAAA,IACtB,GACE,EAAG;AAEN,WAAO;AAAA,EACR;AAAA,ECxBA;AAAA;AAAA;AAAA;AAWO,QAAM,qBAAqB,CAA+B,OAAwC;AACxG,UAAM,cAAcD,MAAAA,OAAA;AACpB,gBAAY,UAAU;AAEtB,WAAOE,MAAAA;AAAAA,MACN,IAAK,SAAkB,YAAY,QAAwB,GAAG,IAAK;AAAA,MACnE,CAAA;AAAA,IAAC;AAAA,EAEH;AAAA,ECnBA;AAAA;AAAA;AAAA;AAgCO,QAAM,6BAA6B,CACzC;AAAA,IACC;AAAA,IACA;AAAA,EACD,MACU;AAEV,UAAM,iCAAiC,mBAAoB,+BAAgC,MAAM;AAAA,IAAA,EAAK;AAEtGD,UAAAA,UAAW,MAAM;;AAChB,UAAK,uBAAuB,WAAW,eAAgB;AACtD;AAAA,MAAA;AAGD,YAAM,EAAE,aAAa;AACrB,YAAM,WAAU,0CAAU,YAAV,mBAAmB;AAEnC,UAAK,CAAC,SAAU;AACf;AAAA,MAAA;AAID,YAAM,+BAA+B,MAAM,CAAE,GAAG,OAAQ,EAAE;AAAA,QACzD,CAAE,KAAK,WAAY;;AAClB,cAAK,OAAO,UAAU,SAAU;AAC/B,mBAAO;AAAA,UAAA;AAGR,gBAAM,WAAW,uCAAwC,OAAO,MAAO;AACvE,gBAAM,YAAWE,MAAA,qCAAU,SAAV,OAAAA,MAAkB,OAAO;AAE1C,cAAK,QAAS,IAAI;AAAA,YACjB,UAAU;AAAA,YACV;AAAA,UAAA;AAGD,iBAAO;AAAA,QAAA;AAAA,QAER,uBAAO,OAAQ,CAAA,CAAG;AAAA;AAAA,MAAA;AAInB,YAAM,uBAAuB,MAAM;AAClC;AAAA,UACC,6BAAA;AAAA,UACA;AAAA,QAAA;AAAA,MACD;AAID,YAAM,uBAAuB,CAAE,WAAoB;AAClD,eAAO,KAAM,SAAS,sBAAsB,EAAE,UAAU,UAAW;AACnE,eAAO,KAAM,WAAW,sBAAsB,EAAE,UAAU,UAAW;AAAA,MAAA;AAGtE,YAAM,0BAAmE,CAAE,GAAG,WAAY;AACzF,6BAAsB,MAAO;AAAA,MAAA;AAG9B,cAAQ,QAAS,oBAAqB;AACtC,cAAQ,GAAgC,OAAO,uBAAwB;AAGvE,UAAK,MAAM,KAAM,OAAQ,EAAE,KAAM,CAAA,WAAU,OAAO,UAAU,OAAQ,GAAI;AACvE,6BAAA;AAAA,MAAqB;AAGtB,aAAO,MAAM;AACZ,gBAAQ,IAAK,OAAO,uBAAwB;AAAA,MAAA;AAAA,IAC7C,GACE,CAAE,sBAAuB,CAAE;AAAA,EAC/B;AAAA,ECvGA;AAAA;AAAA;AAAA;AAyBO,QAAM,yBAAyB,MAAM,cAA4C,IAAK;AAW7F,QAAM,kBAAkB,CAAsC,UAAiD;AAC9G,UAAM;AAAA,MACL;AAAA,MAAI;AAAA,MAAS;AAAA,MACb;AAAA,MAAU;AAAA,MAAQ;AAAA,MAClB,iBAAiB;AAAA,MACjB,gBAAgB;AAAA,MAChB;AAAA,MACA,UAAU,CAAE,OAAO,YAAa,QAAQ,MAAO,OAAO,OAAQ;AAAA,IAAA,IAC3D;AAEJ,UAAM,eAAe,gBAAA;AACrB,UAAM,kCAAkCH,MAAAA,OAAuB,IAAK;AAIpE,UAAM,CAAE,wBAAwB,yBAA0B,IAAII,eAA0C;AAAA,MACvG,QAAQ;AAAA,IAAA,CACP;AAGFH,UAAAA,UAAW,MAAM;AAChB,UAAK,eAAgB;AACpB,kCAAA;AAAA,MAA0B,OACpB;AACN,kCAA2B;AAAA,UAC1B,QAAQ;AAAA,QAAA,CACP;AAAA,MAAA;AAAA,IACH,GACE,CAAE,IAAI,aAAc,CAAE;AAGzBA,UAAAA,UAAW,MAAM,MAAM;AACtB,UAAK,uBAAuB,WAAW,eAAgB;AACtD,+BAAuB,SAAS,QAAA;AAAA,MAAQ;AAAA,IACzC,GACE,CAAE,sBAAuB,CAAE;AAG9B,+BAA4B;AAAA,MAC3B;AAAA,MACA;AAAA,IAAA,CACC;AASF,aAAS,6BAA6B;AACrC,sCAAgC,UAAUI,gCAAA;AAE1C,aAAO,gCAAgC;AAAA,IAAA;AASxC,aAAS,eAAgB,kBAA2B;AACnD,aAAO,gCAAgC,YAAY,oBAAoB,aAAa;AAAA,IAAA;AAQrF,aAAS,4BAA4B;AAIpC,YAAM,2BAA2B,2BAAA;AACjC,YAAM,kBAAkB,IAAI,2BAA4B,SAAU,cAAe;AAGjF,sBAAgB,GAAI,SAAS,CAAE,GAAG,eAAgB;AAAA,QAAA;AAEjD,YAAK,eAAgB,wBAAyB,GAAI;AACjD,kBAAS,WAAW,OAAO;AAAA,YAC1B,OAAO;AAAA,YACP,oBAAoB,WAAW;AAAA,UAAA,CAC9B;AAAA,QAAA;AAAA,MACH,CACC;AAGF,sBAAgB,GAAI,eAAe,MAAM;AACxC,YAAK,WAAW,gBAAgB,UAAU,WAAW,eAAgB,wBAAyB,GAAI;AACjG;AAAA,YACC,gBAAgB;AAAA,YAChB;AAAA,UAAA;AAAA,QACD;AAAA,MACD,CACC;AAGF,sBACE,OAAQ,MAAO,EACf,KAAM,MAAM;AAEZ,YAAK,eAAgB,wBAAyB,GAAI;AACjD,oCAA2B;AAAA,YAC1B,QAAQ;AAAA,YACR,UAAU;AAAA,UAAA,CACT;AAAA,QAAA,OACI;AAEN,0BAAgB,QAAA;AAAA,QAAQ;AAAA,MACzB,CACC,EACD,MAAO,CAAA,UAAS;AAEhB,YAAK,eAAgB,wBAAyB,GAAI;AAEjD,kBAAS,OAAO;AAAA,YACf,OAAO;AAAA,YACP,oBAAoB;AAAA,UAAA,CACnB;AAEF,oCAA2B;AAAA,YAC1B,QAAQ;AAAA,YACR;AAAA,UAAA,CACC;AAAA,QAAA;AAAA,MACH,CACC;AAEH,aAAO;AAAA,IAAA;AAGR,+CACE,uBAAuB,UAAvB,EAAgC,OAAO,0BACtC,QACF;AAAA,EAEF;AAQO,QAAM,yBAAyB,CAAE,QACvC,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAY,YAAY,OAAO,CAAE,gBAAgB,eAAe,OAAQ,EAAE,SAAU,IAAI,MAAO;AAKjH,QAAM,mCAAmC,CAAwC,WACvF,CAAE,QACD,uBAAwB,GAAI,KAAK,IAAI,WAAW;AAK3C,QAAM,gCAAgC,iCAAkC,cAAe;AAOvF,QAAM,8BAA8B,CAAE,QAC5C,iCAAkC,aAAc,EAAG,GAAI,KACvD,IAAI,SAAS,UAAU;AAAA,EC5MxB;AAAA;AAAA;AAAA;AAaO,QAAM,kCAAkCC,4BAAAA;AAAAA,IAC9C;AAAA,IACA;AAAA,MACC,SAAS;AAAA,MACT,kBAAkB,MAAM;AAAA,IAAA;AAAA,EAE1B;AAAA,ECnBA;AAAA;AAAA;AAAA;AAgBO,WAAS,oCAAqC,cAA2C;AAI/F,QAAKC,4BAAAA,sBAAuB,aAAa,UAAW,GAAI;AACvD,aAAO;AAAA,IAAA;AAGR,WAAOC,4BAAAA,iCAAkC,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMtD;AAAA,IAAA,CACC;AAAA,EACH;AAAA,EChCA;AAAA;AAAA;AAAA;AAkCA,QAAMC,wCAAsC;AAAA,EAE5C,MAAqB,iBAAyC,MAAM,UAA0B;AAAA,IAY7F,YAAa,OAAwB;AACpC,YAAO,KAAM;AARN;AAAA;AAAA;AAAA;AAAA,0CAAe,MAAM,UAAA;AAKrB;AAAA;AAAA;AAAA,6CAAyF;AAKhG,WAAK,cAAA;AAAA,IAAc;AAAA;AAAA;AAAA;AAAA,IAMZ,gBAAsB;AAC7B,YAAM,EAAE,qBAAqB;AAE7B,UAAK,CAAC,kBAAmB;AACxB,eAAO,QAAQ,KAAM,2DAA4D;AAAA,MAAA;AAGlF,YAAM,CAAE,KAAM,IAAI,iBAAiB,MAAO,GAAI,EAAE,IAAK,MAAO;AAE5D,UAAK,SAAS,MAAM,iBAAiB,WAAY,OAAQ,GAAI;AAC5D;AAAA,MAAA;AAGD,cAAQ,KAAM,qFAAsF;AAAA,IAAA;AAAA,IAGrG,IAAY,kBAA8D;AACzE,YAAM,EAAE,oBAAoB;AAE5B,aAAO,kBAAkB,gBAAgB,QAAQ;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMlD,IAAW,WAA4E;AACtF,YAAM,EAAE,oBAAoB;AAE5B,aAAO,kBAAkB,gBAAgB,WAAW;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMrD,IAAW,SAAwB;AAClC,YAAM,EAAE,oBAAoB;AAE5B,aAAO,kBAAkB,gBAAgB,WAAW;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOrC,sBAAuB,WAA+C;AACrF,YAAM,EAAE,OAAO,gBAAA,IAAoB;AAGnC,UAAK,UAAU,OAAO,MAAM,IAAK;AAChC,eAAO;AAAA,MAAA;AAGR,UAAK,UAAU,oBAAoB,MAAM,iBAAkB;AAC1D,eAAO;AAAA,MAAA;AAGR,UAAK,iBAAkB;AACtB,wBAAgB,cAAe,CAAE,EAAE,eAAgB;AAClD,cAAK,KAAK,wBAAyB,OAAO,WAAW,QAAS,GAAI;AACjE,qBAAS,KAAK,IAAK,UAAU,IAAM;AAAA,UAAA;AAAA,QACpC,CACC;AAEF,YAAK,cAAc,WAAY;AAC9B,0BAAgB,cAAe,CAAE,EAAE,eAAgB;AAClD,gBAAK,UAAU,UAAW;AACzB,uBAAS,mBAAoBA,qCAAoC;AAAA,YAAA,OAC3D;AACN,uBAAS,oBAAqBA,qCAAoC;AAAA,YAAA;AAAA,UACnE,CACC;AAAA,QAAA;AAAA,MACH;AAGD,aAAO;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMQ,oBAA0B;AACzC,UAAK,CAAC,8BAA+B,KAAK,OAAQ,GAAI;AACrD,aAAK,wBAAA;AAAA,MAAwB;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAMe,qBAA2B;AAC1C,UAAK,CAAC,8BAA+B,KAAK,OAAQ,GAAI;AACrD,aAAK,wBAAA;AAAA,MAAwB;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAMe,uBAA6B;AAC5C,WAAK,0BAAA;AAAA,IAA0B;AAAA;AAAA;AAAA;AAAA,IAMxB,4BAA4B;AACnC,UAAK,KAAK,iBAAkB;AAC3B,aAAK,gBAAgB,QAAA;AACrB,aAAK,kBAAkB;AAAA,MAAA;AAAA,IACxB;AAAA;AAAA;AAAA;AAAA,IAMO,0BAA0B;AACjC,WAAK,0BAAA;AACL,WAAK,kBAAkB,IAAI,0BAA2B,KAAK,aAAa,SAAU;AAAA,QACjF,cAAc,CAAA,UAAS,SAAS,CAAC,CAAC,MAAM;AAAA,QACxC,OAAO,YAAY;;AAClB,cAAI;AACH,mBAAO,MAAM,KAAK,kBAAA;AAAA,UAAkB,SAC3B,OAAa;AACtB,6BAAK,OAAM,YAAX,4BAAsB,OAAO,EAAE,OAAO,kBAAkB,mBAAmB;AAG3E,kBAAM;AAAA,UAAA;AAAA,QACP;AAAA,QAED,YAAY,CAAE,EAAE,kBAAmB;AAClC,gBAAM,EAAE,YAAY,KAAK;AAEzB,cAAK,WAAW,KAAK,aAAa,YAAY,MAAO;AACpD,oBAAS,YAAY,QAAS;AAAA,UAAA;AAAA,QAC/B;AAAA,QAED,SAAS,OAAQ,EAAE,SAAS,kBAAmB;AAC9C,gBAAM,EAAE,mBAAmB,KAAK;AAEhC,cAAI;AACH,kBAAM,KAAK,eAAgB,WAAY;AAOvC,oBAAQ,YAAY;AAAA,UAAA,UACrB;AAKC,gBAAK,gBAAiB;AACrB,6BAAgB,YAAY,QAAS;AAAA,YAAA;AAAA,UACtC;AAAA,QACD;AAAA,MACD,CACC;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMa,SAA0B;AACzC,aACC,sBAAA,cAAC,OAAA,EAAI,KAAM,KAAK,cAAe;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAOjC,MAAc,oBAAkE;AAC/E,UAAK,KAAK,MAAM,iBAAkB;AACjC,cAAM,WAAW,MAAM,KAAK,cAAe,KAAK,aAAa,SAAU,KAAK,YAAa;AAEzF,eAAO;AAAA,UACN;AAAA,UACA,UAAU;AAAA,QAAA;AAAA,MACX;AAGD,YAAM,YAAa,MAAM;AAGxB,YAAK,4BAA6B,KAAK,OAAQ,GAAI;AAClD,iBAAO,IAAI,sBAAuB,KAAK,QAAQ,QAAS;AAAA,QAAA;AAGzD,eAAO,IAAI,KAAK,MAAM,OAAO,eAAgB,KAAK,MAAM,QAAQ,KAAK,MAAM,cAAe;AAAA,MAAA,GAC3F;AAEA,YAAM,mBAAmB;AAAA,QACxB,SAAS;AAAA,MAAA;AAGV,eAAS,WAAY,OAAQ,IAAI,WAAY;;AAC5C,cAAM,EAAE,oBAAoB;AAC5B,cAAM,EAAE,mBAAmB,KAAK;AAEhC,YAAK,iBAAiB,UAAU,KAAK,oBAAkB,wDAAiB,UAAjB,mBAAwB,WAAW;AACzF,yBAAgB,gBAAgB,MAAM,QAAS;AAAA,QAAA;AAGhD,cAAM,WAAW,MAAM,KAAK,cAAe,IAAW,MAAO;AAK7D,YAAK,mBAAmB,iBAAiB,UAAU,GAAI;AACtD,0BAAgB,eAAgB;AAAA,YAC/B;AAAA,YACA;AAAA,UAAA,CACC;AAEF,qBAAY,MAAM;AACjB,gBAAK,KAAK,MAAM,SAAU;AACzB,mBAAK,MAAM,QAAS,SAAU,MAAkB;AAAA,YAAA;AAAA,UACjD,CACC;AAAA,QAAA;AAGH,yBAAiB;AACjB,eAAO;AAAA,MAAA,CACN;AAEF,eAAS,GAAI,SAAS,CAAE,GAAG,EAAE,OAAO,oBAAqB;AACxD,cAAM,UAAU,KAAK,MAAM,WAAW,QAAQ;AAC9C,gBAAS,OAAO,EAAE,OAAO,WAAW,mBAAmB,eAAgB;AAAA,MAAA,CACtE;AAEF,YAAM,SAAS,OAAQ,KAAK,aAAa,SAAU,KAAK,YAAa;AAErE,aAAO;AAAA,QACN;AAAA,QACA,UAAU,SAAU;AAAA,MAAA;AAAA,IACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASO,cAAe,SAAwD,QAAyC;AACvH,YAAM,EAAE,wBAAwB,KAAK;AAErC,UAAK,qBAAsB;AAC1B,iBAAS,iCAAkC,qBAAqB,MAAO;AAAA,MAAA;AAGxE,aAAO,KAAK,MAAM,OAAO;AAAA,QACxB;AAAA,QACA,oCAAqC,MAAO;AAAA,MAAA,EAE3C,KAAM,CAAA,WAAU;AAChB,YAAK,cAAc,KAAK,OAAQ;AAAA,UAAA;AAG/B,cAAK,KAAK,MAAM,UAAW;AAC1B,mBAAO,mBAAoBA,qCAAoC;AAAA,UAAA;AAAA,QAChE;AAGD,cAAM,gBAAgB,OAAO,MAAM;AACnC,cAAM,eAAe,OAAO,QAAQ,KAAK;AAEzC,sBAAc,GAAI,eAAe,CAAA,UAAS;AAAA,UAAA;AAEzC,cAAK,KAAK,MAAM,UAAW;AAC1B,iBAAK,MAAM,SAAU,OAAO,MAAO;AAAA,UAAA;AAAA,QACpC,CACC;AAEF,qBAAa,GAAI,SAAS,CAAA,UAAS;AAAA,UAAA;AAElC,cAAK,KAAK,MAAM,SAAU;AACzB,iBAAK,MAAM,QAAS,OAAO,MAAO;AAAA,UAAA;AAAA,QACnC,CACC;AAEF,qBAAa,GAAI,QAAQ,CAAA,UAAS;AAAA,UAAA;AAEjC,cAAK,KAAK,MAAM,QAAS;AACxB,iBAAK,MAAM,OAAQ,OAAO,MAAO;AAAA,UAAA;AAAA,QAClC,CACC;AAEF,eAAO;AAAA,MAAA,CACN;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMJ,MAAc,eAAgB,kBAAsE;AACnG,YAAM,EAAE,UAAU,SAAA,IAAa;AAE/B,aAAO,IAAI,QAAe,CAAE,SAAS,WAAY;AAAA,QAAA;AAQhD,mBAAY,YAAY;AACvB,cAAI;AACH,gBAAK,UAAW;AACf,oBAAM,SAAS,QAAA;AACf,qBAAO,QAAA;AAAA,YAAQ;AAGhB,gBAAK,UAAW;AACf,oBAAM,SAAS,QAAA;AACf,qBAAO,QAAA;AAAA,YAAQ;AAGhB,oBAAA;AAAA,UAAQ,SACC,GAAI;AACb,oBAAQ,MAAO,CAAE;AACjB,mBAAQ,CAAE;AAAA,UAAA;AAAA,QACX,CACC;AAAA,MAAA,CACD;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUK,wBAAyB,WAAqC,WAAqC,QAA2B;AAKrI,UAAK,UAAU,SAAS,UAAU,MAAO;AACxC,eAAO;AAAA,MAAA;AAIR,UAAK,OAAO,KAAK,IAAA,MAAU,UAAU,MAAO;AAC3C,eAAO;AAAA,MAAA;AAGR,aAAO;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA,IAMA,aAA2B;AAClC,YAAM,SAAS,KAAK,MAAM,UAAU,CAAA;AAEpC,UAAK,KAAK,MAAM,QAAQ,OAAO,aAAc;AAC5C,gBAAQ;AAAA,UACP;AAAA,QAAA;AAAA,MAED;AAID,aAAO;AAAA,QACN,GAAG;AAAA,QACH,aAAa,OAAO,eAAe,KAAK,MAAM,QAAQ;AAAA,MAAA;AAAA,IACvD;AAAA,EAIF;AADC,gBA1YoB,UA0YG,eAAc;AAAA,EAmC/B,MAAM,sBAA8C;AAAA;AAAA;AAAA;AAAA,IAmB1D,YAAa,iBAAmC;AAf/B;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAKT;AAAA;AAAA;AAAA;AAMP,WAAK,mBAAmB;AACxB,WAAK,MAAMJ,gCAAA;AAAA,IAAI;AAAA;AAAA;AAAA;AAAA,IAMT,WAAY,SAA8C;AAChE,WAAK,WAAW;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASV,OAAQ,qBAA2C,QAAyC;AAClG,aAAO,KAAK,iBAAiB,IAAK;AAAA,QACjC;AAAA,QACA;AAAA,QACA,SAAS,KAAK;AAAA,QACd,IAAI,KAAK;AAAA,QACT,MAAM;AAAA,MAAA,CACL;AAAA,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOI,GAAI,GAAW,UAAuF;AAE5G,WAAK,iBAAiB,GAAI,aAAa,CAAEK,IAAG,EAAE,QAAQ,YAAa;AAClE,YAAK,WAAW,KAAK,KAAM;AAC1B,mBAAU,MAAM,EAAE,OAAO,eAAe,QAAY;AAAA,QAAA;AAAA,MACrD,CACC;AAAA,IAAA;AAAA,IAGI,UAA4B;AAWlC,UAAK,KAAK,iBAAiB,UAAU,SAAU;AAC9C,eAAO,KAAK,iBAAiB,OAAQ,KAAK,GAAI;AAAA,MAAA;AAG/C,aAAO,QAAQ,QAAA;AAAA,IAAQ;AAAA;AAAA;AAAA;AAAA,IAMxB,IAAW,SAAkB;AAC5B,aAAO,KAAK,iBAAiB,QAAS,KAAK,GAAI;AAAA,IAAA;AAAA,EAEjD;AAAA,ECriBA;AAAA;AAAA;AAAA;AAuBO,QAAM,+BAA+B,MAA4D;AACvG,UAAM,eAAeV,MAAAA,OAA6C,IAAK;AACvE,UAAM,CAAE,UAAU,WAAY,IAAII,MAAAA,SAAU,MAAM,KAAK,KAAM;AAE7D,UAAM,UAAU,MAAM;AACrB,kBAAa,KAAK,KAAM;AAAA,IAAA;AAGzB,UAAM,UAAU,CAAE,WAAoB,SAAU;AAC/C,UAAK,aAAa,SAAU;AAC3B,qBAAa,QAAQ,QAAA;AACrB,qBAAa,UAAU;AAAA,MAAA;AAGxB,UAAK,UAAW;AACf,oBAAa,KAAK,KAAM;AAAA,MAAA;AAAA,IACzB;AAGD,UAAM,iBAAiB,CAAE,UAAc;;AACtC,yBAAa,YAAb,mBAAsB,eAAgB;AACtC,cAAA;AAAA,IAAQ;AAGT,UAAM,gBAAgB,CAAE,aAA8C;AACrE,UAAK,aAAa,SAAU;AAC3B,qBAAa,QAAQ,cAAe,QAAS;AAAA,MAAA;AAAA,IAC9C;AAGD,UAAM,UAAU,CAAE,iBAAsD;AACvE,cAAS,KAAM;AACf,mBAAa,UAAU,aAAA;AAEvB,cAAA;AACA,oBAAe,OAAQ;AAAA,IAAA;AAGxB,UAAM,qBAAqB,CAAqB,SAAiC;AAAA,MAChF,IAAI,UAAU;AACb,YAAK,CAAC,aAAa,WAAW,CAAC,aAAa,QAAQ,OAAQ;AAC3D,iBAAO;AAAA,QAAA;AAGR,eAAO,aAAa,QAAQ,MAAO,GAAI;AAAA,MAAA;AAAA,IACxC;AAGD,WAAO;AAAA,MACN,IAAI,UAAU;AACb,eAAO,aAAa;AAAA,MAAA;AAAA,MAErB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAEF;AAAA,EClFA;AAAA;AAAA;AAAA;AAcO,WAAS,aAAiB,MAA2C;AAC3E,WAAO,CAAA,UAAS;AACf,WAAK,QAAS,CAAA,QAAO;AACpB,YAAK,OAAO,QAAQ,YAAa;AAChC,cAAK,KAAM;AAAA,QAAA,WACA,OAAO,MAAO;AACzB,cAAI,UAAU;AAAA,QAAA;AAAA,MACf,CACC;AAAA,IAAA;AAAA,EAEJ;AAAA,ECxBA;AAAA;AAAA;AAAA;AAcO,QAAM,mBAAmB,CAAE,IAAkB,SAAgC;AACnF,UAAM,CAAE,UAAU,OAAQ,IAAIA,MAAAA,SAAe,IAAK;AAElD,QAAK,CAACO,4BAAAA,qBAAsB,UAAU,IAAK,GAAI;AAC9C,SAAA;AACA,cAAS,CAAE,GAAG,IAAK,CAAE;AAAA,IAAA;AAAA,EAEvB;AAAA,ECrBA;AAAA;AAAA;AAAA;AAaO,QAAM,yBAAyB,CACrC,WACA,IACA,SACU;AACV,qBAAkB,MAAM;AACvB,UAAK,WAAY;AAChB,kBAAU,cAAe,EAAG;AAAA,MAAA;AAAA,IAC7B,GACE,CAAE,WAAW,GAAG,IAAK,CAAE;AAAA,EAC3B;AAAA,ECvBA;AAAA;AAAA;AAAA;AAqCA,QAAM,sCAAsC;AAG5C,QAAM,qBAAqB,CAAE,UAAqD;AACjF,UAAM,sBAAsBX,MAAAA,OAAqB,MAAM,oBAAoB,IAAK;AAChF,UAAM,YAAY,6BAAA;AAElB,UAAM,aAAsD;AAAA,MAC3D,UAAU,UAAU,mBAAoB,UAAW;AAAA,MACnD,UAAU,UAAU,mBAAoB,UAAW;AAAA,IAAA;AAGpD,UAAM,UAAUY,MAAAA,WAAY,sBAAuB;AAGnD,UAAM,CAAE,OAAO,QAAS,IAAIR,MAAAA,SAAyB,MAAM,OAAO,KAAM,MAAM,IAAK,CAAE;AAGrF,UAAM,CAAE,MAAM,OAAQ,IAAIA,MAAAA,SAAkC,EAAE,GAAG,MAAM,MAAO;AAG9E,UAAM,CAAE,YAAY,aAAc,IAAIA,MAAAA,SAAmD,EAAE,GAAG,MAAM,iBAAkB;AAEtH,UAAM,qBAAqBJ,MAAAA,OAAiB,IAAK;AAUjD,UAAM,kCAAkC,MAAM;AAC7C,YAAM,SAAS,WAAW,SAAS;AAEnC,UAAK,CAAC,QAAS;AACd;AAAA,MAAA;AAGD,YAAM,oCAAoC,CAAE,aAAoC;AAC/E,YAAK,SAAS,QAAQ,CAAC,OAAO,QAAQ,KAAK,WAAY,SAAS,IAAK,GAAI;AACxE,iBAAO,QAAQ,KAAK,cAAe,SAAS,cAAe,KAAM,GAAG,SAAS,IAAK;AAAA,QAAA;AAAA,MACnF;AAGD,aACE,OAAQ,OAAO,GAAG,KAAK,SAAU,EACjC,QAAS,iCAAkC;AAAA,IAAA;AAG9CC,UAAAA,UAAW,MAAM;AAChB,YAAM,mBAAmB,oBAAoB;AAG7C,UAAK,WAAW,CAAC,4BAA6B,OAAQ,GAAI;AACzD;AAAA,MAAA;AAID,UAAK,CAAC,oBAAoB,MAAM,kBAAkB,OAAQ;AACzD;AAAA,MAAA;AAGD,gBAAU,QAAS,MAAM,IAAI,0BAA2B,kBAAkB;AAAA,QACzE,OAAO;AAAA,QACP,YAAY,CAAE,EAAE,kBAAmB;AAClC,gBAAM,EAAE,YAAY;AAEpB,cAAK,WAAW,oBAAoB,YAAY,MAAO;AACtD,oBAAS,YAAY,QAAS;AAAA,UAAA;AAAA,QAC/B;AAAA,QAED,SAAS,OAAQ,EAAE,SAAS,kBAAmB;AAC9C,gBAAM,EAAE,mBAAmB;AAE3B,cAAI;AACH,kBAAM,eAAgB,WAAY;AAOlC,oBAAQ,YAAY;AAAA,UAAA,UACrB;AAKC,gBAAK,gBAAiB;AACrB,6BAAgB,YAAY,QAAS;AAAA,YAAA;AAAA,UACtC;AAAA,QACD;AAAA,MACD,CACC,CAAE;AAEJ,aAAO,MAAM;AACZ,wCAAA;AACA,kBAAU,QAAS,KAAM;AAAA,MAAA;AAAA,IAC1B,GACE,CAAE,MAAM,IAAI,MAAM,eAAe,mCAAS,MAAO,CAAE;AAKtD,UAAM,aAAa,MAAoB;AACtC,YAAM,SAAS,MAAM,UAAU,CAAA;AAE/B,UAAK,MAAM,QAAQ,OAAO,aAAc;AACvC,gBAAQ;AAAA,UACP;AAAA,QAAA;AAAA,MAED;AAGD,aAAO;AAAA,QACN,GAAG;AAAA,QACH,iBAAiB;AAAA,MAAA;AAAA,IAClB;AAMD,UAAM,eAAe,mBAAoB,CAAE,QAAyB,UAA4B;AAC/F,YAAM,gBAAgB,OAAQ,MAAM;AAEpC,UAAK,CAAC,MAAM,0BAA2B;AACtC,cAAM,UAAkC,CAAA;AACxC,cAAM,gBAAyD,CAAA;AAE/D,sBAAc,OAAO,WAAA,EACnB,QAAS,CAAA,WAAU;AACnB,cAAI;AAAA,UAAA;AAGJ,cAAK,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAW;AACzD,mBAAO,OAAO,SAAS;AAAA,UAAA,OACjB;AAEN,mBAAO,OAAO,MAAM;AAAA,UAAA;AAKrB,cAAK,CAAC,KAAK,cAAe;AACzB;AAAA,UAAA;AAGD,gBAAM,EAAE,aAAa;AAErB,kBAAS,QAAS,IAAI,OAAQ,QAAS,EAAE,UAAW;AAAA,QAAA,CACnD;AAEH,sBAAc,OAAO,gBAAA,EACnB,QAAS,CAAA,gBAAe;AAGxB,cAAK,YAAY,OAAQ;AACxB,gBAAK,QAAS,YAAY,IAAK,MAAM,QAAY;AAChD,qBAAO,QAAS,YAAY,IAAK;AAAA,YAAA;AAGlC;AAAA,UAAA;AAGD,gBAAM,WAAW,YAAY;AAE7B,wBAAe,QAAS,IAAI,OAAQ,kBAAmB,QAAS;AAAA,QAAA,CAC/D;AAEH,YAAK,OAAO,KAAM,OAAQ,EAAE,QAAS;AACpC,kBAAS,mBAAkB,EAAE,GAAG,cAAc,GAAG,UAAY;AAAA,QAAA;AAG9D,YAAK,OAAO,KAAM,aAAc,EAAE,QAAS;AAC1C,wBAAe,yBAAwB,EAAE,GAAG,oBAAoB,GAAG,gBAAkB;AAAA,QAAA;AAAA,MACtF;AAAA,MACD;AAGA,UAAK,MAAM,UAAW;AACrB,cAAM,SAAU,OAAO,MAAQ;AAAA,MAAA;AAAA,IAChC,CACC;AAKF,UAAM,YAAY,mBAAoB,CAAE,QAAyB,MAAiB,SAAkC;AACnH,YAAM,WAAW,KAAK;AAEtB,UAAK,CAAC,MAAM,0BAA2B;AACtC;AAAA,UAAS,CAAA,kBACN,EAAE,GAAG,cAAc,CAAE,QAAS,GAAG,OAAQ,QAAS,EAAE,SAAA,CAAW,EAAA;AAAA,QAAE;AAGpE;AAAA,UAAe,CAAA,wBACZ,EAAE,GAAG,oBAAoB,CAAE,QAAS,GAAG,OAAQ,kBAAmB,QAAS,EAAA;AAAA,QAAE;AAAA,MAChF;AAGD,eAAU,CAAA,cAAaY,iCAAM,CAAE,GAAG,WAAW,KAAK,QAAS,CAAE,CAAE;AAAA,IAAA,CAC9D;AAKF,UAAM,eAAe,mBAAoB,CAAE,SAA0B,MAAiB,SAAkC;AACvH,YAAM,WAAW,KAAK;AAEtB,UAAK,CAAC,MAAM,0BAA2B;AACtC,gBAAS,CAAA,iBAAgB;AAExB,gBAAM,EAAE,CAAE,QAAU,GAAG,GAAG,GAAG,YAAY;AAEzC,iBAAO,EAAE,GAAG,QAAA;AAAA,QAAQ,CACnB;AAEF,sBAAe,CAAA,uBAAsB;AAEpC,gBAAM,EAAE,CAAE,QAAU,GAAG,GAAG,GAAG,kBAAkB;AAE/C,iBAAO,EAAE,GAAG,cAAA;AAAA,QAAc,CACzB;AAAA,MAAA;AAGH,eAAU,eAAa,UAAU,OAAQ,CAAAC,UAAQA,UAAS,QAAS,CAAE;AAAA,IAAA,CACpE;AAQF,UAAM,gBAAgB,mBAAoB,CACzC,aACA,WAC8B;AAC9BC,kCAAAA,gBAAiB,EAAE,GAAG,MAAM,gBAAA,GAAmB,UAAW;AAC1DA,kCAAAA,gBAAiB,EAAE,GAAG,MAAM,KAAA,GAAQ,IAAK;AACzCC,kCAAAA,eAAgB,OAAO,KAAM,MAAM,IAAK,GAAG,KAAM;AAEjD,aAAO,MAAM,OAAO;AAAA,QACnB;AAAA,QACA,oCAAqC,MAAO;AAAA,MAAA,EAE3C,KAAM,CAAE,WAA6B;AACrC,cAAM,aAAa,OAAO,YAAA;AAG1BD,oCAAAA,gBAAiB,EAAE,GAAG,WAAA,GAAc,IAAK;AACzCA,oCAAAA,gBAAiB,EAAE,GAAG,OAAO,mBAAA,EAAmB,GAAK,UAAW;AAChEC,oCAAAA,eAAgB,OAAO,KAAM,UAAW,GAAG,KAAM;AAEjD,YAAK,MAAM,UAAW;AAAA,UAAA;AAGrB,iBAAO,mBAAoB,mCAAoC;AAAA,QAAA;AAGhE,cAAM,gBAAgB,OAAO,MAAM;AACnC,cAAM,eAAe,OAAO,QAAQ,KAAK;AAEzC,sBAAc,GAAI,eAAe,CAAA,QAAO,aAAc,QAAQ,GAAI,CAAE;AAEpE,eAAO,GAAkB,WAAW,CAAE,KAAK,SAAU,UAAW,QAAQ,KAAK,IAAK,CAAE;AACpF,eAAO,GAAqB,cAAc,CAAE,KAAK,SAAU,aAAc,QAAQ,KAAK,IAAK,CAAE;AAE7F,qBAAa,GAAI,SAAS,CAAA,UAAS;AAAA,UAAA;AAElC,cAAK,MAAM,SAAU;AACpB,kBAAM,QAAS,OAAO,MAAO;AAAA,UAAA;AAAA,QAC9B,CACC;AAEF,qBAAa,GAAI,QAAQ,CAAA,UAAS;AAAA,UAAA;AAEjC,cAAK,MAAM,QAAS;AACnB,kBAAM,OAAQ,OAAO,MAAO;AAAA,UAAA;AAAA,QAC7B,CACC;AAEF,eAAO;AAAA,MAAA,CACN;AAAA,IAAA,CACF;AAKF,UAAM,iBAAiB,CAAE,qBAAkF;AAC1G,YAAM,EAAE,UAAU,SAAA,IAAa;AAE/B,aAAO,IAAI,QAAe,CAAE,SAAS,WAAY;AAAA,QAAA;AAQhD,mBAAY,YAAY;AACvB,cAAI;AACH,gBAAK,UAAW;AACf,oBAAM,SAAS,QAAA;AACf,qBAAO,QAAA;AAAA,YAAQ;AAGhB,gBAAK,UAAW;AACf,oBAAM,SAAS,QAAA;AACf,qBAAO,QAAA;AAAA,YAAQ;AAGhB,oBAAA;AAAA,UAAQ,SACC,GAAI;AACb,oBAAQ,MAAO,CAAE;AACjB,mBAAQ,CAAE;AAAA,UAAA;AAAA,QACX,CACC;AAAA,MAAA,CACD;AAAA,IAAA;AAMH,UAAM,oBAAoB,YAA2C;AACpE,UAAK,MAAM,iBAAkB;AAC5B,cAAM,WAAW,MAAM,cAAe,MAAM,MAAa,YAAa;AAEtE,eAAO;AAAA,UACN;AAAA,UACA,UAAU;AAAA,QAAA;AAAA,MACX;AAGD,YAAM,YAAa,MAAM;AACxB,YAAK,4BAA6B,OAAQ,GAAI;AAC7C,iBAAO,IAAI,sBAAuB,QAAQ,QAAS;AAAA,QAAA;AAGpD,eAAO,IAAI,MAAM,OAAO,eAAgB,MAAM,QAAQ,MAAM,cAAe;AAAA,MAAA,GAC5E;AAEA,YAAM,mBAAmB;AAAA,QACxB,SAAS;AAAA,MAAA;AASV,eAAS,WAAY,OAAQ,GAAG,WAAY;AAC3C,cAAM,EAAE,mBAAmB;AAE3B,YAAK,iBAAiB,UAAU,KAAK,kBAAkB,WAAW,SAAS,SAAU;AACpF,yBAAgB,WAAW,SAAS,OAAQ;AAAA,QAAA;AAG7C,cAAM,WAAW,MAAM,cAAe,MAAa,MAAO;AAE1D,YAAK,iBAAiB,UAAU,GAAI;AACnC,oBAAU,eAAgB;AAAA,YACzB;AAAA,YACA;AAAA,UAAA,CACC;AAEF,qBAAY,MAAM;AAAA,YAAA;AAEjB,gBAAK,MAAM,SAAU;AACpB,oBAAM,QAAS,SAAU,MAAO;AAAA,YAAA;AAAA,UACjC,CACC;AAAA,QAAA;AAGH,yBAAiB;AACjB,eAAO;AAAA,MAAA,CACN;AAEF,eAAS,GAAI,SAAS,CAAE,GAAG,EAAE,OAAO,oBAAqB;AACxD,cAAM,UAAU,MAAM,WAAW,QAAQ;AACzC,gBAAS,OAAO,EAAE,OAAO,WAAW,mBAAmB,eAAgB;AAAA,MAAA,CACtE;AAEF,YAAM,SACJ,OAAQ,MAAa,YAAa,EAClC,MAAO,CAAA,UAAS;AAChB,cAAM,UAAU,MAAM,WAAW,QAAQ;AACzC,gBAAS,OAAO,EAAE,OAAO,kBAAkB,mBAAmB,OAAQ;AACtE,cAAM;AAAA,MAAA,CACL;AAEH,aAAO;AAAA,QACN;AAAA,QACA,UAAU,SAAU;AAAA,MAAA;AAAA,IACrB;AAGD,UAAM,gBAAgB,CACrB,eACA,aAII;AACJ,YAAM,oBAAoB,OAAO,KAAM,aAAc;AACrD,YAAM,eAAe,OAAO,KAAM,QAAS;AAE3C,aAAO;AAAA,QACN,WAAW,aAAa,OAAQ,CAAA,QAAO,CAAC,kBAAkB,SAAU,GAAI,CAAE;AAAA,QAC1E,aAAa,kBAAkB,OAAQ,CAAA,QAAO,CAAC,aAAa,SAAU,GAAI,CAAE;AAAA,MAAA;AAAA,IAC7E;AAGD,UAAM,mBAAqEd,MAAAA;AAAAA,MAC1E,CAAA,YAAW;AACV,kBAAU,cAAe,MAAM;AAC9B,6BAAmB,UAAU;AAC7B,kBAAS,OAAQ;AAAA,QAAA,CAChB;AAAA,MAAA;AAAA,MAEH,CAAE,OAAQ;AAAA,IAAA;AAGX,UAAM,yBAA4FA,MAAAA;AAAAA,MACjG,CAAA,kBAAiB;AAChB,kBAAU,cAAe,MAAM;AAC9B,6BAAmB,UAAU;AAC7B,wBAAe,aAAc;AAAA,QAAA,CAC5B;AAAA,MAAA;AAAA,MAEH,CAAE,aAAc;AAAA,IAAA;AAGjB,UAAM,iBACL,sBAAA;AAAA,MAAC;AAAA,MAAA;AAAA,QACA,KAAM;AAAA,QACN,QAAQ,WAAW,SAAS;AAAA,MAAA;AAAA,IAAA;AAI9B,2BAAwB,UAAU,SAAS,CAAE,EAAE,eAAgB;AAC9D,UAAK,MAAM,UAAW;AACrB,iBAAS,mBAAoB,mCAAoC;AAAA,MAAA,OAC3D;AACN,iBAAS,oBAAqB,mCAAoC;AAAA,MAAA;AAAA,IACnE,GACE,CAAE,MAAM,QAAS,CAAE;AAEtB,2BAAwB,UAAU,SAAS,CAAE,EAAE,eAAgB;AAE9D,UAAK,mBAAmB,SAAU;AACjC,2BAAmB,UAAU;AAE7B,cAAM,WAAW,OAAO,KAAM,IAAK;AACnC,cAAM,iBAAiB,OAAO,KAAM,UAAW;AAO/C,YAAK,CAAC,SAAS,MAAO,CAAA,QAAO,eAAe,SAAU,GAAI,CAAE,GAAI;AAC/D,kBAAQ,MAAO,kEAAmE;AAClF,gBAAM,IAAI,MAAO,kEAAmE;AAAA,QAAA;AAGrF,cAAM,aAAa,SAAS,YAAA;AAC5B,cAAM,mBAAmB,SAAS,mBAAA;AAElC,cAAM;AAAA,UACL,WAAW;AAAA,UACX,aAAa;AAAA,QAAA,IACV;AAAA,UACH;AAAA,UACA;AAAA,UAAuG,CAAA;AAAA,QAAC;AAGzG,cAAM,gBAAgB,SAAS;AAAA,UAAQ,CAAA,aACtC,WAAY,QAAS,MAAM,UAC3B,KAAK,UAAW,WAAY,QAAS,CAAE,MAAM,KAAK,UAAW,KAAM,QAAS,CAAE;AAAA,QAAA;AAG/E,cAAM,6BAA6B,eAAe,OAAQ,CAAA,aACzD,KAAK,UAAW,iBAAkB,QAAS,CAAE,MAAM,KAAK,UAAW,WAAY,QAAS,CAAE,CAAE;AAE7F,cAAM,kBAAkB,CAAEe,WAA0B;AACnDA,iBAAM,QAAS,CAAA,aAAY;AAC1B,qBAAU,QAAS,UAAU;AAAA,cAC5B,MAAM,KAAM,QAAS,KAAK;AAAA,cAC1B,aAAY,yCAAc;AAAA,cAC2D,CAAA;AAAA,cACrF,YAAY;AAAA,YAAA,CACX;AAAA,UAAA,CACD;AAAA,QAAA;AAGH,cAAM,sBAAsB,CAAEA,WAA0B;AACvDA,iBAAM,QAAS,CAAA,aAAY;AAC1B,qBAAU,WAAY,UAAU,IAAK;AAAA,UAAA,CACpC;AAAA,QAAA;AAGH,cAAM,oBAAoB,CAAEA,WAA0B;AACrD,gBAAM,eAAeA,OAAM;AAAA,YAC1B,CAAE,QAAQ,cAAgB,EAAE,GAAG,QAAQ,CAAE,QAAS,GAAG,KAAM,QAAS;YACpE,uBAAO,OAAQ,IAAK;AAAA,UAAA;AAErB,mBAAS,KAAK,IAAK,cAAc,EAAE,8BAA8B,MAAc;AAAA,QAAA;AAGhF,cAAM,0BAA0B,CAAE,QAAqBA,WAA0B;AAChFA,iBAAM,QAAS,CAAA,aAAY;AAC1B,mBAAO,KAAM,WAAa,QAAS,CAAE,EAAE,QAAS,CAAA,SAAQ;AACvD,uBAAS,sBAAuB,IAAK;AAAA,YAAA,CACpC;AAEF,mBAAO,gBAAiB,SAAS,MAAM,SAAS,QAAS,QAAS,CAAG;AACrE,mBAAO,cAAe,WAAa,QAAS,GAAG,SAAS,MAAM,SAAS,QAAS,QAAS,CAAG;AAAA,UAAA,CAC3F;AAAA,QAAA;AAIH,mBAAY,MAAM;AACjB,mBAAS,MAAM,OAAQ,CAAA,WAAU;AAChC,4BAAiB,QAAS;AAC1B,gCAAqB,YAAa;AAElC,gBAAK,cAAc,QAAS;AAC3B,gCAAmB,aAAc;AAAA,YAAA;AAGlC,gBAAK,2BAA2B,QAAS;AACxC,sCAAyB,QAAQ,0BAA2B;AAAA,YAAA;AAAA,UAC7D,CACC;AAAA,QAAA,CACD;AAAA,MAAA;AAAA,IACH,GACE,CAAE,MAAM,UAAW,CAAE;AAExB,UAAM,mBAAmB,MAAM;AAAA,MAC9B,CAAA,aACC,sBAAA;AAAA,QAAC;AAAA,QAAA;AAAA,UACA,KAAK;AAAA,UACL,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,QAAA;AAAA,MAAA;AAAA,IACD;AAIF,WAAO;AAAA,MACN,QAAQ,WAAW,SAAS;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,MAAM,SAAS;AAAA,MACf;AAAA,MAAY,eAAe;AAAA,IAAA;AAAA,EAE7B;AAEO,QAAM,iBAAiBC,MAAAA,KAAMC,MAAAA,WAAY,CAAE,EAAE,IAAI,WAAW,SAAA,GAIhE,QAAS;AACX,UAAM,WAAWnB,MAAAA,OAAwB,IAAK;AAE9CC,UAAAA,UAAW,MAAM;AAChB,UAAI;AACJ,UAAI;AAEJ,gBAAU,cAAe,CAAE,EAAE,eAAgB;AAC5C,YAAK,CAAC,SAAS,SAAU;AACxB;AAAA,QAAA;AAGD,iBAAS;AAET,cAAM,EAAE,IAAI,MAAA,IAAU;AACtB,cAAM,OAAO,MAAM,SAAS,QAAS,QAAS;AAE9C,YAAK,QAAQ,OAAO,GAAG,mBAAoB,QAAS,GAAI;AACvD,iBAAO,eAAgB,IAAK;AAAA,QAAA;AAG7B,mBAAW,GAAG,KAAK,eAAgB,UAAU,SAAS,OAAQ;AAC9D,WAAG,YAAa,QAAS;AAEzB,iBAAS,QAAQ,KAAK,YAAA;AAAA,MAAY,CACjC;AAEF,aAAO,MAAM;AAAA,QAAA;AAEZ,YAAK,UAAU,OAAO,UAAU,eAAe,SAAS,SAAU;AACjE,gBAAM,OAAO,OAAO,MAAM,SAAS,QAAS,QAAS;AAAA,UAAA;AAGrD,cAAK,MAAO;AACX,mBAAO,eAAgB,IAAK;AAAA,UAAA;AAAA,QAC7B;AAAA,MACD;AAAA,IACD,GACE,CAAE,UAAU,QAAS,CAAE;AAE1B,WACC,sBAAA;AAAA,MAAC;AAAA,MAAA;AAAA,QACA,KAAK,UAAU;AAAA,QACf;AAAA,QACA,KAAM,UAAW,KAAK,QAAS;AAAA,MAAA;AAAA,IAAA;AAAA,EAGlC,CAAE,CAAE;AAEJ,iBAAe,cAAc;AAEtB,QAAM,uBAAuBkB,MAAAA,WAAY,CAAE,EAAE,OAAA,GAAe,QAAS;AAC3E,UAAM,aAAanB,MAAAA,OAAwB,IAAK;AAEhDC,UAAAA,UAAW,MAAM;AAChB,YAAM,mBAAmB,WAAW;AAEpC,UAAK,CAAC,UAAU,CAAC,kBAAmB;AACnC,eAAO;AAAA,MAAA;AAGR,YAAM,UAAU,OAAO,GAAG,KAAK,QAAQ;AAEvC,uBAAiB,YAAa,OAAS;AAEvC,aAAO,MAAM;AACZ,YAAK,iBAAiB,SAAU,OAAQ,GAAI;AAC3C,2BAAiB,YAAa,OAAS;AAAA,QAAA;AAAA,MACxC;AAAA,IACD,GACE,CAAE,UAAU,OAAO,EAAG,CAAE;AAE3B,+CAAQ,OAAA,EAAI,KAAK,UAAW,YAAY,GAAI,GAAG;AAAA,EAChD,CAAE;AAEF,uBAAqB,cAAc;AAAA,ECvqBnC;AAAA;AAAA;AAAA;AAYO,QAAM,oBAAoB,MAAiC;AACjE,UAAM,aAAaD,MAAAA,OAAiB,KAAM;AAE1CC,UAAAA,UAAW,MAAM;AAEhB,iBAAW,UAAU;AAErB,aAAO,MAAM;AACZ,mBAAW,UAAU;AAAA,MAAA;AAAA,IACtB,GACE,EAAG;AAEN,WAAO;AAAA,EACR;AAAA,ECzBA;AAAA;AAAA;AAAA;AAmCO,QAAM,mBAAmB,CAC/B,aACmC;AAEnC,UAAM,CAAE,YAAY,aAAc,IAAIG,eAAiC;AAAA,MACtE,QAAQ;AAAA,IAAA,CACP;AAGF,UAAM,eAAe,kBAAA;AAKrB,UAAM,sBAAsBJ,MAAAA,OAAuB,IAAK;AAGxD,UAAM,gBAAgB,mBAAoB,UAAW,SAAa;AACjE,UAAK,aAAa,WAAWoB,4BAAAA,SAAU;AACtC,eAAO;AAAA,MAAA;AAGR,YAAM,uBAAuBf,4BAAAA,IAAA;AAC7B,0BAAoB,UAAU;AAE9B,UAAI;AAEH,YAAK,WAAW,WAAW,WAAY;AACtC,wBAAe;AAAA,YACd,QAAQ;AAAA,UAAA,CACP;AAAA,QAAA;AAIH,cAAM,SAAS,MAAM,SAAU,GAAG,IAAK;AAIvC,YAAK,CAAC,aAAa,WAAW,oBAAoB,YAAY,sBAAuB;AACpF,wBAAe;AAAA,YACd,QAAQ;AAAA,YACR,MAAM;AAAA,UAAA,CACL;AAAA,QAAA;AAGH,eAAO;AAAA,MAAA,SACE,OAAa;AACtB,gBAAQ,MAAO,KAAM;AAGrB,YAAK,CAAC,aAAa,WAAW,oBAAoB,YAAY,sBAAuB;AACpF,wBAAe;AAAA,YACd,QAAQ;AAAA,YACR;AAAA,UAAA,CACC;AAAA,QAAA;AAAA,MACH;AAGD,aAAO;AAAA,IAAA,CACN;AAEF,WAAO,CAAE,eAAe,UAAW;AAAA,EACpC;AAAA,ECjGA;AAAA;AAAA;AAAA;AAuCO,QAAM,gBAAgB,CAC5B,UACA,SAC6B;AAC7B,UAAM,CAAE,eAAe,UAAW,IAAI,iBAAkB,QAAS;AAEjE,qBAAkB,eAAe,IAAK;AAKtC,QAAK,WAAW,WAAW,QAAS;AACnC,aAAO;AAAA,QACN,QAAQ;AAAA,MAAA;AAAA,IACT;AAGD,WAAO;AAAA,EACR;AAAA,ECzDA;AAAA;AAAA;AAAA;AAkCA,WAAwB,iBACvB,QACkC;AAElC,UAAM,sBAAsB,KAAK,UAAW,MAAO;AAGnD,UAAM,SAAS;AAAA,MACd,YAAkDgB,4BAAAA,kBAAmB,MAAO;AAAA,MAC5E,CAAE,mBAAoB;AAAA,IAAA;AAIvB,QAAK,OAAO,WAAW,WAAY;AAClC,aAAO;AAAA,QACN,GAAG,OAAO;AAAA,QACV,QAAQ;AAAA,MAAA;AAAA,IACT;AAGD,WAAO;AAAA,EACR;AAAA,ECvDA;AAAA;AAAA;AAAA;AAuCA,QAAM,oBAAoB,CAAsC,WAC/D,CACC,qBACqE;AACrE,UAAM,6BAA6B,CAAE,UAA6D;;AACjG,YAAM,sBAAsB,iBAAkB,OAAO,KAAM;AAE3D,cAAS,oBAAoB,QAAA;AAAA,QAE5B,KAAK;AACJ,cAAK,CAAC,OAAO,aAAc;AAC1B,mBAAO;AAAA,UAAA;AAGR,iBAAO,OAAO,YAAa,oBAAoB,KAAM;AAAA,QAGtD,KAAK;AACJ,iBAAO,sBAAA,cAAC,kBAAA,EAAkB,GAAG,OAAY,OAAQ,qBAAsB;AAAA,QAGxE;AACC,kBAAO,kBAAO,iBAAP,gDAA2B;AAAA,MAAA;AAAA,IACpC;AAGD,+BAA2B,cAAc;AAEzC,WAAO;AAAA,EACR;;;;;;;;;;;;"}